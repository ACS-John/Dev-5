00001   print program$&" is not intended to be run directly" : end
00100   def fn_setup
00102     if ~setup then 
00104       let setup=1
00106       gosub SETUP_LIBRARY
00108       gosub SETUP_CONSTANTS
00110 !   gosub SETUP_SQL
00112     end if  ! ~setup
00114     goto SETUP_XIT
00120 SETUP_LIBRARY: !
00125     if ~setup_library then 
00130       let setup_library=1
00135       library "Print/Library": fnnum$,fnchar$,fnget_prnlegacyvar,fnget_prnvar$,fnsel_lib,fnclose
00140       library "Registry/Library": fnregunum_get,fnregunum_put
00145       library "OpenFile/Library": fnindex_handle,fnopen_master,fnopen_active,fnindex_handle_reset, fnopen_changes,fnclosed_changes, fnopen_dchanges,fnclosed_dchanges,fnopen_infinity,fnopen_debtor,fnopen_diary
00150       library "GridIO/Library": fnwindow_this_size$, fnfield_disable$,fnarray_sort,fnmenu2
00155       library "mergewp/prog2": fnd_rel
00160       library "Toolbar/Library": fnpk_cleanup$,fndisplay_menu_validate,fnsearch_menu
00165       library "SQL/Library": fnsql_setup
00166       library "Intermnt/prog2": fnmasforw_data$,fnclerkf_data$
00167       library "Phonelib/Library": fndphone2_debtor
00168       library "Select/Library": fnfilterselect
00170     end if  ! ~Setup_Library
00175     return  ! SETUP_LIBRARY
00200 SETUP_CONSTANTS: ! 
00205     if ~setup_constants then 
00210       let setup_constants=1
00215       let true=yes=1 : let false=no=0 : let cancel=esc=99 : let tab$=chr$(9) : let lf$=chr$(10) : let cr$=chr$(13) : let crlf$=cr$&lf$
00220       let pw_srow=1 : let pw_scol=2 : let pw_erow=3 : let pw_ecol=4 : let pw_rows=5 : let pw_cols=6 : let pw_tabcap=7 : let pw_tabcap_text=8 : let pw_parent=9 : let pw_border=10 : let pw_button_fkey=11 : let pw_button_text=12 : let pw_name=13 : let pw_attr_n=14 : let pw_button_help=15 : let pw_no_task_bar=16 : let pw_modal=17 : let pw_position=18 : let pw_fontsize=19 ! fnparse_window enumerations
00225 !   LET FKey_Menu=98 : FKey_Exit=93 : FKey_Escape=99 : FKey_AE_Field_Exit=107 : FKey_PageUp=90 : FKey_PageDown=91 :  FKey_Tab_Change=92 : FKey_Click=200 : FKey_Click_Double=201 ! Standard FKey Enumerations
00230       gosub SETUP_MESSAGEBOX
00235 !   CSZ_City=1 : CSZ_State=2 : CSZ_Zip=3 ! fnParse_CSZ$ Enumerations
00240 !   PN_Prefix=1 : PN_First=2 : PN_Middle=3 : PN_Last=4 : PN_Suffix=5 : PN_Type_Slash=1 : PN_Type_Space=2 ! fnParse_Name$ Enumerations
00245       let relation_masforw=1 : let relation_clerkf=2 : let relation_copf=3 : let relation_advafile=4 : let relation_bankfile=5 : let relation_masco=6 : let relation_attyfile=7 : let relation_secyfile=8 : let relation_clientf=9 : let relation_employer=10 : let relation_collfile=11 : let relation_sales=12 : let relation_group=13 : let relation_trustee=14 : let relation_lender=15 : let relation_broker=16 : let relation_judge=17 : let relation_insuranc=18 : let relation_titleco=19 : let relation_cccs=20 : let relation_procserv=21 : let relation_hospital=22 : let relation_medrec=23 : let relation_doctor=24 : let relation_mediator=25 : let relation_repo=26 : let relation_contact=27 : let relation_enetwork=28 ! Internal Backbone Relation Enumerations
00250 !   Zip_Zip_Code=1 : Zip_City_Name=2 : Zip_City_Name_Abbreviated=3 : Zip_City_Name_Addressable=4 : Zip_State=5 : Zip_County=6 : Zip_Area_Code=7 : Zip_Latitude=8 : Zip_Longitude=9 : Zip_Time_Zone=10 ! fnZip$ Enumerations
00255       mat empty$(0)
00260 !   File_EOF_Input=10 : File_EOF_Output=11 : File_IOErr_Input=20 : File_IOErr_Output=21 : File_Not_Open=-1 ! File Internal Function Enumerations
00265       let bar$=chr$(179)
00270       if uprc$(env$("Developer"))="YES" then let developer=1 else let developer=0
00275       if uprc$(env$("Debug"))="YES" then let debug=1 else let debug=0
00280       if uprc$(env$("Debug_Force_Stat_On"))="YES" then let debug_force_stat_on=1 else let debug_force_stat_on=0
00285       if serial=12906 and lwrc$(env$("UserName"))='jbowman' then let jbowman=1 else let jbowman=0
00290       let fnsessionsize_setup(screen_height,screen_width)
00295       if user_init$="" then let user_init$=fnuserinit$ ! moved from 86965
00300     end if  ! ~Setup_Constants
00305     return  ! SETUP_CONSTANTS
00310 SETUP_MESSAGEBOX: ! 
00312     if ~setup_messagebox then 
00314       let setup_messagebox=1
00316       let mb_ok=1 : let mb_cancel=2 : let mb_abort=3 : let mb_retry=4 : let mb_ignore=5 : let mb_yes=6 : let mb_no=7 ! fnMessageBox Response Enumerations
00318       let mb_stop=16 : let mb_question=32 : let mb_exclamation=48 : let mb_information=64 ! fnMessageBox Icon Enumerations
00320       let mb_button1_default=0 : let mb_button2_default=256 : let mb_button3_default=512 ! fnMessageBox Default Button Enumerations
00322       let mb_okonly=0 : let mb_okcancel=1 : let mb_abortretryignore=2 : let mb_yesnocancel=3 : let mb_yesno=4 : let mb_retrycancel=5 ! fnMessageBox Button Set Enumerations
00324     end if  ! ~setup_messagebox
00326     return 
00330 SETUP_ZONE_SECURITY: ! Setup Zone Security
00335     if ~setup_zone_security then 
00340       let setup_zone_security=1
00345       if ~setup_constants then gosub SETUP_CONSTANTS
00350       dim zone_line$(1)*80,zone_to_val(1),czone_line$(1)*80,zone_from$(1)*80,zone_to$(1)*20,zone_mask$(1)*20,zone_mask$*20,zone_field$(1)*80
00355       let fnasci_("SQL\Zones.ini",mat zone_line$)
00360       let nzones=udim(zone_line$)
00365       mat zone_from$(nzones)
00370       mat zone_to_val(nzones)
00375       mat zone_to$(nzones)
00380       mat zone_mask$(nzones)
00385       for zcount=1 to udim(mat zone_line$)
00390         let str2mat(zone_line$(zcount),mat zone_field$,tab$)
00395         let zone_field$(1)=trim$(uprc$(zone_field$(1)))
00400         mat zone_field$(3)
00405         let zone_mask$(zcount)=trim$(zone_field$(3))
00410         let zone_from$(zcount)='{'&zone_field$(1)&'}'
00415         let zone_to_val(zcount)=fnval_(zone_field$(2))
00420         let zone_to$(zcount)='{'&str$(zone_to_val(zcount))&'}'
00425       next zcount
00430 ! ---- Custom\Zones.ini ----
00435       let fnasci_("Custom\Zones.ini",mat czone_line$)
00440       for zcount=1 to udim(czone_line$)
00445         let str2mat(czone_line$(zcount),mat zone_field$,tab$)
00450         mat zone_field$(3)
00455         let zone_field$(1)=trim$(uprc$(zone_field$(1)))
00460         let zone_mask$=trim$(zone_field$(3))
00465         let zoneit=srch(mat zone_from$,'{'&zone_field$(1)&'}')
00470         if zoneit>0 then 
00475           let nxtzone=zoneit
00480         else 
00485           let nxtzone=udim(mat zone_from$)+1
00490           mat zone_from$(nxtzone)
00495           mat zone_to_val(nxtzone)
00500           mat zone_to$(nxtzone)
00505           mat zone_mask$(nxtzone)
00510         end if 
00515         let zone_from$(nxtzone)='{'&zone_field$(1)&'}'
00520         let zone_to_val(nxtzone)=fnval_(zone_field$(2))
00525         let zone_to$(nxtzone)='{'&str$(zone_to_val(nxtzone))&'}'
00530         let zone_mask$(nxtzone)=zone_mask$
00535       next zcount
00540       let policy_mask_ssn=max(0,fnsecurity_("MASK:SSN",'',0,user_init$,1)) 
00541       let policy_mask_dob=max(0,fnsecurity_("MASK:DOB",'',0,user_init$,1)) 
00542       let policy_mask_forw_fileno=max(0,fnsecurity_("MASK:FORW FILE NO",'',0,user_init$,1)) 
00543       let policy_mask_bank=max(0,fnsecurity_("MASK:BANK",'',0,user_init$,1)) 
00544       let policy_mask_orgactn=max(0,fnsecurity_("MASK:*OrgAct#",'',0,user_init$,1))
00545     end if  ! ~setup_zone_security
00549     return  ! SETUP_ZONE_SECURITY
00550 SETUP_EDI_TYPE_XLATE: ! 
00552     if ~setup_edi_type_xlate then 
00554       let setup_edi_type_xlate=1
00556       if ~setup_constants then gosub SETUP_CONSTANTS
00558       dim edi_code_xlate_line$(1)*40,edi_code_xlate_field$(1)*20,edi_code_xlate_from$(1)*20,edi_code_xlate_to$(1)*20
00560       mat edi_code_xlate_from$(0)
00562       mat edi_code_xlate_to$(0)
00564       if fnasci_('edi\edi_code.txt',mat edi_code_xlate_line$)=1 then 
00566         for edi_code_xlate_line_item=1 to udim(mat edi_code_xlate_line$) ! edi_code_xlate_line_count
00568           if str2mat(edi_code_xlate_line$(edi_code_xlate_line_item),mat edi_code_xlate_field$,tab$)=>2 then 
00570             let fn_add_one$(mat edi_code_xlate_from$,uprc$(edi_code_xlate_field$(1)))
00572             let fn_add_one$(mat edi_code_xlate_to$,edi_code_xlate_field$(2))
00574           end if  ! str2mat(...)=>2
00576         next edi_code_xlate_line_item
00578       end if  ! fnasci_=1
00580     end if  ! ~setup_edi_type_xlate
00582     return  ! SETUP_EDI_TYPE_XLATE
00590 SETUP_WHOAMI: ! 
00592     if ~setup_whoami then 
00594       if ~cls_setup then let fnclssetup
00596 !     dim whoami$*20
00598       open #h_whoami:=fngethandle_: "Name=N:WhoAmI,Shr",internal,input,relative ioerr SETUP_WHOAMI_FAIL ! SETUP_WHOAMI_BAD_USER
00600 !     read #h_whoami,using "FORM POS 1,C 20",rec=1: whoami$ norec SETUP_WHOAMI_BAD_USER
00602 !     read #h_whoami,using "form pos 1,c 8,4*BH 4",rec=2: initial$,mat my_preferences norec SETUP_WHOAMI_FAIL
00604       read #h_whoami,using "FORM POS 1,4*C 8",rec=3: user_new$,user_paper$,user_master$,user_acc$ norec SETUP_WHOAMI_FAIL
00606       let setup_whoami=1
00608       goto SETUP_WHOAMI_XIT
01270 SETUP_WHOAMI_FAIL: ! 
01272       let user_new$=user_paper$=user_master$=user_acc$='NNNNNNNN'
01274       goto SETUP_WHOAMI_XIT ! SETUP_WHOAMI_FAIL
01280 SETUP_WHOAMI_XIT: ! 
01282       close #h_whoami: ioerr ignore
01284       if trim$(user_new$)<>"" then let min_new$=user_new$
01286       if trim$(user_paper$)<>"" then let min_paper$=user_paper$
01288       if trim$(user_master$)<>"" then let min_master$=user_master$
01290       if trim$(user_acc$)<>"" then let min_acc$=user_acc$
01292     end if  ! ~setup_whoami
01294     return  ! SETUP_WHOAMI
01300 SETUP_XIT: ! 
01305   fnend  ! fn_setup
01310   def fncategdesc$*60(categ$)
01312     if ~setup_buckets then let fnsetup_buckets
01314     let ncateg=srch(mat categ_code$,uprc$(categ$)) 
01315     if ncateg>=0 then let fncategdesc$=categ_desc$(ncateg)
01316   fnend 
01320   def library fncateg_desc$*60(categ$)
01322     let fncateg_desc$=fncategdesc$(categ$)
01324   fnend 
01330   def library fncheck_buckets(mat buckets_code,mat buckets_amt,mat ta_desc$,mat ta_amt;c0de,amt1,l2_5)
01335     let nbuckets=udim(buckets_code) !:
          mat ta_desc$(nbuckets)=("") !:
          mat ta_amt(nbuckets)=(0)
01340 ! Do we need to include cost disb & other stuff?   We might
01345     let nskip=nscan=0 !:
          for nta=1 to nbuckets
01350       if buckets_code(nta)=0 or buckets_code(nta)=6100 or buckets_code(nta)=4100 then let nskip+=1 !:
              goto L1360 !:
              ! * Skip Stat Fees, no need to show on check !:
              ! ** Also Skip Costs Recovered, again no need to show on check
01355       let nscan+=1 !:
            let ta_code$=cnvrt$('PIC(####)',buckets_code(nta)) !:
            let ta_desc$(nscan)=ta_code$&" "&fncategdesc$(ta_code$) !:
            let ta_amt(nscan)=buckets_amt(nta) !:
            if ta_amt(nscan)>=404040404 or ta_amt(nscan)<=-202020202 then let ta_amt(nscan)=0
01360 L1360: next nta
01365 ! At this point mat TA_DESC$ has the Category code & description!:
          ! ** The check may only havea max of 6 items, and also, we need to hide some stuff
01370     let buff1$="" !:
          let nbuckets-=nskip !:
          mat ta_desc$(nbuckets): mat ta_amt(nbuckets) !:
          if nbuckets<=max_ta_lines then goto L1395
01375     let buff1$="" !:
          let temp_amt=0 !:
          for nta=max_ta_lines to nbuckets
01380       let buff1$(1:0)=ta_desc$(nta)(1:4)&" " !:
            let temp_amt+=ta_amt(nta)
01385     next nta
01390     mat ta_desc$(max_ta_lines) !:
          mat ta_amt(max_ta_lines) !:
          let ta_desc$(max_ta_lines)=buff1$&" - Multiple" !:
          let ta_amt(max_ta_lines)=temp_amt
01395 L1395: ! Only ## Buckets, ok to proceed !:
          ! ** Defined by max_ta_lines !:
          ! ** This is currently hard coded, but could be user defined
01400     if c0de=0 then let c0de=99 else !:
            if c0de>99 then let c0de=99
01405     let bucket_amt=amt1 !:
          if amt1=0 then let bucket_amt=l2_5
01410     if udim(ta_amt)<=0 then mat ta_desc$(1): mat ta_amt(1) !:
            let ta_desc$(1)=str$(c0de)&" - "&fncateg2_$(c0de) !:
            let ta_amt(1)=bucket_amt
01415   fnend 
01420   def fnos$
01425     if uprc$(env$("CLIENT_SERVER"))="YES" then let fnos$="Client Server" !:
            goto L1445
01430     if trim$(env$("Public"))<>"" and trim$(env$("CommonProgramFiles"))<>"" then let fnos$="7/Vista" !:
            goto L1445
01435 ! if TRIM$(ENV$("CommonProgramFiles"))<>"" then let fnOS$="Server" !:
          ! GOTO 1520 !:
          ! ** Note: XP has CommonProgramFiles (Sometimes) !:
          ! ** We need to find another qualifier
01440     if uprc$(env$("OS"))="WINDOWS_NT" then !:
            let fnos$="32 Bit" else !:
            if env$("winbootdir")<>"" then !:
              let fnos$="95/98" else !:
              if env$("Winbootdir")<>"" then !:
                let fnos$="98" else !:
                if env$("win")<>"" then !:
                  let fnos$="WIN" else !:
                  let fnos$=wbplatform$
01445 L1445: fnend 
01450   def library fnos_version$
01452     let fnos_version$=fnos$
01454   fnend 
01460   def library fnfl_case$*30(case$*30)
01462     if len(trim$(case$))<>20 then let fnfl_case$=trim$(case$) !:
            goto L1466
01464     let fnfl_case$=case$(1:2)&"-"&case$(3:6)&"-"&case$(7:8)&"-"&case$(9:14)&"-"&case$(15:18)&"-"&case$(19:20) !:
          goto L1466
01466 L1466: fnend 
01470   def library fnlaser(prnname$)
01472     if (prnname$(1:4)="HPLJ" or prnname$(1:4)="HPIV") or prnname$(1:4)="WIN-" or prnname$(1:4)="NWP-" then let fnlaser=1: goto L1474
01474 L1474: fnend 
01480   def library fnsetup_tz(mat tz$)
01482     mat tz$(24)=("") !:
          for n=1 to 24 !:
            let tz$(n)=cnvrt$('PIC(-##)',-n) !:
          next n
01484     let tz$(4)="ATL" !:
          let tz$(5)="EST" !:
          let tz$(6)="CST" !:
          let tz$(7)="MST" !:
          let tz$(8)="PST" !:
          let tz$(9)="AST" !:
          let tz$(10)="HAW" !:
          let tz$(11)="SAM"
01486   fnend 
01490   def library fnis_status(choice)
01492     let fnis_status=fnisstatus(choice)
01494   fnend 
01500   def fnisstatus(choice)
01505     if choice=8 or choice=10 or (choice>=13 and choice<=17) or (choice>=21 and choice<=25) then let fnisstatus=1
01510   fnend 
01520   def library fnscreen_choice(screen)
01522     let choice=1
01524     if screen>=1 and screen<=4 then let choice=5 !:
            goto L1534
01526     if screen=6 then let choice=2: !:
            goto L1534
01528     if screen=7 then let choice=3: !:
            goto L1534
01530     if screen=9 then let choice=4: !:
            goto L1534
01532     if screen>=11 and screen<=12 then let choice=6 !:
            goto L1534
01534 L1534: let fnscreen_choice=choice
01536   fnend 
01540   def library fnvalid_claim_status(choice)
01545     if (choice<=0 or choice>17) and (choice<>21) then let choice=13 !:
            ! - if No Choice Defined
01550     if fnisstatus(choice) then goto L1560
01555     let choice=13
01560 L1560: let fnvalid_claim_status=choice
01565   fnend 
01570   def library fnstatus_help$*1024
01572     dim thelp$*1024,int_table$(1)*80,int_date$(1)*10,int_rate(1)
01574     let thelp$="1B;1. NA\n2. NA\n3. NA\n4. NA\n5. NA"
01576     let thelp$(9999:0)="\n6. NA\n7. NA\n8. Full Status Screen\n9. NA\n10.Caption Summary [Block 4]"
01578     let thelp$(9999:0)="\n11.NA\n12.NA\n13.Legal Status Screen [Default]\n14.Status - Legacy - All Debtors\n15.Status - Legacy - Debtor 1\n16.Status - Legal Information;"
01580     let fnstatus_help$=thelp$
01582   fnend 
01590   def library fnvalid_claim_startup(choice)
01592     if choice<=0 or choice>17 then let choice=13 !:
            ! - if No Choice Defined
01594     if choice=11 or choice=12 then let choice=13
01596     if choice=5 then let choice=13
01598 ! if CHOICE=13 THEN LET CHOICE=13
01600     let fnvalid_claim_startup=choice
01602   fnend 
01610   def library fnstartup_help$*1024
01612     let thelp$="1B;1. Debtor Demographics\n2. Bankruptcy\n3. Debtor Jugment\n4. Debtor Caption\n5. NA"
01614     let thelp$(9999:0)="\n6. Placement Information\n7. Legal Info [Block 3]\n8. Full Status Screen\n9. Creditor/Plaintiff\n10.Caption Summary [Block 4]"
01616     let thelp$(9999:0)="\n11.NA\n12.NA\n13.Legal Status Screen [Default]\n14.Status - Legacy - All Debtors\n15.Status - Legacy - Debtor 1\n16.Status - Legal Information;"
01618     let fnstartup_help$=thelp$
01620   fnend 
01630   def library fninternal_setup(choice,&screen_num$,&file_name$,&screen$,&file_type$,&screen_dat$,&file_open$)
01632     on choice goto L1636,L1638,L1640,L1642,L1644,L1646,L1648,L1650,L1652,L1654,L1656,L1658,L1660,L1662,L1664,L1666,L1668,L1670,L1672,L1674,L1676,L1678,L1680,L1682,L1684,L1686,L1688,L1690
01634     let fnmessagebox_("Warning Invalid internal file ("&str$(choice)&") requested from FNINTERNAL_SETUP [Line 2000 in clsutil]",16,"Invalid Internal File") !:
          goto L1700
01636 L1636: let screen_num$="01" !:
          let file_name$="MASFORW" !:
          let screen$="SCREEN.I01//8" !:
          let file_type$="Forwarder" !:
          let screen_dat$="MASFORW.DAT/SQL" !:
          let file_open$="MASFORW//8" !:
          goto L1700
01638 L1638: let screen_num$="02" !:
          let file_name$="CLERKF" !:
          let screen$="SCREEN.I02//8" !:
          let file_type$="Clerk" !:
          let screen_dat$="CLERKF.DAT/SQL" !:
          let file_open$="CLERKF//9" !:
          goto L1700
01640 L1640: let screen_num$="03" !:
          let file_name$="COPF" !:
          let screen$="SCREEN.I03//8" !:
          let file_type$="Sheriff" !:
          let screen_dat$="COPF.DAT/SQL" !:
          let file_open$="COPF//9" !:
          goto L1700
01642 L1642: let screen_num$="04" !:
          let file_name$="ADVAFILE" !:
          let screen$="SCREEN.I04//8" !:
          let file_type$="Adversary" !:
          let screen_dat$="ADVAFILE.DAT/SQL" !:
          let file_open$="ADVAFILE//9" !:
          goto L1700
01644 L1644: let screen_num$="05" !:
          let file_name$="BANKFILE" !:
          let screen$="SCREEN.I05//8" !:
          let file_type$="Bank" !:
          let screen_dat$="BANKFILE.DAT/SQL" !:
          let file_open$="BANKFILE//9" !:
          goto L1700
01646 L1646: let screen_num$="06" !:
          let file_name$="MASCO" !:
          let screen$="SCREEN.I06//8" !:
          let file_type$="Co-counsel" !:
          let screen_dat$="MASCO.DAT/SQL" !:
          let file_open$="MASCO//8" !:
          goto L1700
01648 L1648: let screen_num$="07" !:
          let file_name$="ATTYFILE" !:
          let screen$="SCREEN.I07//8" !:
          let file_type$="Attorney" !:
          let screen_dat$="ATTYFILE.DAT/SQL" !:
          let file_open$="ATTYFILE//9" !:
          goto L1700
01650 L1650: let screen_num$="08" !:
          let file_name$="SECYFILE" !:
          let screen$="SCREEN.I08//8" !:
          let file_type$="Paralegal" !:
          let screen_dat$="SECYFILE.DAT/SQL" !:
          let file_open$="SECYFILE//9" !:
          goto L1700
01652 L1652: let screen_num$="09" !:
          let file_name$="CLIENTF" !:
          let screen$="SCREEN.I09//8" !:
          let file_type$="Creditor" !:
          let screen_dat$="CLIENTF.DAT/SQL" !:
          let file_open$="CLIENTF//9" !:
          goto L1700
01654 L1654: let screen_num$="10" !:
          let file_name$="EMPLOYER" !:
          let screen$="SCREEN.I10//8" !:
          let file_type$="Employer" !:
          let screen_dat$="EMPLOYER.DAT/SQL" !:
          let file_open$="EMPLOYER//9" !:
          goto L1700
01656 L1656: let screen_num$="11" !:
          let file_name$="COLLFILE" !:
          let screen$="SCREEN.I11//8" !:
          let file_type$="Collector" !:
          let screen_dat$="COLLFILE.DAT/SQL" !:
          let file_open$="COLLFILE//9" !:
          goto L1700
01658 L1658: let screen_num$="12" !:
          let file_name$="SALES" !:
          let screen$="SCREEN.I12//8" !:
          let file_type$="Salesperson" !:
          let screen_dat$="SALES.DAT/SQL" !:
          let file_open$="SALES//9" !:
          goto L1700
01660 L1660: let screen_num$="13" !:
          let file_name$="GROUP" !:
          let screen$="SCREEN.I13//8" !:
          let file_type$="Group" !:
          let screen_dat$="GROUP.DAT/SQL" !:
          let file_open$="GROUP//9" !:
          goto L1700
01662 L1662: let screen_num$="14" !:
          let file_name$="TRUSTEE" !:
          let screen$="SCREEN.I14//8" !:
          let file_type$="Trustee" !:
          let screen_dat$="TRUSTEE.DAT/SQL" !:
          let file_open$="TRUSTEE//9" !:
          goto L1700
01664 L1664: let screen_num$="15" !:
          let file_name$="LENDER" !:
          let screen$="SCREEN.I15//8" !:
          let file_type$="Lender" !:
          let screen_dat$="LENDER.DAT/SQL" !:
          let file_open$="LENDER//9" !:
          goto L1700
01666 L1666: let screen_num$="16" !:
          let file_name$="BROKER" !:
          let screen$="SCREEN.I16//8" !:
          let file_type$="Broker" !:
          let screen_dat$="BROKER.DAT/SQL" !:
          let file_open$="BROKER//9" !:
          goto L1700
01668 L1668: let screen_num$="17" !:
          let file_name$="JUDGE" !:
          let screen$="SCREEN.I17//8" !:
          let file_type$="Judge" !:
          let screen_dat$="JUDGE.DAT/SQL" !:
          let file_open$="JUDGE//9" !:
          goto L1700
01670 L1670: let screen_num$="18" !:
          let file_name$="INSURANC" !:
          let screen$="SCREEN.I18//8" !:
          let file_type$="Insurance" !:
          let screen_dat$="INSURANC.DAT/SQL" !:
          let file_open$="INSURANC//9" !:
          goto L1700
01672 L1672: let screen_num$="19" !:
          let file_name$="TITLECO" !:
          let screen$="SCREEN.I19//8" !:
          let file_type$="Title" !:
          let screen_dat$="TITLECO.DAT/SQL" !:
          let file_open$="TITLECO//9" !:
          goto L1700
01674 L1674: let screen_num$="20" !:
          let file_name$="CCCS" !:
          let screen$="SCREEN.I20//8" !:
          let file_type$="CCCS" !:
          let screen_dat$="CCCS.DAT/SQL" !:
          let file_open$="CCCS//9" !:
          goto L1700
01676 L1676: let screen_num$="21" !:
          let file_name$="PROCSERV" !:
          let screen$="SCREEN.I21//8" !:
          let file_type$="Procserv" !:
          let screen_dat$="PROCSERV.DAT/SQL" !:
          let file_open$="PROCSERV//9" !:
          goto L1700
01678 L1678: let screen_num$="22" !:
          let file_name$="HOSPITAL" !:
          let screen$="SCREEN.I22//8" !:
          let file_type$="Medical" !:
          let screen_dat$="HOSPITAL.DAT/SQL" !:
          let file_open$="HOSPITAL//9" !:
          goto L1700
01680 L1680: let screen_num$="23" !:
          let file_name$="MEDREC" !:
          let screen$="SCREEN.I23//8" !:
          let file_type$="Medrec" !:
          let screen_dat$="MEDREC.DAT/SQL" !:
          let file_open$="MEDREC//9" !:
          goto L1700
01682 L1682: let screen_num$="24" !:
          let file_name$="DOCTOR" !:
          let screen$="SCREEN.I24//8" !:
          let file_type$="Doctor" !:
          let screen_dat$="DOCTOR.DAT/SQL" !:
          let file_open$="DOCTOR//9" !:
          goto L1700
01684 L1684: let screen_num$="25" !:
          let file_name$="MEDIATOR" !:
          let screen$="SCREEN.I25//8" !:
          let file_type$="Mediator" !:
          let screen_dat$="MEDIATOR.DAT/SQL" !:
          let file_open$="MEDIATOR//9" !:
          goto L1700
01686 L1686: let screen_num$="26" !:
          let file_name$="REPO" !:
          let screen$="SCREEN.I26//8" !:
          let file_type$="Repossession Agent" !:
          let screen_dat$="REPO.DAT/SQL" !:
          let file_open$="REPO//9" !:
          goto L1700
01688 L1688: let screen_num$="27" !:
          let file_name$="CONTACT" !:
          let screen$="SCREEN.I27//8" !:
          let file_type$="Client Contact" !:
          let screen_dat$="CONTACT.DAT/SQL" !:
          let file_open$="CONTACT//9" !:
          goto L1700
01690 L1690: let screen_num$="28" !:
          let file_name$="ENETWORK" !:
          let screen$="SCREEN.I28//8" !:
          let file_type$="eNetwork" !:
          let screen_dat$="ENETWORK.DAT/SQL" !:
          let file_open$="ENETWORK.int//9" !:
          goto L1700
01700 L1700: ! END OF INTERNAL
01710   fnend 
01720   def library fnlist_queue(queue_handle,mat queues$)
01725     dim queues$(1)*8
01730     let next_queue$=last_queue$="" !:
          let queues=0 !:
          mat queues$(1)=("") !:
          let queue_handle_open=0
01735     if queue_handle=0 or lrec(queue_handle)<0 then !:
            let fndiary_rw_open !:
            open #queue_handle: "name=DIARY.INT//6,KFNAME=DIARY.QUE//6,SHR",internal,input,keyed  !:
            let queue_handle_open=1
01740     restore #queue_handle: 
01745     read #queue_handle,using L1750,release: fileno$,queue$ eof L1780 !:
          let queue$=uprc$(queue$) ! Always treate QUEUE$ as Upper case (CU 8).
01750 L1750: form pos 1,c 8,pos 49,c 8
01755     if last_queue$<>queue$ then !:
            let last_queue$=queue$ !:
            let queues+=1 !:
            mat queues$(queues) !:
            let queues$(queues)=queue$
01760     if queue$(8:8)<>"`" then !:
            let next_queue$=queue$(1:7)&chr$(ord(queue$(8:8))+1) else !:
            let next_queue$=queue$(1:7)&chr$(123)
01765     read #queue_handle,using L1750,search>=next_queue$,release: fileno$,queue$ nokey L1780 !:
          let queue$=uprc$(queue$) ! Always treate QUEUE$ as Upper case (CU 8).
01770     if queue$<next_queue$ then !:
            print bell;"Warning Diary Index is Damaged - QUEUE:";queue$;" NEXT QUEUE:";next_queue$;bell !:
            let sleep(1) !:
            goto L1780
01775     goto L1750
01780 L1780: let fnlist_queue=queues
01785     if queue_handle_open then close #queue_handle: 
01790   fnend 
01792 ! r: Diary//9 functions
01793   def library fnpick_diary(default; pick_diary_cache_reset)
01794     if pick_diary_cache_reset then let setup_diary=0
01795     if ~setup_diary then let fn_setup_diary
01796 ! PRINT FIELDS "24,1,CC 80,[S]": "Select the Desired Diary Code"
01797     if default=0 then 
01798       let default=1
01799     else 
01800       let pick_diary=0
01801       for ndia=1 to udim(diary_desc$)
01802         if diary_code(ndia)<=default then let pick_diary=ndia else let ndia=999
01803       next ndia
01804       let default=pick_diary
01805     end if 
01806     let pick_diary=fnwinscroll_(mat diary_desc$,default,"TITLE=Select Desired Diary Code HEADING=Diary;Queue;Description;Document")
01807     if (cmdkey=99 or cmdkey=93) then let pick_diary=default
01808     if pick_diary>=1 and pick_diary<=udim(diary_desc$) then let pick_diary=diary_code(pick_diary)
01809     let fnpick_diary=pick_diary
01810   fnend 
01811   def library fndiary_desc$*60(dcode)
01812     if ~setup_diary then let fn_setup_diary
01813     let ndcode=srch(mat diary_code,dcode)
01814     if ndcode>0 then let fndiary_desc$=diary_desc$(ndcode)(14:63)
01815   fnend 
01816   def library fndiary_span(dcode)
01817     if ~setup_diary then let fn_setup_diary
01818     let ndcode=srch(mat diary_code,dcode)
01819     if ndcode>0 then let fndiary_span=diary_span(ndcode)
01820   fnend 
01821   def library fndiary_autodel$(dcode)
01822     if ~setup_diary then let fn_setup_diary
01823     let ndcode=srch(mat diary_code,dcode)
01824     if ndcode>0 then let fndiary_autodel$=cache_diary_autodel$(ndcode)
01825   fnend 
01826   def library fndiary_protected$(dcode)
01827     if ~setup_diary then let fn_setup_diary
01828     let ndcode=srch(mat diary_code,dcode)
01829     if ndcode>0 then let fndiary_protected$=cache_diary_protected$(ndcode)
01830   fnend 
01831   def library fndiary_finan(dcode,mat finan)
01832     if ~setup_diary then let fn_setup_diary
01833     let ndcode=srch(mat diary_code,dcode)
01834     let diary_finan_return=0
01835     let df_finan_item=0
01836     if ndcode>0 then 
01837       let df_finan_size_max=udim(mat cache_diary_finan,2)
01838       mat finan(df_finan_size_max)
01839       for x=1 to df_finan_size_max
01840         if cache_diary_finan(ndcode,x)<>0 then 
01841           let df_finan_item+=1
01842           let finan(df_finan_item)=cache_diary_finan(ndcode,x)
01843         end if 
01844       next x
01845     end if 
01846     mat finan(df_finan_item)
01847     let diary_finan_return=udim(mat finan)
01848     let fndiary_finan=diary_finan_return
01849   fnend 
01850   def library fndiary_docs(dcode,mat docs$)
01851     if ~setup_diary then let fn_setup_diary
01852     let ndcode=srch(mat diary_code,dcode)
01853     if ndcode<=0 or trim$(diary_docs$(ndcode))="" then 
01854       mat docs$(1)=("")
01855       let fndiary_docs=0
01856     else 
01857       let str2mat(diary_docs$(ndcode),mat docs$,chr$(9))
01858       let fndiary_docs=udim(docs$)
01859     end if 
01860   fnend 
01861   def library fndiary_lrec
01862     if ~setup_diary then let fn_setup_diary
01863     let fndiary_lrec=ndiary ! Diary_Count - is the # of Entries in Array, not the Total # of Diaries in the system
01864   fnend 
01865   def library fndiary_queue$(dcode)
01866     if ~setup_diary then let fn_setup_diary
01867     let ndcode=srch(mat diary_code,dcode)
01868     if ndcode<=0 then let fndiary_queue$="" else let fndiary_queue$=diary_queue$(ndcode)
01869   fnend 
01870   def library fndiary_info(dcode,&queue$,&desc$; &span)
01871     let diary_info_return=0
01872     if ~setup_diary then let fn_setup_diary
01873     let ndcode=srch(mat diary_code,dcode)
01874     if ndcode>0 then 
01875       let queue$=diary_queue$(ndcode)
01876       let desc$=diary_desc$(ndcode)(14:63)
01877       let span=diary_span(ndcode)
01878       let diary_info_return=1
01879     else 
01880       let queue$=""
01881       let desc$=""
01882       let span=0
01883     end if 
01884     let fndiary_info=diary_info_return
01885   fnend 
01886   def library fndiary_data(dcode,mat diary_data$,mat diary_datan)
01887     let diary_data_return=0
01888     if ~setup_diary then let fn_setup_diary
01889     let ndcode=srch(mat diary_code,dcode)
01890     if ndcode>0 then 
01891       let str2mat(diary_docs$(ndcode),mat docs$,chr$(9))
01892       mat docs$(10)
01893       let diary_data$(diary_diary_des)=diary_desc$(ndcode)(14:63)
01894       let diary_data$(diary_document01)=docs$(01)
01895       let diary_data$(diary_document02)=docs$(02)
01896       let diary_data$(diary_document03)=docs$(03)
01897       let diary_data$(diary_document04)=docs$(04)
01898       let diary_data$(diary_document05)=docs$(05)
01899       let diary_data$(diary_document06)=docs$(06)
01900       let diary_data$(diary_document07)=docs$(07)
01901       let diary_data$(diary_document08)=docs$(08)
01902       let diary_data$(diary_document09)=docs$(09)
01903       let diary_data$(diary_document10)=docs$(10)
01904       let diary_data$(diary_autodel)=cache_diary_autodel$(ndcode)
01905       let diary_data$(diary_queue)=diary_queue$(ndcode)
01906       let diary_data$(diary_protected)=cache_diary_protected$(ndcode)
01907       let diary_datan(diary_finan01)=cache_diary_finan(ndcode,01)
01908       let diary_datan(diary_finan02)=cache_diary_finan(ndcode,02)
01909       let diary_datan(diary_finan03)=cache_diary_finan(ndcode,03)
01910       let diary_datan(diary_finan04)=cache_diary_finan(ndcode,04)
01911       let diary_datan(diary_finan05)=cache_diary_finan(ndcode,05)
01912       let diary_datan(diary_finan06)=cache_diary_finan(ndcode,06)
01913       let diary_datan(diary_finan07)=cache_diary_finan(ndcode,07)
01914       let diary_datan(diary_finan08)=cache_diary_finan(ndcode,08)
01915       let diary_datan(diary_finan09)=cache_diary_finan(ndcode,09)
01916       let diary_datan(diary_finan10)=cache_diary_finan(ndcode,10)
01917       let diary_datan(diary_recno)=ndcode
01918       let diary_datan(diary_span)=diary_span(ndcode)
01919       let diary_data_return=1
01920     else 
01921       mat diary_data$=("")
01922       mat diary_datan=(0)
01923     end if 
01924     let fndiary_data=diary_data_return
01925   fnend 
01926   def library fndiary_save(recno,mat diary_data$,mat diary_datan)
01927     if ~setup_diary_save then 
01928       let setup_diary_save=1
01929       if ~setup_library then gosub SETUP_LIBRARY
01930       if ~setup_sql_diary then let fn_setup_sql_diary
01931       let diary_save_h_diary=fnopen_diary(mat diary_save_h_diary_index)
01932     end if 
01933     let diary_save_return=0
01934     if recno<1 or recno>999 then let diary_save_return=-100000 : goto DIARY_SAVE_XIT
01935     do while lrec(diary_save_h_diary)<recno
01936       write #diary_save_h_diary,using 'Form pos 151,N 3': lrec(diary_save_h_diary)+1 error DIARY_SAVE_ERROR
01937     loop 
01938     rewrite #diary_save_h_diary,using diary_formall$,rec=recno: mat diary_data$,mat diary_datan error DIARY_SAVE_ERROR
01939     let setup_diary=0
01940     let diary_save_return=1
01941     goto DIARY_SAVE_XIT
01942 DIARY_SAVE_ERROR: ! 
01943     let diary_save_return=-err
01944 DIARY_SAVE_XIT: ! 
01946     let fndiary_save=diary_save_return
01947   fnend 
01950 ! /r ___________________________________________________________________
01952   def library fndoc_desc$*60(llcode$;letters_handle)
01954     let fndoc_desc$=fndoc_desc_$(llcode$,letters_handle)
01956   fnend 
01960   def fndoc_desc_$*60(llcode$;letters_handle)
01962     dim docdesc_ldesc$*30
01964     if fnreadletter_desc(llcode$,docdesc_ldesc$)=0 then let docdesc_ldesc$=""
01966     let fndoc_desc_$=docdesc_ldesc$
01968   fnend 
01970   def library fnscode_desc$*60(fileno$,scode;&scode_date,&scode_time,&scode_code$,paperless_handle,letters_handle)
01972     let scode_desc$=sfcode_desc$="" !:
          let tfileno$=scode_code$="" !:
          let tdate=ttime=scode_date=scode_time=0
01974     if paperless_handle<=0 then let paperless_handle=fngethandle_
01976     let paperless_open=0 !:
          if lrec(paperless_handle)<0 then !:
            open #paperless_handle: "NAME=ACTIVE.INT//6,KFNAME=ACTIVE.IDX//6,SHR",internal,outin,keyed ioerr L1992 !:
            let paperless_open=1
01978     dim scode_desc$*80,sfcode_desc$*80
01980     if scode>0 and scode<=lrec(paperless_handle) then !:
            let scode_desc$="** Please Index 1-9-X/1-9-W **" !:
            read #paperless_handle,using L1982,rec=scode,release: scode_fileno$,scode_date,scode_time,scode_desc$,scode_code$ norec L1990 else !:
            goto L1990
01982 L1982: form pos 1,c 8,2*bh 4,c 48,c 8
01984     if scode_fileno$<>fileno$ then !:
            let scode_code$="" !:
            let scode_desc$="** Please Index 1-9-X/1-9-W **" !:
            let scode_date=scode_time=0 !:
            goto L1990
01986     let buff$=fndoc_desc_$(scode_code$,50) !:
          if trim$(buff$)="" then let buff$=scode_desc$(29:48)
01988     let scode_desc$=buff$&scode_desc$(1:28)
01990 L1990: let fnscode_desc$=scode_desc$
01992 L1992: fnend 
02000   def fnclear
02002 L2002: ! This function will "Clear out" the keyboard buffer
02004     if trim$(kstat$)<>"" then goto L2002
02006   fnend 
02010   def library fnint_rec(fileno$,int_value,debtor_no,int_person,int_type$,int_handle)
02015     dim ikey$*23,finan_key$*29
02020     let ikey$=rpad$(fileno$,8)(1:8)&cnvrt$('N 3',debtor_no)&cnvrt$('N 2',int_person)&"Main"
02025     let ikey$=rpad$(ikey$,23)(1:23) !:
          rewrite #int_handle,using L2030,key=ikey$: int_value nokey L2035 !:
          goto L2045
02030 L2030: form pos 24,bh 3
02035 L2035: write #int_handle,using L2040: ikey$,int_value
02040 L2040: form pos 1,c 23,bh 3
02045 L2045: ! 
02049   fnend 
02050   def library fnget_iowin(;base)
02052     if base=0 then let base=409
02054 L2054: if file(base)<0 then let fnget_iowin=base !:
            goto L2059
02056     let base-=1 !:
          if base<1 then let base=999
02058     goto L2054
02059 L2059: fnend 
02060   def library fndefault_password$*25
02062     let fndefault_password$=hex$("25643F72107A7C147A1A4D0C4B0A46084C1B7E197C147A1A4D")
02064   fnend 
02070 ! =======================================================-)
02072   def library fn_encryptdecrypt(&strpassed$;&key_text$)
02074     let fn_encryptdecrypt=fnencryptdecrypt(strpassed$,key_text$)
02076   fnend 
02080   def fnencryptdecrypt(&strpassed$;&key_text$)
02085 ! STRPASSED is String to Encode or Decode !:
          ! KEY_TEXT is the Key used to encrypt !:
          ! Without the KEY, can't decode
02090 ! Encrypts Or Decrypts The String Passed
02095 ! ON ERROR GOTO ERRTRAP
02100     if key_text$="" then let key_text$="Def!Password!"
02105     let key_offset=25
02110     for lnum=1 to len(strpassed$)
02115       let key_pos=fn_mod(lnum,len(key_text$))+1
02120       let xor_char$=key_text$(key_pos:key_pos)
02125       if fn_mod(lnum,2) then 
02130         if ord(xor_char$)<=(255-key_offset) then !:
                let xor_char$=chr$(ord(xor_char$)+key_offset)
02135       else 
02140         if ord(xor_char$)>=key_offset then !:
                let xor_char$=chr$(ord(xor_char$)-key_offset)
02145       end if 
02150       let strpassed$(lnum:lnum)=chr$(fn_xor(ord(strpassed$(lnum:lnum)),ord(xor_char$)))
02155     next lnum
02159   fnend 
02160 ! ---------LIBRARY----------FNFIND_FIRST()------------------------------
02162   def library fnfind_first(mat array$,search$*80;search_start)
02164     let fnfind_first=fnfindfirst(mat array$,search$,search_start)
02166   fnend 
02170   def fnfindfirst(mat array$,search$*80;search_start)
02172     if search_start<1 then let search_start=1 else !:
            if search_start>udim(array$) then let search_start=udim(array$)
02174     let find_first=0 !:
          let search$=rtrm$(search$) !:
          let nlen=len(search$)
02176     for nfind=search_start to udim(array$)
02178       if uprc$(search$)=uprc$(ltrm$(array$(nfind))(1:nlen)) then !:
              let find_first=nfind !:
              let nfind=inf
02180     next nfind
02182     let fnfindfirst=find_first
02184   fnend 
02190 ! ---------LIBRARY----------FNFIND_FIRST_EXT()------------------------------
02192   def library fnfind_first_ext(mat array$,search$*80;search_start)
02194     let fnfind_first_ext=fnfindfirst_ext(mat array$,search$,search_start)
02196   fnend 
02200   def fnfindfirst_ext(mat array$,search$*80;search_start)
02202     dim array$*80
02204     if search_start<1 then let search_start=1 else !:
            if search_start>udim(array$) then let search_start=udim(array$)
02206     let find_first_ext=0 !:
          let search$=rtrm$(search$) !:
          let search$=uprc$(search$)
02208     for nfind=search_start to udim(array$)
02210       let array$=uprc$(array$(nfind)) !:
            let match=pos(array$,search$) !:
            if match>0 then !:
              let find_first_ext=nfind !:
              let nfind=inf
02212     next nfind
02214     let fnfindfirst_ext=find_first_ext
02216   fnend 
02220   def library fnnopaper$*1024(blank$*1024)
02222     let fnnopaper$=fnnopaper_$(blank$)
02224   fnend 
02230   def fnnopaper_$*1024(blank$*1024)
02232     if ~xlate_setup then let fnxlate_setup
02234     let blank$=xlate$(blank$,blank_xlate$) !:
          let blank$=srep$(blank$," ","")
02236     let fnnopaper_$=trim$(blank$)
02238   fnend 
02240   def library fny2k_date$(tdait$;y2k_setting$,y2k_name$*80,y2k_window,y2k_output$)
02245     if y2k_output$="" then let y2k_output$="CCYYMMDD"
02250     let y2k_problem=0
02255     let tdait$=srep$(tdait$,"-","/") !:
          if len(tdait$)=8 or (len(tdait$)=6 and pos(tdait$,"/")=0) or (len(tdait$)=10 or len(tdait$)=0) then goto L2270
02260     let td1=pos(tdait$,"/") !:
          if td1=0 then goto L2270
02265     let td2=pos(tdait$,"/",td1+1) !:
          let tdait$=cnvrt$('PIC(##)',val(tdait$(1:td1-1)))&"/"&cnvrt$('PIC(##)',val(tdait$(td1+1:td2-1)))&"/"&cnvrt$('PIC(##)',val(tdait$(td2+1:8))) conv L2340
02270 L2270: let tdait$=srep$(tdait$,"/","")
02275     let tdait=val(tdait$) conv L2320
02280     if trim$(y2k_setting$)<>"" and days(tdait,y2k_setting$) then !:
            let fny2k_date$=date$(days(tdait,y2k_setting$),y2k_output$) !:
            goto L2340
02285     if trim$(y2k_setting$)<>"" then let y2k_problem=9
02290     if tdait=0 then let y2k_problem=0 !:
            goto L2340
02295     if days(tdait,"CYMD") then !:
            let fny2k_date$=date$(days(tdait,"CYMD"),y2k_output$) !:
            let y2k_problem=1 : goto L2340
02300     if days(tdait,"MDCY") then !:
            let fny2k_date$=date$(days(tdait,"MDCY"),y2k_output$) !:
            let y2k_problem=2 : goto L2340
02305     if days(tdait,"YMD") then !:
            let fny2k_date$=date$(days(tdait,"YMD"),y2k_output$) !:
            let y2k_problem=3 : goto L2340
02310     if days(tdait,"MDY") then !:
            let fny2k_date$=date$(days(tdait,"MDY"),y2k_output$) !:
            let y2k_problem=4 : goto L2340
02315     goto L2340
02320 L2320: let tdait$=uprc$(srep$(tdait$,"-","/")) !:
          let tdait=val(srep$(tdait$,"/","")) conv L2325 !:
          goto L2270
02325 L2325: let td1=pos(tdait$,"/") !:
          let td2=pos(tdait$,"/",td1+1)
02330     let month=srch(mat months$,tdait$(td1+1:td2-1)) !:
          if month<=0 then goto L2340
02335     let tdait$=cnvrt$('PIC(##)',val(tdait$(td2+1:99)))&"/"&cnvrt$('PIC(##)',month)&"/"&cnvrt$('PIC(##)',val(tdait$(1:td1-1))) conv L2340 !:
          goto L2270
02340 L2340: ! THIS WAS_FNEND
02345     if trim$(y2k_setting$)<>"" and y2k_problem>2 then !:
            print #y2k_window: "Y2K ISSUE:";claimz$;" Should be in:";y2k_setting$;" Format" else !:
            if y2k_problem>3 then print #y2k_window: "Y2K ISSUE:";claimz$;" Claims are in Ambiguous Format & Will Fail in 2001!"
02350     if y2k_1st then goto L2419 else !:
            ! CHECK FOR Y2K PROBLEMS
02355       if trim$(y2k_setting$)<>"" then goto L2385 !:
              ! THIS SECTIONS TESTS STANDARDS THAT ARE NOT DEFINED!
02360       if y2k_problem<2 then goto L2419 !:
              ! Don't worry if date had century
02365       if y2k_problem=3 then print #y2k_window: "Warning Y2k issue: Dates Are Ambiguous, but in YY/MM/DD format" !:
              print #y2k_window: "Dates Should continue to work correctly" !:
              print #y2k_window: "Contact "&y2k_name$&" to enhance for Y2K" !:
              print #y2k_window: "Hit any key to continue" !:
              let kstat$(1) !:
              let y2k_1st=1 !:
              goto L2419
02370       if y2k_problem=4 then print #y2k_window: "Warning Y2k issue: Dates Are Ambiguous, and in MM/DD/YY format" !:
              print #y2k_window: "Dates Will only work until 12/31/2000" !:
              print #y2k_window: "Contact "&y2k_name$&" to enhance for Y2K" !:
              print #y2k_window: "Hit any key to continue" !:
              let kstat$(1) !:
              let y2k_1st=1 !:
              goto L2419
02375       if y2k_problem>4 then print #y2k_window: "Warning Y2k issue: Dates Are Ambiguous, unknown format" !:
              print #y2k_window: "Dates Will may not work properkly" !:
              print #y2k_window: "Contact CLS to enhance for Y2K" !:
              print #y2k_window: "Hit any key to continue" !:
              let kstat$(1) !:
              let y2k_1st=1 !:
              goto L2419
02380       goto L2419
02385 L2385: ! Y2K Date Formate Defined, but Data does not comply
02390 ! Check for Deviation from Defined Date Standard
02395       if y2k_problem<2 then goto L2419 !:
              ! Don't worry if date had century
02400       if y2k_problem=3 then print #y2k_window: "Warning Y2k issue: Dates Are Ambiguous, but in YY/MM/DD format" !:
              print #y2k_window: "Standard was defined as:"&y2k_setting$ !:
              print #y2k_window: "Dates Should continue to work correctly" !:
              print #y2k_window: "Contact "&y2k_name$&" to enhance for Y2K" !:
              print #y2k_window: "Hit any key to continue" !:
              let kstat$(1) !:
              let y2k_1st=1 !:
              goto L2419
02405       if y2k_problem=4 then print #y2k_window: "Warning Y2k issue: Dates Are Ambiguous, and in MM/DD/YY format" !:
              print #y2k_window: "Standard was defined as:"&y2k_setting$ !:
              print #y2k_window: "Dates Will only work until 12/31/2000" !:
              print #y2k_window: "Contact "&y2k_name$&" to enhance for Y2K" !:
              print #y2k_window: "Hit any key to continue" !:
              let kstat$(1) !:
              let y2k_1st=1 !:
              goto L2419
02410       if y2k_problem>4 then print #y2k_window: "Warning Y2k issue: Dates Are Ambiguous, unknown format" !:
              print #y2k_window: "Standard was defined as:"&y2k_setting$ !:
              print #y2k_window: "Dates Will may not work properkly" !:
              print #y2k_window: "Contact CLS to enhance for Y2K" !:
              print #y2k_window: "Hit any key to continue" !:
              let kstat$(1) !:
              let y2k_1st=1 !:
              goto L2419
02415       goto L2419
02419 L2419: fnend 
02420     def library fnmodify_paper
02422       if ~cls_setup then let fnclssetup
02424       let fnmodify_paper=modify_paper
02426     fnend 
02430     def library fntotclaim
02432       if ~cls_setup then let fnclssetup
02434       let fntotclaim=totclaim
02436     fnend 
02440     def library fnre_size(filename$*80,new_size)
02445       dim copy_tmp$*80
02450       open #(size_handle=fngethandle_): "NAME="&filename$,internal,outin 
02455       let current_size=rln(size_handle) !:
            close #size_handle: 
02460       if current_size>=new_size then goto L2485
02465       let npos=pos(filename$,"/") !:
            let copy_tmp$="COPY.TMP" !:
            if npos>0 then let copy_tmp$="COPY.TMP"&filename$(npos:999)
02470       execute "COPY "&filename$&" "&copy_tmp$
02475       execute "COPY "&copy_tmp$&" "&filename$&" -"&str$(new_size)
02480       if exists(filename$) then !:
              execute "free "&copy_tmp$
02485 L2485: fnend 
02490     def fnget_trust
02495       let max_trust=0 !:
            mat account$(1)=("") !:
            mat des$(1)=("") !:
            mat mnu$(1)=("") !:
            let trustact_data_type$(1)=("")
02500       dim des$*80,path$*80,account$(1)*80,des$(1)*80,line1(6),line2(8)
02505 ! if ~SETUP_CATEG then let fnSETUP_CATEG !:
            ! ** This line removed 8/13/2003 - Caused a DIM Problem because CATEG has not yet been defined! !:
            ! I don't see any reference to categs here, do we need?
02510       let trust_handle=fngethandle_ !:
            open #trust_handle: "name=trustact/common/5,shr",internal,outin,relative ioerr L2545
02515       for ntrust=1 to lrec(trust_handle)
02520         read #trust_handle,using "FORM POS 1,C 40,C 28,C 2,C 4",rec=ntrust,release: path$,des$,type$,mnu$
02525         if exists(path$) and pos(uprc$(path$),"\ACCOUNT")>0 then !:
                let max_trust+=1 !:
                mat account$(max_trust): mat des$(max_trust): mat mnu$(max_trust) : mat trustact_data_type$(max_trust) !:
                let xx=pos(path$,"\ACCOUNT"): let account$(max_trust)=path$(1:xx-1) !:
                let des$(max_trust)=des$ !:
                let mnu$(max_trust)=mnu$ !:
                let trustact_data_type$(max_trust)=type$
02530       next ntrust
02535       close #trust_handle: 
02540       let setup_trust=1
02545 L2545: fnend 
02550     def library fnfind_ta(tanum$,mat find_ta$)
02555       if ~setup_trust then let fnget_trust
02560       mat find_ta$(1)=("") !:
            let find_ta=0 !:
            let tanum=val(tanum$) conv L2629 !:
            let ta_search$=cnvrt$('PD 4',tanum) error L2629
02565       for ntrust=1 to max_trust
02570         let trust_handle=fngetfile("NAME=K:"&account$(ntrust)&"\FINSUM,KFNAME=K:"&account$(ntrust)&"\FNSUMTA.IDX,SHR","INPUT")
02575         if trust_handle<=0 then goto L2620
02580         read #trust_handle,using L2585,search>=ta_search$,release: fileno$,dait$,mat line1,mat line2,refno,trans_code,trans_code$ ioerr L2615
02585 L2585:  form pos 1,2*c 8,pos 263,6*pd 6.2,8*pd 6.2,pos 455,pd 4,pos 477,b 2,pos 517,c 8
02590 L2590:  if refno<>tanum then goto L2615
02591         let active_code=val(trans_code$) conv L2595 !:
              if active_code>=1 and int(active_code)<=99 then !:
                let trans_code=active_code
02595 L2595:  let categ2$="" !:
              if trans_code>=1 and int(trans_code)<=udim(categ2$) then let categ2$=fncateg2_$(trans_code)
02600         let find_ta+=1 !:
              mat find_ta$(find_ta) !:
              let find_ta$(find_ta)=fileno$&""&cnvrt$('PIC(-##)',trans_code)&""&fndate_dis10_$(dait$)&""&rpad$(categ2$(1:45),45)&""&mnu$(ntrust)&"-"&des$(ntrust)(1:18)&""&cnvrt$('PIC($,$$$,$$$.##-)',line1(6)+line2(5))
02605         read #trust_handle,using L2585,release: fileno$,dait$,mat line1,mat line2,refno,trans_code ioerr L2615
02610         goto L2590
02615 L2615:  close #trust_handle: ioerr L2620
02620 L2620: next ntrust
02625       let fnfind_ta=find_ta
02629 L2629: fnend 
02630     def library fntrust_code_is_valid(tcv_code$)
02632       if ~setup_trust then let fnget_trust
02634       let tcv_return=0
02636       if srch(mat mnu$,tcv_code$)>0 then let tcv_return=1
02638       let fntrust_code_is_valid=tcv_return
02639     fnend  ! fntrust_code_is_valid
02640     def library fnsetup_trust(mat setup_account$,mat setup_des$)
02642       if ~setup_trust then let fnget_trust
02644       let ntrust=udim(account$) !:
            mat setup_account$(ntrust)=account$ !:
            mat setup_des$(ntrust)=des$
02646       let fnsetup_trust=ntrust
02648     fnend 
02650     def library fnsetup_trust_type(mat trustact_data_type_list$)
02652       if ~setup_trust then let fnget_trust
02654       let trustact_data_type_count=udim(mat trustact_data_type$)
02656       mat trustact_data_type_list$(trustact_data_type_count)=trustact_data_type$
02658     fnend  ! fnSetup_Trust_Code
02660     def library fnsetup_trust_code(mat setup_mnu$)
02662       if ~setup_trust then let fnget_trust
02664       let ntrust=udim(account$)
02666       mat setup_mnu$(ntrust)=mnu$
02668     fnend  ! fnSetup_Trust_Code
02670     def library fntrust(trust$)
02672       if ~setup_trust then let fnget_trust
02674       let fntrust=srch(mat mnu$,rpad$(trust$,4))
02676     fnend 
02680     def library fntrust_lock(; tl_cap$*80,tl_trust_path$*256)
02682       let fntrust_lock=fn_trust_lock( tl_cap$,tl_trust_path$)
02684     fnend  ! FnTrust_Lock
02690     def fn_trust_lock(; tl_cap$*80,tl_trust_path$*256)
02692 ! returns 0 if failure to lock or handle if successful.
02694       if tl_trust_path$='' then let tl_trust_path$='/7'
02696       let tl_return=0
02698       open #tl_postingint_handle:=fngethandle_: "Name=Posting.Int/"&tl_trust_path$&",Shr,RecL=512,Use",internal,outin,relative ioerr TL_OPEN_POSTINGINT_IOERR
02700       let tl_return=tl_postingint_handle
02702       goto TL_XIT
02704 TL_OPEN_POSTINGINT_IOERR: ! 
02706       if tl_cap$<>'' then let tl_cap$=tl_cap$&' - '(1:80)
02708       let fn_stat_locks("There is a posting conflict.\nWait for reporting to be completed.",tl_cap$&"Posting Locked")
02710       let tl_return=0
02712       goto TL_XIT ! TL_OPEN_POSTINGINT_IOERR
02714 TL_XIT: ! 
02716       let fn_trust_lock=tl_return
02718     fnend  ! Fn_Trust_Lock
02720     def library fntrust_unlock(;tu_lock_handle)
02722       let fntrust_unlock=fn_trust_unlock(tu_lock_handle)
02724     fnend  ! fntrust_unlock(; tl_cap$*80,tl_trust_path$*256)
02730     def fn_trust_unlock(;tu_lock_handle)
02732       if tu_lock_handle=0 then let tu_lock_handle=tl_postingint_handle
02734       if tu_lock_handle>0 then 
02736         close #tu_lock_handle: ioerr ignore
02738       end if  ! tu_lock_handle>0
02739     fnend  ! fn_trust_unlock
02740     def library fncheck_time(queue_handle,queue$,dait$,mat diary_time$,mat diary_fileno$,mat diary_item$,mat diary_key$,mat diary_recno)
02745       let diary_time=0 !:
            mat diary_time$(0)=("") !:
            mat diary_fileno$(0)=("") !:
            mat diary_item$(0)=("") !:
            mat diary_key$(0)=("") !:
            mat diary_recno(0)=(0)
02750       if ~setup_diary then let fn_setup_diary
02755       let last_diary_key$="" !:
            if trim$(queue$)="" then let queue$=rpad$("QUSER"&session$,8)(1:8)
02760       dim last_diary_key$*80,diary_key$*80,diary_sort,diary_work$(1)*132,diary_work(1),diary_desc$*80
02765       let orig_queue_handle=queue_handle
02770       if queue_handle=0 or trim$(file$(queue_handle))="" then !:
              let fndiary_rw_open !:
              open #queue_handle:=fngethandle_: "name=diary.int//6,kfname=diary.que//6,shr",internal,input,keyed ioerr CHECK_TIME_FINIS
02775       let queue$=rpad$(uprc$(queue$),8) !:
            let dait$=srep$(dait$,"/","")
02780       let ct_time_start=fnstime_(time$)
02785       let diary_key$=last_diary_key$=rpad$(uprc$(queue$),8)(1:8)&rpad$(dait$(1:8),8)
02790 L2790: read #queue_handle,using L15180,search>=diary_key$,release: tfileno$,tc0de,tc0de$,tdait$,tcmt$,tqueue$,ttime$,tpriority$ nokey CHECK_TIME_FINIS ioerr CHECK_TIME_FINIS
02795 L2795: if tc0de$<>lpad$(trim$(str$(tc0de)),8) then !:
              let fnmessagebox_("There is a problem with the diary code.\nFile #:"&chr$(9)&tfileno$&"\nDiary Code:"&chr$(9)&lpad$(trim$(str$(tc0de)),8)&"\nDiary Date:"&chr$(9)&fndate_dis10_$(tdait$)&"\n\nPlease review the claim and update the diary entry.",16,"Bad Diary Code") !:
              goto CHECK_TIME_FINIS
02796       if uprc$(tqueue$)<>queue$ or tdait$<>dait$ or diary_time>3500 then !:
              goto CHECK_TIME_FINIS
02800       if ttime$="@@:@@" then goto NEXT_KEY
02805       let diary_time+=1 !:
            mat diary_time$(diary_time) !:
            mat diary_fileno$(diary_time) !:
            mat diary_key$(diary_time) !:
            mat diary_item$(diary_time) !:
            mat diary_recno(diary_time)
02810       let diary_desc$="" !:
            let ndcode=srch(mat diary_code,tc0de) !:
            if ndcode>0 then let diary_desc$=diary_desc$(ndcode)(14:63)
02815       let diary_time$(diary_time)=ttime$ !:
            let diary_fileno$(diary_time)=tfileno$ !:
            let diary_key$(diary_time)=tqueue$&tdait$&tc0de$&ttime$&tpriority$ !:
            let diary_item$(diary_time)=tc0de$&"  "&ttime$&"  "&trim$(diary_desc$)&" - "&tcmt$ !:
            let diary_recno(diary_time)=rec(queue_handle)
02820       read #queue_handle,using L15180,release: tfileno$,tc0de,tc0de$,tdait$,tcmt$,tqueue$,ttime$ eof CHECK_TIME_FINIS !:
            ! PRINT COUNT+=1
02825       goto L2795
02830 NEXT_KEY: ! FIGURE OUT NEXT KEY
02835       let diary_key$=rpad$(uprc$(tqueue$),8)(1:8)&rpad$(tdait$(1:8),8)&lpad$(str$(tc0de+1),8) !:
            if uprc$(env$("DEBUG"))="YES" then !:
              let msg$(diary_key$)
02840       let ct_time=fnstime_(time$)
02845       if last_diary_key$=diary_key$ or ct_time>ct_time_start+10000 then 
02850         let fnmessagebox_("The system has discovered that the diary index is damaged.\nPlease contact the system administrator to re-index.\nDue to the damage, your diary reminder will not function properly",16,"Damaged Diary Index")
02855         goto CHECK_TIME_FINIS
02860       end if  ! last_diary_key$=diary_key$ or ct_time>ct_time_start+10000
02865       let last_diary_key$=diary_key$
02870       goto L2790
02875 CHECK_TIME_FINIS: if orig_queue_handle=0 then !:
              close #queue_handle: ioerr L2880
02880 L2880: if diary_time=0 then goto L2915
02885       mat diary_sort(diary_time)=aidx(diary_time$) !:
            mat diary_work$(diary_time)=("") !:
            mat diary_work(diary_time)=(0)
02890       for n=1 to diary_time !:
              let diary_work$(n)=diary_time$(diary_sort(n)) !:
            next n !:
            mat diary_time$=diary_work$
02895       for n=1 to diary_time !:
              let diary_work$(n)=diary_fileno$(diary_sort(n)) !:
            next n !:
            mat diary_fileno$=diary_work$
02900       for n=1 to diary_time !:
              let diary_work$(n)=diary_item$(diary_sort(n)) !:
            next n !:
            mat diary_item$=diary_work$
02905       for n=1 to diary_time !:
              let diary_work$(n)=diary_key$(diary_sort(n)) !:
            next n !:
            mat diary_key$=diary_work$
02910       for n=1 to diary_time !:
              let diary_work(n)=diary_recno(diary_sort(n)) !:
            next n !:
            mat diary_recno=diary_work
02915 L2915: fnend 
02920     def library fnbpj$(sdate$,jdate$) ! Calculate BPJ
02922       let fnbpj$=fn_bpj$(sdate$,jdate$)
02924     fnend  ! library FNBPJ$
02930     def fn_bpj$(sdate$,jdate$) ! Calculate BPJ
02932       let bpj$="B"
02934       if trim$(sdate$)<>"" then let bpj$="P"
02936       if trim$(jdate$)<>"" then let bpj$="J"
02938       let fn_bpj$=bpj$
02939     fnend 
02940     def library fnopen_parent$*999(open_parent$*999; mat op_win_part_return$,op_force_parent_none,op_restrain_font_size)
02942       gosub SETUP_CONSTANTS
02944       let fnopen_parent$=fn_open_parent$(open_parent$, mat op_win_part_return$,op_force_parent_none,op_restrain_font_size)
02946     fnend 
02950     def fn_open_parent$*999(open_parent$*999; mat op_win_part_return$,op_force_parent_none,op_restrain_font_size)
02952       dim op_win0_fontsize(2)
02954 !     if 0=0 then ! env$("GUIMODE")="ON" then ! jbowman and
02956       dim op_win_part$(1)*256
02958       if env$("GUIMODE")="ON" and (op_force_parent_none or fn_use_parent_none) then let op_use_parent_none=1 else let op_use_parent_none=0
02960       let fn_window_parse(open_parent$,mat op_win_part$)
02962       if op_win_part$(pw_button_text)<>'' then 
02964         let fn_modify_window_for_buttons(mat op_win_part$)
02966       end if  ! op_win_part$(pw_button_text)<>''
02968 !       print '(before) open_parent=';open_parent$
02970       let open_parent$=fn_window_build$(mat op_win_part$,op_use_parent_none,op_restrain_font_size)
02972 !       print '( after) open_parent=';open_parent$ : pause
02974 ! 
02976       if udim(mat op_win_part_return$)<>0 then 
02978         mat op_win_part_return$(udim(mat op_win_part$))
02980         mat op_win_part_return$=op_win_part$ ! soflow ignore
02982       end if  ! udim(mat op_win_part_return$)<>10
02984       let fn_open_parent$=open_parent$
02986     fnend 
02990     def fn_window_build$*1024(mat winbuild_win_part$,winbuild_use_parent_none,winbuild_restrain_font_size) ! winbuild_
02992       dim winbuild_return$*1024
02994       let winbuild_return$=''
02996       let winbuild_return$=winbuild_return$&',Rows='&winbuild_win_part$(pw_rows)
02998       let winbuild_return$=winbuild_return$&',Cols='&winbuild_win_part$(pw_cols)
03000       if winbuild_win_part$(pw_border)<>'' then 
03002         let winbuild_return$=winbuild_return$&',Border='&winbuild_win_part$(pw_border)
03004       end if  ! winbuild_win_part$(pw_border)<>''
03006       if winbuild_win_part$(pw_tabcap_text)<>'' then 
03008         let winbuild_return$=winbuild_return$&','&winbuild_win_part$(pw_tabcap)&'='&winbuild_win_part$(pw_tabcap_text)
03010       end if  ! winbuild_win_part$(pw_tabcap_text)<>''
03012       if winbuild_win_part$(pw_name)<>'' and winbuild_use_parent_none then 
03014         let winbuild_return$=winbuild_return$&',Name='&winbuild_win_part$(pw_name)
03016       end if  ! winbuild_win_part$(pw_name)<>''
03018       if winbuild_win_part$(pw_parent)<>'' and winbuild_use_parent_none then 
03020         let winbuild_return$=winbuild_return$&',Parent='&winbuild_win_part$(pw_parent)
03022       end if  ! winbuild_win_part$(pw_parent)<>''
03024       if winbuild_win_part$(pw_position)<>'' and winbuild_use_parent_none then 
03026         let winbuild_return$=winbuild_return$&','&winbuild_win_part$(pw_position)
03028       end if  ! winbuild_win_part$(pw_position)<>''
03030       if winbuild_win_part$(pw_modal)<>'' and winbuild_use_parent_none then 
03032         let winbuild_return$=winbuild_return$&','&winbuild_win_part$(pw_modal)
03034       end if  ! winbuild_win_part$(pw_modal)<>''
03036       if winbuild_win_part$(pw_no_task_bar)<>'' and winbuild_use_parent_none then 
03038         let winbuild_return$=winbuild_return$&','&winbuild_win_part$(pw_no_task_bar)
03040       end if  ! winbuild_win_part$(pw_no_task_bar)<>''
03042       if winbuild_win_part$(pw_fontsize)<>'' and winbuild_use_parent_none then 
03044         let winbuild_return$=winbuild_return$&',FontSize='&winbuild_win_part$(pw_fontsize)
03046       end if  ! winbuild_win_part$(pw_fontsize)<>''
03048       if winbuild_win_part$(pw_border)<>'' and ~winbuild_use_parent_none then 
03050         let winbuild_return$=winbuild_return$&',Border='&winbuild_win_part$(pw_border)
03052       end if  ! winbuild_win_part$(pw_fontsize)<>''
03054       if winbuild_use_parent_none then 
03056         let winbuild_return$=winbuild_return$&',Relative'
03058         let winbuild_return$=winbuild_return$&',NoMaximize'
03060       end if  ! winbuild_use_parent_none
03062       if pos(uprc$(winbuild_return$),',FONTSIZE=')<=0 then 
03064         dim winbuild_winnew_fontsize(2)
03066         let file(0,"FONTSIZE", mat winbuild_win0_fontsize)
03068         if winbuild_restrain_font_size then 
03070           let winbuild_winnew_fontsize(1)=max(winbuild_win0_fontsize(1)+1,16)
03072           let winbuild_winnew_fontsize(1)=min(winbuild_win0_fontsize(1)+1,22)
03074           let winbuild_winnew_fontsize(2)=max(winbuild_win0_fontsize(2),8)
03076           let winbuild_winnew_fontsize(2)=min(winbuild_win0_fontsize(2),10)
03078           let winbuild_height_ratio=winbuild_win0_fontsize(1)/winbuild_winnew_fontsize(1)
03080           let winbuild_width_ratio=winbuild_win0_fontsize(2)/winbuild_winnew_fontsize(2)
03082 !         if jbowman then pr 'before winbuild_win_part$(pw_srow)=';winbuild_win_part$(pw_srow)
03084 !         if jbowman then pr 'before winbuild_win_part$(pw_scol)=';winbuild_win_part$(pw_scol)
03086           let winbuild_win_part$(pw_srow)=str$(int(val(winbuild_win_part$(pw_srow))*winbuild_height_ratio )) !   +    val(winbuild_win_part$(pw_rows))/2                 ))
03088           let winbuild_win_part$(pw_scol)=str$(int(val(winbuild_win_part$(pw_scol))*winbuild_width_ratio )) !   +     val(winbuild_win_part$(pw_cols))/2             ))
03090 !         if jbowman then pr ' after winbuild_win_part$(pw_srow)=';winbuild_win_part$(pw_srow)
03092 !         if jbowman then pr ' after winbuild_win_part$(pw_scol)=';winbuild_win_part$(pw_scol) : pause
03094         else 
03096           let winbuild_winnew_fontsize(1)=winbuild_win0_fontsize(1)+1 !:
                let winbuild_winnew_fontsize(2)=winbuild_win0_fontsize(2)
03098         end if  ! winbuild_restrain_font_size
03100         let env$("MONITOR1",mat monitor1_size)
03102         let winbuild_winnew_fontsize(1)=min( int((monitor1_size(4)-monitor1_size(2)- 100)/val(winbuild_win_part$(pw_rows)) ) - 2,winbuild_winnew_fontsize(1))
03104         let winbuild_return$(inf:0)=',FontSize='&str$(winbuild_winnew_fontsize(1)+1)&'x'&str$(winbuild_winnew_fontsize(2))
03106       end if  ! pos(uprc$(winbuild_return$),',FONTSIZE=')<=0
03108       let winbuild_return$=winbuild_return$&',SRow='&str$(max(val(winbuild_win_part$(pw_srow)),1))
03110       let winbuild_return$=winbuild_return$&',SCol='&winbuild_win_part$(pw_scol)
03112       let winbuild_return$=trim$(winbuild_return$,',')
03114       let fn_window_build$=winbuild_return$
03116     fnend  ! fn_window_build$
03120     def fn_modify_window_for_buttons(mat mwb_win_part$) ! mwb_
03122       let mwb_height_mod=fn_window_button_rows(mat mwb_win_part$)
03124       let mwb_win_part$(pw_rows)=str$(val(mwb_win_part$(pw_rows))+mwb_height_mod)
03126       let mwb_win_part$(pw_erow)=str$(val(mwb_win_part$(pw_erow))+mwb_height_mod)
03128 !     if jbowman then pause
03130       do while val(mwb_win_part$(pw_srow))+val(mwb_win_part$(pw_rows))>24
03132         let mwb_win_part$(pw_srow)=str$(val(mwb_win_part$(pw_srow))-1)
03134       loop 
03136     fnend  ! fn_modify_window_for_buttons
03140     def fn_window_button_rows(mat wbr_win_part$) ! wbr_
03142 ! this function determines the number of button rows a window needs and returns that number.
03144       if pos(lwrc$(wbr_win_part$(pw_button_text)),'(f)')>0 or len(wbr_win_part$(pw_button_text))*1.2>val(wbr_win_part$(pw_cols)) then let wbr_return=2 else let wbr_return=1
03146       let fn_window_button_rows=wbr_return
03148     fnend  ! fn_window_button_rows
03150     def library fnuse_parent_none
03152       let fnuse_parent_none=fn_use_parent_none
03154     fnend 
03160     def fn_use_parent_none
03162       if ~upn_setup then 
03164         let upn_setup=1
03166         let upn_security_gui_popup=fnsecurity_("GUI:POPUP",'',0,fnuserinit$,1)
03168         if upn_security_gui_popup>0 and env$("GUIMODE")="ON" then !:
                let upn_return=1 else let upn_return=0
03170       end if  ! ~upn_setup
03172       let fn_use_parent_none=upn_return
03174     fnend 
03180     def fn_window_parse(pw_source$*512,mat pw_data$) ! pw_   - makes .._win_part
03182       dim pw_part$(19)*512,pw_part$*512,pw_part_lwrc$*512
03184       mat pw_data$(19)=('')
03186       let pw_data_srow=pw_data_scol=pw_data_erow=pw_data_ecol=pw_data_rows=pw_data_cols=pw_tmp_has_center=pw_tmp_has_left=pw_tmp_has_right=pw_tmp_has_top=pw_tmp_has_bottom=0 ! local numeric variables (pw_clear_var :P )
03188       let str2mat(pw_source$,mat pw_part$,',')
03190       for pw_part_item=1 to udim(mat pw_part$)
03192         let pw_part$=pw_part$(pw_part_item)
03194         let pw_part_lwrc$=lwrc$(pw_part$)
03196         let pw_part_len=len(pw_part$)
03198         if pw_part_lwrc$(1:4)='srow' then 
03200           let pw_data$(pw_srow)=pw_part$(6:pw_part_len)
03202           let pw_data_srow=val(pw_data$(pw_srow)) conv PW_CONV
03204         else if pw_part_lwrc$(1:4)='scol' then 
03206           let pw_data$(pw_scol)=pw_part$(6:pw_part_len)
03208           let pw_data_scol=val(pw_data$(pw_scol)) conv PW_CONV
03210         else if pw_part_lwrc$(1:4)='erow' then 
03212           let pw_data$(pw_erow)=pw_part$(6:pw_part_len)
03214           let pw_data_erow=val(pw_data$(pw_erow)) conv PW_CONV
03216         else if pw_part_lwrc$(1:4)='ecol' then 
03218           let pw_data$(pw_ecol)=pw_part$(6:pw_part_len)
03220           let pw_data_ecol=val(pw_data$(pw_ecol)) conv PW_CONV
03222         else if pw_part_lwrc$(1:4)='rows' then 
03224           let pw_data$(pw_rows)=pw_part$(6:pw_part_len)
03226           let pw_data_rows=val(pw_data$(pw_rows)) conv PW_CONV
03228         else if pw_part_lwrc$(1:4)='cols' then 
03230           let pw_data$(pw_cols)=pw_part$(6:pw_part_len)
03232           let pw_data_cols=val(pw_data$(pw_cols)) conv PW_CONV
03234         else if pw_part_lwrc$(1:3)='tab' then 
03236           let pw_data$(pw_tabcap)='Tab'
03238           let pw_data$(pw_tabcap_text)=pw_part$(5:pw_part_len)
03240         else if pw_part_lwrc$(1:7)='caption' then 
03242           let pw_data$(pw_tabcap)='Caption'
03244           let pw_data$(pw_tabcap_text)=pw_part$(9:pw_part_len)
03246         else if pw_part_lwrc$(1:6)='parent' then 
03248           let pw_data$(pw_parent)=pw_part$(8:pw_part_len)
03250         else if pw_part_lwrc$(1:6)='border' then 
03252           let pw_data$(pw_border)=pw_part$(8:pw_part_len)
03254         else if pw_part_lwrc$(1:11)='button.fkey' then 
03256           let pw_data$(pw_button_fkey)=pw_part$(13:pw_part_len)
03258         else if pw_part_lwrc$(1:11)='button.text' then 
03260           let pw_data$(pw_button_text)=pw_part$(13:pw_part_len)
03262         else if pw_part_lwrc$(1:11)='button.help' then 
03264           let pw_data$(pw_button_help)=pw_part$(13:pw_part_len)
03266         else if pw_part_lwrc$(1:8)='relative' then 
03268           let pw_data$(pw_position)='relative'
03270         else if pw_part_lwrc$(1:8)='absolute' then 
03272           let pw_data$(pw_position)='absolute'
03274         else if pw_part_lwrc$(1:5)='modal' then 
03276           let pw_data$(pw_modal)='modal'
03278         else if pw_part_lwrc$(1:11)='no_task_bar' then 
03280           let pw_data$(pw_no_task_bar)='no_task_bar'
03282         else if pw_part_lwrc$(1:8)='fontsize' then 
03284           let pw_data$(pw_fontsize)=pw_part$(10:pw_part_len)
03286         else if pw_part_lwrc$(1:4)='name' then 
03288           let pw_data$(pw_name)=pw_part$(6:pw_part_len)
03290         else if pw_part_lwrc$(1:1)='n' then 
03292           let pw_data$(pw_attr_n)=pw_part$(3:pw_part_len)
03294         else if pw_part_lwrc$='center' then 
03296           let pw_tmp_has_center=1
03298         else if pw_part_lwrc$='left' then 
03300           let pw_tmp_has_left=1
03302         else if pw_part_lwrc$='right' then 
03304           let pw_tmp_has_right=1
03306         else if pw_part_lwrc$='top' then 
03308           let pw_tmp_has_top=1
03310         else if pw_part_lwrc$='bottom' then 
03312           let pw_tmp_has_bottom=1
03314         else 
03315 !       Additional Parts May be defined here!
03320           if debug or developer then print 'what is this "';pw_part$;'" of which you speak?' : pause 
03340         end if  ! pw_part_lwrc$(1:##)='...   /   else 
03342       next pw_part_item
03350 ! center, left, right, top, bottom
03352       if pw_tmp_has_center then 
03354         if pw_data_rows then 
03356           let pw_data_srow=int((screen_height-pw_data_rows)/2)+1
03358           let pw_data$(pw_srow)=str$(pw_data_srow)
03360         end if  ! pw_data_rows
03362         if pw_data_cols then 
03364           let pw_data_scol=int((screen_width-pw_data_cols)/2)+1
03366           let pw_data$(pw_scol)=str$(pw_data_scol)
03368         end if  ! pw_data_cols
03370       end if  ! pw_tmp_has_center
03372       if pw_tmp_has_left and pw_data_rows then 
03374         let pw_data_scol=2
03376         let pw_data$(pw_scol)=str$(pw_data_scol)
03378       end if  ! pw_tmp_has_left and pw_data_rows
03380       if pw_tmp_has_right and pw_data_cols then 
03382         let pw_data_scol=screen_width-pw_data_cols
03384         let pw_data$(pw_scol)=str$(pw_data_scol)
03386       end if  ! pw_tmp_has_right and pw_data_cols
03388       if pw_tmp_has_top then 
03390         let pw_data_srow=2
03392         let pw_data$(pw_srow)=str$(pw_data_srow)
03394       end if  ! pw_tmp_has_top
03396       if pw_tmp_has_bottom then 
03398         let pw_data_srow=screen_height-pw_data_rows-1
03400         let pw_data$(pw_srow)=str$(pw_data_srow)
03402       end if  ! pw_tmp_has_bottom
03410 ! 
03412 ! fill in the gaps
03414       if pw_data_rows=0 then 
03416         if ~pw_data_erow and ~pw_data_rows and developer then print 'pw_data_erow=pw_data_rows=0 - trouble' : pause 
03418         let pw_data_rows=pw_data_erow-pw_data_srow+1
03420         let pw_data$(pw_rows)=str$(pw_data_rows)
03422       end if  ! pw_data_rows=0
03424       if pw_data_cols=0 then 
03426         if ~pw_data_cols and ~pw_data_ecol and developer then print 'pw_data_erow=pw_data_rows=0 - trouble' : pause 
03428         let pw_data_cols=pw_data_ecol-pw_data_scol+1
03430         let pw_data$(pw_cols)=str$(pw_data_cols)
03432       end if  ! pw_data_cols=0
03434       if pw_data_erow=0 then 
03436         let pw_data_erow=pw_data_srow+pw_data_rows
03438         let pw_data$(pw_erow)=str$(pw_data_erow)
03440       end if  ! pw_data_erow=0
03442       if pw_data_ecol=0 then 
03444         let pw_data_ecol=pw_data_scol+pw_data_cols
03446         let pw_data$(pw_ecol)=str$(pw_data_ecol)
03450       end if  ! pw_data_ecol=0
03452       goto PW_XIT
03460 PW_CONV: ! 
03462       if debug then print 'conv on ';line;' of fn_window_parse.'
03464       if developer then pause 
03466       continue  ! pw_conv
03470 PW_XIT: ! 
03472     fnend  ! fn_window_parse
03480     def fnphone_$*60(phone$*60)
03482       dim tphone$*60
03484       let tphone$=trim$(phone$)
03486       if ~xlate_setup then let fnxlate_setup
03488       let phone$=xlate$(phone$,symbols_xlate$) !:
            let phone$=srep$(phone$," ","")
03490       if trim$(phone$)="" then goto L3506 ! if the phone does not contain any digits, then accept whatever they typed
03492       let phone$=trim$(ltrm$(trim$(phone$),"0")) !:
            if trim$(phone$)="" then goto L3508 else !:
              if fnval_(srep$(xlate$(phone$,numbers_xlate$)," ",""))=0 then goto L3506 !:
                ! if the phone is not only numbers, then do not format !:
                ! Remove Leading 0's from phone #
03494 L3494: let phone_val=val(phone$) conv L3502
03495       if phone$(1:1)="1" and phone_val<>1111111111 and phone_val<>1234567890 and phone_val<19999999999 then !:
              let phone$(1:1)="" !:
              goto L3494
03496       if phone_val>9999999999 then 
03498         if trim$(trim$(phone$(11:99)),"0")="" then let phone$(11:99)=""
03500       end if 
03502 L3502: if len(phone$)=7 then let phone$=phone$(1:3)&"-"&phone$(4:7) !:
              goto L3508
03504       if len(phone$)=10 then let phone$=phone$(1:3)&"/"&phone$(4:6)&"-"&phone$(7:99) !:
              goto L3508
03506 L3506: let phone$=tphone$ !:
            goto L3508
03508 L3508: let fnphone_$=phone$
03509     fnend 
03520 ! --------------------------FNphone$()--------------------------------
03522     def library fnphone$*60(phone$*60)
03524       let fnphone$=fnphone_$(phone$)
03526     fnend 
03528 ! --------------------------FNSSN$()--------------------------------
03530     def library fnssn$*60(ssn$*60)
03532       let fnssn$=fnssn_$(ssn$)
03534     fnend 
03540 !  -------------------------FNHTML_NBSP$()-----------------------------
03542     def library fnhtml_nbsp$*256(text$*256)
03544 ! Funtion will return either the contents of text$ or "&nbsp;" !:
            ! if the text is empty !:
            ! This helps to prevent formating problems in html documents
03546       let html_val=val(text$) conv L3548 !:
            if html_val>1e+10 then let text$=rtrm$(text$)&"&nbsp;" !:
              ! Very Long Numbers should have a forced space at the end of the line
03548 L3548: if trim$(text$)="" then let fnhtml_nbsp$="&nbsp;" else !:
              let fnhtml_nbsp$=text$
03549     fnend 
03550     def library fnneg_array(mat array)
03552       for n_array=1 to udim(array)
03554         let array(n_array)*=-1
03556       next n_array
03558     fnend 
03560     def library fnpick_salut$(pick$)
03562       mat _menu$(1)=("") !:
            if ~cls_setup then let fnclssetup
03564       let nmenu=0 !:
            for n=1 to 9 !:
              if trim$(salut$(n))<>"" then !:
                let nmenu+=1: mat _menu$(nmenu) !:
                let _menu$(nmenu)=str$(n)&"  "&trim$(salut$(n))
03566       next n
03568       let npick=0 !:
            let npick=val(pick$) conv L3570
03570 L3570: let npick=fnwinscroll_(mat _menu$,npick,"TITLE=Select Title HEADING=Code;Description")
03572       if npick>0 and npick<udim(_menu$) then let fnpick_salut$=_menu$(npick)(1:1)
03574     fnend 
03580 ! --------------------------FNGETDATE$()--------------------------------
03581     def fngetdate$(inp_dait$*30,fmt_from$,fmt_to$)
03582       let inp_dait$=uprc$(inp_dait$) !:
            let is_weeks=is_months=is_years=0 !:
            if pos(inp_dait$,"W")>0 then !:
              let is_weeks=1 : let inp_dait$=srep$(inp_dait$,"W","") !:
            else if pos(inp_dait$,"M")>0 then !:
              let is_months=1 : let inp_dait$=srep$(inp_dait$,"M","") !:
            else if pos(inp_dait$,"Y")>0 then !:
              let is_years=1 : let inp_dait$=srep$(inp_dait$,"Y","")
03584 L3584: let inp_dait=fndate_val(inp_dait$)
03586   let inp_dait$=trim$(inp_dait$) !:
        let dait_len=len(inp_dait$)
03588   if inp_dait$="0" then let inp_dait=date("CYMDD") !:
          let fmt_from$="CYMD" !:
          goto L3608
03590   let slash_pos=pos(inp_dait$,"/") !:
        if slash_pos<=0 then goto L3604 !:
          ! if date has slashes, then clean up input
03592   if slash_pos=2 then let inp_dait$(1:0)="0" !:
          goto L3584
03594   if dait_len=4 then let inp_dait$(4:3)="0" !:
          goto L3584
03596   if dait_len=5 and pos(inp_dait$,"-")<=0 then !:
          let inp_dait$=inp_dait$&date$("/YY") !:
          let inp_dait=fndate_val(inp_dait$) !:
          let fmt_from$="MM/DD/YY" !:
          goto L3584
03598   let slash2_pos=pos(inp_dait$,"/",slash_pos+1)
03600   if slash2_pos<0 then goto L3604
03602   if slash2_pos=5 then let inp_dait$(4:3)="0" !:
          goto L3584
03604 L3604: if dait_len=4 and pos(inp_dait$,"-")<=0 then !:
          let inp_dait$=inp_dait$&date$("YY") !:
          let inp_dait=fndate_val(inp_dait$) !:
          let fmt_from$="MMDDYY" !:
          goto L3608
03606   if inp_dait$(1:1)="-" or dait_len<=3 then goto L3616
03608 L3608: let fmt_from$=srep$(srep$(fmt_from$,"CC",""),"YY","CCYY") !:
        if days(inp_dait,fmt_from$)<>0 then goto L3624
03610   let fmt_from$=srep$(fmt_from$,"CCYY","YY") !:
        if days(inp_dait,fmt_from$)<>0 then goto L3624
03611   let fmt_from$="CCYYMMDD" !:
        if days(inp_dait,fmt_from$)<>0 then goto L3624
03612   let fmt_from$="MMDDCCYY" !:
        if days(inp_dait,fmt_from$)<>0 then goto L3624
03613   let fmt_from$="YYMMDD" !:
        if days(inp_dait,fmt_from$)<>0 then goto L3624
03614   let fmt_from$="MMDDYY" !:
        if days(inp_dait,fmt_from$)<>0 then goto L3624
03615   goto L3628 !:
        ! DON'T RECOGNIZE DATE, QUIT
03616 L3616: let inp_span=val(srep$(inp_dait$,"/","")) conv L3628 !:
        let fmt_from$="CCYYMMDD"
03618   if is_years then !:
          let inp_dait=date(days(date)+int(inp_span*365.25/7)*7,"CCYYMMDD") !:
        else if is_months then !:
          let inp_dait=date(days(date)+int(inp_span*30.42/7)*7,"CCYYMMDD") !:
        else if is_weeks then !:
          let inp_dait=date(days(date)+inp_span*7,"CCYYMMDD") !:
        else !:
          let inp_dait=date(days(date)+inp_span,"CCYYMMDD")
03620 goto L3624
03624 L3624: let inp_dait$="" !:
      let inp_days=days(inp_dait,fmt_from$) !:
      if inp_days then !:
        let inp_dait$=date$(inp_days,fmt_to$)
03626 let fngetdate$=inp_dait$
03628 L3628: fnend 
03630 ! --------------------------FN_CDAYS()----------------------------------
03632 def fn_cdays(inp_date)
03634   let inp_date=fnget_date10(str$(inp_date))
03636   let fn_cdays=days(inp_date,"CYMD")
03638 fnend 
03640 ! ----------------------FNDATE_VAL()------------------------------------
03642 def fndate_val(inp_date$*30)
03644   let inp_date=0
03645   let inp_date$=uprc$(inp_date$) !:
        let inp_date$=srep$(inp_date$,"/","") !:
        let inp_date$=srep$(inp_date$,"-","") !:
        let inp_date$=srep$(inp_date$,"W","") !:
        let inp_date$=srep$(inp_date$,"M","") !:
        let inp_date$=srep$(inp_date$,"Y","")
03646   let inp_date=val(inp_date$) conv L3648 !:
        goto L3650
03648 L3648: if pos(inp_date$,"*")>0 or pos(inp_date$,"?")>0 then !:
          let inp_date=1
03650 L3650: let fndate_val=inp_date
03652 fnend 
03660 ! ---------------------------FNGET_DATE8$()-----------------------------
03662 def fnget_date8$(inp_date$)
03664   let fnget_date8$=date$(days(inp_date:=fndate_val(inp_date$)),"Y/M/D")
03666 fnend 
03668 ! -------------------------FNGET_DATE8()--------------------------------
03670 def fnget_date8(inp_date$)
03672   let fnget_date8=date(days(inp_date:=fndate_val(inp_date$)),"Y/M/D")
03674 fnend 
03676 ! --------------------------FNGET_DATE10$-------------------------------
03678 def fnget_date10$(inp_date$)
03680   let fnget_date10$=date$(days(inp_date:=fndate_val(inp_date$)),"CCYY/MM/DD")
03682 fnend 
03684 ! --------------------------FNGET_DATE10()------------------------------
03686 def fnget_date10(inp_date$)
03688   let fnget_date10=date(days(inp_date:=fndate_val(inp_date$)),"CCYYMMDD")
03689 fnend 
03690 ! ---------LIBRARY----------FNDATE_DIS8$--------------------------------
03692 def fndate_dis8_$(inp_date$)
03694   if inp_date$="99/99/99" or inp_date$="9999/99/99" then !:
          let fndate_dis8_$="*ERROR*" !:
          goto L3704
03696   if fndate_val(inp_date$)=0 then goto L3704
03698   if ~cls_setup then let fnclssetup
03700   let inp_date=fnget_date8(inp_date$)
03702   let fndate_dis8_$=date$(days(inp_date),date_8$(1))
03704 L3704: fnend 
03710 def library fndate_dis8$(inp_date$)
03712   let fndate_dis8$=fndate_dis8_$(inp_date$)
03714 fnend 
03720 ! ---------LIBRARY----------FNDATE_DIS10$-------------------------------
03722 def fndate_dis10_$(inp_date$)
03724   if inp_date$="99/99/99" or inp_date$="9999/99/99" then !:
          let fndate_dis10_$="*ERROR*" !:
          goto L3734
03726   if fndate_val(inp_date$)=0 then goto L3734
03728   if ~cls_setup then let fnclssetup
03730   let inp_date=fnget_date10(inp_date$)
03732   let fndate_dis10_$=date$(days(inp_date,"CYMD"),date_10$(1))
03734 L3734: fnend 
03740 def library fndate_dis10$(inp_date$)
03742   let fndate_dis10$=fndate_dis10_$(inp_date$)
03744 fnend 
03750 def fn_date10_dis_fmt$
03752   if ~cls_setup then let fnclssetup
03754   let fn_date10_dis_fmt$=date_10$(1)
03756 fnend  ! fn_Date10_Dis_fmt$
03760 def library fndate10_dis_fmt$
03762   let fndate10_dis_fmt$=fn_date10_dis_fmt$
03764 fnend  ! fnDate10_Dis_fmt$
03770 ! ---------LIBRARY----------FNDATE_INP8$--------------------------------
03772 def fndate_inp8_$(inp_date$)
03774   if fndate_val(inp_date$)=0 and trim$(inp_date$)<>"0" then goto L3786
03776   if ~cls_setup then let fnclssetup
03778   let use_popup=0 !:
        if pos(inp_date$,"*")>0 or pos(inp_date$,"?")>0 or cmdkey=18 then !:
          let inp_date$=srep$(inp_date$,"*","") !:
          let inp_date$=srep$(inp_date$,"?","") !:
          let use_popup=1
03780   let inp_date$=fngetdate$(inp_date$,date_8$(2),"CCYYMMDD") !:
        if use_popup then !:
          let inp_date$=fngetdate$(fnpopup$(inp_date$),date_8$(2),"CCYYMMDD")
03782   let inp_date=val(inp_date$)
03784   if inp_date then !:
          let fndate_inp8_$=date$(days(inp_date,"CCYYMMDD"),"YY/MM/DD")
03786 L3786: fnend 
03790 def library fndate_inp8$(inp_date$)
03792   let fndate_inp8$=fndate_inp8_$(inp_date$)
03794 fnend 
03800 ! ---------LIBRARY----------FNDATE_INP10$-------------------------------
03802 def fndate_inp10_$(inp_date$)
03804   if fndate_val(inp_date$)=0 and trim$(inp_date$)<>"0" then goto L3816
03806   if ~cls_setup then let fnclssetup
03808   let use_popup=0 !:
        if pos(inp_date$,"*")>0 or pos(inp_date$,"?")>0 or cmdkey=18 then !:
          let inp_date$=srep$(inp_date$,"*","") !:
          let inp_date$=srep$(inp_date$,"?","") !:
          let use_popup=1
03810   let inp_date$=fngetdate$(inp_date$,date_10$(2),"CCYYMMDD") !:
        if use_popup then !:
          let inp_date$=fngetdate$(fnpopup$(inp_date$),date_10$(2),"CCYYMMDD")
03812   let inp_date=val(inp_date$)
03814   if inp_date then !:
          let fndate_inp10_$=date$(days(inp_date,"CCYYMMDD"),"CCYY/MM/DD")
03816 L3816: fnend 
03820 def library fndate_inp10$(inp_date$)
03822   let fndate_inp10$=fndate_inp10_$(inp_date$)
03824 fnend 
03830 ! ---------LIBRARY----------FNDATE_INPDIS8$()---------------------------
03832 L3832: def fndate_inpdis8_$(inp_date$)
03834   if inp_date$="99/99/99" or inp_date$="9999/99/99" then !:
          let fndate_inpdis8_$="*ERROR*" !:
          goto L3844
03836   if fndate_val(inp_date$)=0 then goto L3844
03838   if ~cls_setup then let fnclssetup
03840   let inp_date=fnget_date8(inp_date$)
03842   let fndate_inpdis8_$=date$(days(inp_date),date_8$(2))
03844 L3844: fnend 
03860 def library fndate_inpdis8$(inp_date$)
03862   let fndate_inpdis8$=fndate_inpdis8_$(inp_date$)
03864 fnend 
03870 ! ---------LIBRARY----------FNDATE_INPDIS10$()--------------------------
03872 def fndate_inpdis10_$(inp_date$)
03874   if inp_date$="99/99/99" or inp_date$="9999/99/99" then !:
          let fndate_inpdis10_$="*ERROR*" !:
          goto L3884
03876   if fndate_val(inp_date$)=0 then goto L3884
03878   if ~cls_setup then let fnclssetup
03880   let inp_date=fnget_date10(inp_date$)
03882   let fndate_inpdis10_$=date$(days(inp_date,"CYMD"),date_10$(2))
03884 L3884: fnend 
03890 def library fndate_inpdis10$(inp_date$)
03892   let fndate_inpdis10$=fndate_inpdis10_$(inp_date$)
03894 fnend 
03900 ! ---------LIBRARY----------FNDATE_DIS_SAVE8$()-------------------------
03902 def library fndate_dis_save8$(inp_date$)
03904   if fndate_val(inp_date$)=0 then goto L3916
03906   if ~cls_setup then let fnclssetup
03908   let inp_date=fndate_val(inp_date$) !:
        let inp_form$=date_8$(1) !:
        if inp_date=0 then goto L3916
03910   if days(inp_date,inp_form$)<>0 then goto L3914 else !:
          let inp_form$=srep$(date_8$(1),"CC","") !:
          if days(inp_date,inp_form$) then goto L3914
03912 ! 
03914 L3914: let fndate_dis_save8$=date$(days(inp_date,inp_form$),"YY/MM/DD")
03916 L3916: fnend 
03920 ! ---------LIBRARY----------FNDATE_DIS_SAVE10$()------------------------
03922 def library fndate_dis_save10$(inp_date$)
03924   if fndate_val(inp_date$)=0 then goto L3934
03926   if ~cls_setup then let fnclssetup
03928   let inp_date=fndate_val(inp_date$) !:
        let inp_form$=date_10$(1) !:
        if inp_date=0 then goto L3832
03930   if days(inp_date,inp_form$)<>0 then goto L3932 else !:
          let inp_form$=srep$(date_10$(1),"CC","") !:
          if days(inp_date,inp_form$) then goto L3932
03932 L3932: let fndate_dis_save10$=date$(days(inp_date,date_10$(2)),"CCYY/MM/DD")
03934 L3934: fnend 
03940 ! ---------LIBRARY----------FNDATE8$()----------------------------------
03942 def fndate8_$(inp_date$)
03944   let inp_date$=fnget_date8$(inp_date$)
03946   if inp_date$<>"00/00/00" then !:
          let fndate8_$=inp_date$
03948 fnend 
03950 def library fndate8$(inp_date$)
03952   let fndate8$=fndate8_$(inp_date$)
03954 fnend 
03960 ! ---------LIBRARY----------FNDATE8-------------------------------------
03962 def fndate8_(inp_date$)
03964   let inp_date=fnget_date8(inp_date$)
03966   if inp_date<>0 then !:
          let fndate8_=inp_date
03968 fnend 
03970 def library fndate8(inp_date$)
03972   let fndate8=fndate8_(inp_date$)
03974 fnend 
03980 ! ---------LIBRARY----------FNDATE10$-----------------------------------
03982 def fndate10_$(inp_date$)
03984   let inp_date$=fnget_date10$(inp_date$)
03986   if inp_date$<>"0000/00/00" and inp_date$<>"1899/12/31" then !:
          let fndate10_$=inp_date$
03988 fnend 
03990 def library fndate10$(inp_date$)
03992   let fndate10$=fndate10_$(inp_date$)
03994 fnend 
03996 ! ---------LIBRARY----------FNDATE10------------------------------------
04000 def fndate10_(inp_date$)
04002   let inp_date=fnget_date10(inp_date$)
04004   if inp_date<>0 then !:
          let fndate10_=inp_date
04006 fnend 
04010 def library fndate10(inp_date$)
04012   let fndate10=fndate10_(inp_date$)
04014 fnend 
04016 def library fndate_c8$(inp_date$)
04018   let fndate_c8$=fn_date_c8$(inp_date$)
04019 fnend 
04020 def fn_date_c8$(inp_date$)
04022   let inp_date=fnget_date10(inp_date$)
04024   if inp_date<>0 then !:
          let fn_date_c8$=date$(days(inp_date),"CCYYMMDD")
04026 fnend 
04028 ! ---------LIBRARY----------FNDATE_RPT8$()------------------------------
04030 def library fndate_rpt8$(inp_date$)
04032   if trim$(inp_date$)="0" then !:
          let fndate_rpt8$=rpad$("",8)(1:8) !:
          goto L4042
04034   if fndate_val(inp_date$)=0 then !:
          let fndate_rpt8$=rpad$(inp_date$,8)(1:8) !:
          goto L4042
04036   if ~cls_setup then let fnclssetup
04038   let inp_date=fnget_date8(inp_date$)
04040   if days(inp_date) then !:
          let fndate_rpt8$=date$(days(inp_date),date_8$(3)) else !:
          let fndate_rpt8$="**/**/**"
04042 L4042: fnend 
04050 ! ---------LIBRARY----------FNDATE_RPT10$-------------------------------
04052 def library fndate_rpt10$(inp_date$)
04054   if trim$(inp_date$)="0" then !:
          let fndate_rpt10$=rpad$("",10) !:
          goto L4064
04056   if fndate_val(inp_date$)=0 then !:
          let fndate_rpt10$=rpad$(inp_date$,10) !:
          goto L4064
04058   if ~cls_setup then let fnclssetup
04060   let inp_date=fnget_date10(inp_date$)
04062   if days(inp_date,"CYMD") then !:
          let fndate_rpt10$=date$(days(inp_date,"CYMD"),date_10$(3)) else !:
          let fndate_rpt10$="**/**/****"
04064 L4064: fnend 
04070 ! ---------LIBRARY----------FNCDAYS()-----------------------------------
04072 def library fncdays(inp_date)
04074   let fncdays=fn_cdays(inp_date)
04076 fnend 
04080 ! ---------LIBRARY----------FNLOW_DATE$()-------------------------------
04082 def fnlow_date_$
04084   if ~cls_setup then let fnclssetup
04086   if trim$(base_year$)="" then let fnlow_date_$="1900/01/01" else !:
          let fnlow_date_$=base_year$&"/01/01"
04088 fnend 
04090 def library fnlow_date$
04092   let fnlow_date$=fnlow_date_$
04094 fnend 
04100 ! ---------LIBRARY----------FNHIGH_DATE$()------------------------------
04102 def fnhigh_date_$
04104   let fnhigh_date_$="2399/12/31"
04106 fnend 
04110 def library fnhigh_date$
04112   let fnhigh_date$=fnhigh_date_$
04114 fnend 
04120 NEXTFRIDAY: ! -----------LIBRARY----------Fnnextfriday$()----------------
04122 def library fnnextfriday$(nf_d$)
04124   let nf_current_date=fndate10_(nf_d$)
04126   let nf_current_day=fndow_(nf_current_date)
04128   if nf_current_day=7 then !:
          let nf_friday$=date$(days(nf_current_date)+6) !:
        else !:
          let nf_friday$=date$(days(nf_current_date)+6-nf_current_day,"CCYY/MM/DD")
04130 X_FNNEXT_FRIDAY: !:
        let fnnextfriday$=nf_friday$
04132 fnend 
04140 ! ------- library FNSTART
04142 def library fnstart$
04144   let start_time=days(date)*24*60*60*100+fnstime_(time$)
04146   let setenv("START_TIME",str$(start_time)) !:
        ! * Assign Environment Varialbe to "Mark" the Start Time
04148 fnend 
04150 ! ----------LIBRARY----------FNTIME()
04152 def library fntime$
04154   let end_time=days(date)*24*60*60*100+fnstime_(time$)
04156   let start_time=val(env$("START_TIME"))
04158   let fntime$=fnstime_$(end_time-start_time)
04159 fnend 
04160 ! ----------LIBRARY ---------- FNMAT_COPY$
04162 def library fnmat_copy$(mat from$,mat to$)
04164   mat to$(udim(from$))=from$
04166 fnend 
04170 ! ----------LIBRARY ---------- FNMAT_COPY
04172 def library fnmat_copy(mat from,mat to)
04174   mat to(udim(from))=from
04176 fnend 
04180 def library fnwb_header(filname$*80,mat results)
04182   let fnwb_header=fnwbheader(filname$,mat results)
04184 fnend 
04190 def fnwbheader(filname$*80,mat results)
04192   let next_file_handle=fngethandle_
04194   mat results(7)=(0) !:
        ! 1 = LASTREC !:
        ! 2 = LASTSORT !:
        ! 3 = FILETYPE !:
        ! 4 = RECLEN !:
        ! 5 = HEAD !:
        ! 6 = Total # Bytes !:
        ! 7 = Estimated LASTREC
04196   open #next_file_handle: "name="&filname$&",recl=16,shr",external,input ioerr WBH_OPEN_ERR ! 7035
04198   read #next_file_handle,using R1,release: mat results(1:5) ioerr L4202
04200 R1: form pos 1,b 4,b 4,b 1,b 2,b 2
04202 L4202: close #next_file_handle: ioerr L4204
04204 L4204: open #next_file_handle: "name="&filname$&",recl=1,shr",external,input ioerr WBH_XIT
04206   let results(6)=lrec(next_file_handle) !:
        if results(6)<0 then let results(6)+=2**32
04208   let results(7)=(results(6)-results(5))/(results(4)+1)
04210   close #next_file_handle: ioerr ignore
04212   goto WBH_XIT
04214 WBH_OPEN_ERR: ! 
04216   let results(7)=-err
04218   goto WBH_XIT ! WBH_OPEN_ERR
04220 WBH_XIT: ! 
04222   let fnwbheader=results(7)
04224 fnend 
04230 def library fndate(from_date$,to_date$)
04232   let td=days(fndate10_(to_date$))-days(fndate10_(from_date$))
04234   let fndate=td
04236 fnend 
04240 def library fnfmt_date$*80(dait$;fmt$*80)
04242   if trim$(fmt$)="" then let fmt$="[Month] [D], [CCYY]"
04244   if ~cls_setup then let fnclssetup
04246   let tdait$=fndate10_$(dait$) !:
        let tdait=fndate10_(tdait$) !:
        if trim$(tdait$)="" then let fnfmt_date$="" !:
          goto L4259
04248   let month=date(days(tdait),"M") !:
        let day=date(days(tdait),"D") !:
        let year=date(days(tdait),"Y") !:
        let century=date(days(tdait),"CCYY")
04250   let dth$="th" !:
        if day=1 or day=21 or day=31 then let dth$="st" else !:
          if day=2 or day=22 then let dth$="nd" else !:
            if day=3 or day=23 then let dth$="rd"
04252   let fmt$=srep$(fmt$,"[Month]",month$(month)) !:
        let fmt$=srep$(fmt$,"[D]",str$(day)) !:
        let fmt$=srep$(fmt$,"[Dth]",str$(day)&dth$) !:
        let fmt$=srep$(fmt$,"[CCYY]",str$(century)) !:
        let fmt$=srep$(fmt$,"[Y]",str$(year)) !:
        let fmt$=srep$(fmt$,"[M]",str$(month))
04254   let fmt$=srep$(fmt$,"[DD]",cnvrt$('PIC(##)',day)) !:
        let fmt$=srep$(fmt$,"[MM]",cnvrt$('PIC(##)',month)) !:
        let fmt$=srep$(fmt$,"[YY]",cnvrt$('PIC(##)',year))
04256   let fmt$=srep$(fmt$,"[Mon]",month$(month)(1:3)) !:
        let fmt$=srep$(fmt$,"[MON]",uprc$(month$(month)(1:3))) !:
        let fmt$=srep$(fmt$,"[Day]",date$(days(tdait),"Day"))
04258   let fnfmt_date$=fmt$
04259 L4259: fnend 
04260 def library fnis_pay(c0de$)
04262   if ~cls_setup then let fnclssetup
04264   let is_pay=0
04266   if trim$(c0de$)="" then goto L4282
04268   for ncount=1 to 5
04270     if trim$(c0de$)=trim$(vlp$(ncount)) then let is_pay=1 !:
            let is_pay=1: let ncount=99 !:
            goto L4280
04272     if trim$(c0de$)=trim$(psc$(ncount)) then let is_pay=1 !:
            let is_pay=1: let ncount=99 !:
            goto L4280
04274     if trim$(c0de$)=trim$(rop$(ncount)) then let is_pay=1 !:
            let is_pay=1: let ncount=99 !:
            goto L4280
04280 L4280: next ncount
04282 L4282: let fnis_pay=is_pay
04284 fnend 
04290 def library fninternal_acct(mat _menu$)
04292   mat _menu$(28) !:
        let _menu$(1)="FFile" !:
        let _menu$(2)="Dcket" !:
        let _menu$(3)="Sher" !:
        let _menu$(4)="Adva" !:
        let _menu$(5)="Bank" !:
        let _menu$(6)="CoRef"
04294   let _menu$(7)="Atty" !:
        let _menu$(8)="Para" !:
        let _menu$(9)="Cred" !:
        let _menu$(10)="Empl" !:
        let _menu$(11)="Coll" !:
        let _menu$(12)="Sales" !:
        let _menu$(13)="Group"
04296   let _menu$(14)="Trust" !:
        let _menu$(15)="Lnder" !:
        let _menu$(16)="Brker" !:
        let _menu$(17)="Judge" !:
        let _menu$(18)="Ins" !:
        let _menu$(19)="Title"
04298   let _menu$(20)="CCCS" !:
        let _menu$(21)="PServ" !:
        let _menu$(22)="MdSer" !:
        let _menu$(23)="MdRec" !:
        let _menu$(24)="DrRef"
04300   let _menu$(25)="Medtr" !:
        let _menu$(26)="Repo" !:
        let _menu$(27)="Contact" !:
        let _menu$(28)="eNetwork"
04302 fnend 
04310 ! ---------LIBRARY----------FNINTERNAL_MENU()-------------------------------------
04312 def library fninternal_menu(mat _menu$,mat _types$)
04314   let fninternal_menu=fni_menu(mat _menu$,mat _types$)
04316 fnend 
04320 def fni_menu(mat _menu$,mat _types$)
04322   mat _menu$(29) !:
        let _menu$(1)="1. Forwarder File" !:
        let _menu$(2)="2. Court File" !:
        let _menu$(3)="3. Sheriff File" !:
        let _menu$(4)="4. Adversary Attorney File" !:
        let _menu$(5)="5. Bank File" !:
        let _menu$(6)="6. Co-counsel File"
04324   let _menu$(7)="7. Attorney File" !:
        let _menu$(8)="8. Paralegal File" !:
        let _menu$(9)="9. Creditor File" !:
        let _menu$(10)="Z. Employer File" !:
        let _menu$(11)="Y. Collector File" !:
        let _menu$(12)="X. Salesperson File" !:
        let _menu$(13)="W. Group File"
04326   let _menu$(14)="V. Trustee File" !:
        let _menu$(15)="U. Lender File" !:
        let _menu$(16)="T. Broker File" !:
        let _menu$(17)="S. Judge File" !:
        let _menu$(18)="R. Insurance File" !:
        let _menu$(19)="Q. Title Company File"
04328   let _menu$(20)="P. Consumer Credit Counsel" !:
        let _menu$(21)="O. Process Server File" !:
        let _menu$(22)="N. Medical Services File" !:
        let _menu$(23)="M. Medical Records File" !:
        let _menu$(24)="L. Doctor File"
04330   let _menu$(25)="K. Mediator File" !:
        let _menu$(26)="J. Repossession Agent File" !:
        let _menu$(27)="I. Client Contact File" !:
        let _menu$(28)="H. eNetwork File" !:
        let _menu$(29)="0. Return to Main Menu"
04340   mat _types$(29) !:
        let _types$(1)="Client" !:
        let _types$(2)="Legal" !:
        let _types$(3)="Legal" !:
        let _types$(4)="Debtor" !:
        let _types$(5)="Debtor" !:
        let _types$(6)="Legal" !:
        let _types$(7)="In House"
04342   let _types$(8)="In House" !:
        let _types$(9)="Client" !:
        let _types$(10)="Debtor" !:
        let _types$(11)="In House" !:
        let _types$(12)="In House" !:
        let _types$(13)="Medical" !:
        let _types$(14)="Misc."
04344   let _types$(15)="Misc." !:
        let _types$(16)="Misc." !:
        let _types$(17)="Legal" !:
        let _types$(18)="Misc." !:
        let _types$(19)="Misc."
04346   let _types$(20)="Misc." !:
        let _types$(21)="Legal" !:
        let _types$(22)="Medical" !:
        let _types$(23)="Medical" !:
        let _types$(24)="Medical"
04348   let _types$(25)="Legal" !:
        let _types$(26)="Legal" !:
        let _types$(27)="Client" !:
        let _types$(28)="Client" !:
        let _types$(29)=""
04350   let fni_menu=udim(_menu$)-1
04352 fnend 
04360 def library fninternal_files(mat f_name$,mat f_desc$)
04362   let fninternal_files=fnfc_menu(mat f_name$,mat f_desc$)
04364 fnend 
04370 def fnfc_menu(mat filename$,mat fielddesc$)
04372   mat fielddesc$(28) !:
        let fielddesc$(1)="Forwarder File" !:
        let fielddesc$(2)="Court File" !:
        let fielddesc$(3)="Sheriff File" !:
        let fielddesc$(4)="Adversary Attorney File" !:
        let fielddesc$(5)="Bank File" !:
        let fielddesc$(6)="Co-counsel File"
04374   let fielddesc$(7)="Attorney File" !:
        let fielddesc$(8)="Paralegal File" !:
        let fielddesc$(9)="Creditor File" !:
        let fielddesc$(10)="Employer File" !:
        let fielddesc$(11)="Collector File" !:
        let fielddesc$(12)="Salesperson File" !:
        let fielddesc$(13)="Group File"
04376   let fielddesc$(14)="Trustee File" !:
        let fielddesc$(15)="Lender File" !:
        let fielddesc$(16)="Broker File" !:
        let fielddesc$(17)="Judge File" !:
        let fielddesc$(18)="Insurance File" !:
        let fielddesc$(19)="Title Company File"
04378   let fielddesc$(20)="Consumer Credit Counsel" !:
        let fielddesc$(21)="Process Server File" !:
        let fielddesc$(22)="Medical Services File" !:
        let fielddesc$(23)="Medical Records File" !:
        let fielddesc$(24)="Doctor File"
04380   let fielddesc$(25)="Mediator File" !:
        let fielddesc$(26)="Repossession Agent File" !:
        let fielddesc$(27)="Contact File" !:
        let fielddesc$(28)="eNetwork File"
04390   mat filename$(28) !:
        let filename$(1)="MASFORW" !:
        let filename$(2)="CLERKF" !:
        let filename$(3)="COPF" !:
        let filename$(4)="ADVAFILE" !:
        let filename$(5)="BANKFILE" !:
        let filename$(6)="MASCO" !:
        let filename$(7)="ATTYFILE"
04392   let filename$(8)="SECYFILE" !:
        let filename$(9)="CLIENTF" !:
        let filename$(10)="EMPLOYER" !:
        let filename$(11)="COLLFILE" !:
        let filename$(12)="SALES" !:
        let filename$(13)="GROUP" !:
        let filename$(14)="TRUSTEE"
04394   let filename$(15)="LENDER" !:
        let filename$(16)="BROKER" !:
        let filename$(17)="JUDGE" !:
        let filename$(18)="INSURANC" !:
        let filename$(19)="TITLECO"
04396   let filename$(20)="CCCS" !:
        let filename$(21)="PROCSERV" !:
        let filename$(22)="HOSPITAL" !:
        let filename$(23)="MEDREC" !:
        let filename$(24)="DOCTOR"
04398   let filename$(25)="MEDIATOR" !:
        let filename$(26)="REPO" !:
        let filename$(27)="CONTACT" !:
        let filename$(28)="ENETWORK"
04400   let fnfc_menu=udim(_menu$)-1
04402 fnend 
04410 def fnpopup$(today$)
04412   let orig_today$=today$ !:
        let orig_fkey=fkey !:
        let orig_curfld=curfld
04414   if fnwin_gui then !:
          let fnpopup$=fnwin_cal$(today$) !:
          goto L4474
04416   dim day$(41),day_form$(41)*32,orig_today$*10,orig_fkey,orig_curfld
04418 L4418: for z=1 to 7
04420     let day_form$(z)="2,"&str$((z*3)-2)&",C 2,[T],B"&str$(1000+z) !:
          let day_form$(z+7)="3,"&str$((z*3)-2)&",C 2,[T],B"&str$(1000+z+7) !:
          let day_form$(z+14)="4,"&str$((z*3)-2)&",C 2,[T],B"&str$(1000+z*14) !:
          let day_form$(z+21)="5,"&str$((z*3)-2)&",C 2,[T],B"&str$(1000+z*21) !:
          let day_form$(z+28)="6,"&str$((z*3)-2)&",C 2,[T],B"&str$(1000+z*28)
04422   next z
04424   let day_form$(36)="7,1,C 2,[T],B1036" !:
        let day_form$(37)="7,4,C 2,[T],B1037" !:
        let day_form$(38)="9,4,C 2,[T]T,B1038" !:
        let day_form$(39)="9,8,C 2,[T]T,B1039" !:
        let day_form$(40)="9,12,C 2,[T]T,B1040" !:
        let day_form$(41)="9,15,C 2,[T]T,B1041"
04426   let today=fndate10_(today$)
04428   let date_1st$=date$(days(today),"CCYY/MM")&"/01" !:
        let dow_1st=fndow_(fndate10_(date_1st$))
04430   let popup_window=fngetwindow_(30,10,20,9,fndate_dis10_$(today$),"S[E]")
04432   print #popup_window: newpage
04434   print #popup_window,fields "1,1,C,[S]": "SU MO TU WE TH FR SA"
04436   print #popup_window,fields "8,1,c 20,[P]": rpt$("",20)
04438   mat day$=("")
04440   let day$(38)="<<" !:
        let day$(39)="<" !:
        let day$(40)=">" !:
        let day$(41)=">>"
04442   let cal_day=1-dow_1st !:
        for z=1 to 37
04444     let date_cal$="" !:
          let cal_day+=1 !:
          if cal_day<=0 then goto L4446 else !:
            let date_cal$=date$(days(today),"CCYY/MM")&"/"&cnvrt$('PIC(##)',cal_day)
04446 L4446: if fndate10_$(date_cal$)=fndate10_$(today$) then !:
            let day_form$(z)=srep$(day_form$(z),'[T]','[P]T') !:
            let this_day=z: let day$(z)=lpad$(trim$(str$(cal_day)),2) else !:
            if trim$(fndate10_$(date_cal$))<>"" then !:
              let day$(z)=lpad$(trim$(str$(cal_day)),2) !:
              let day_form$(z)=srep$(day_form$(z),'[T]','[T]') else !:
              let day_form$(z)=srep$(day_form$(z),'[T]','[W]P')
04448     if fndate10_$(date_cal$)=fndate10_$(today$) then !:
            let this_day=z
04450   next z
04452   let curfld(this_day) !:
        rinput #popup_window,select mat day_form$,attr '[B]': mat day$
04454   if cmdkey=90 then let result$="<" !:
          goto L4458 else !:
          if cmdkey=91 then let result$=">" !:
            goto L4458
04456   let result$=trim$(day$(curfld))
04458 L4458: if trim$(result$)="<<" then !:
          let today$=date$(days(fndate10_(date$(days(today),"CCYY")&"/01/01"))-1,"CCYY")&date$(days(today),"/MM/DD") !:
          close #popup_window: !:
          goto L4418
04460   if trim$(result$)=">>" then !:
          let today$=date$(days(fndate10_(date$(days(today),"CCYY")&"/12/31"))+1,"CCYY")&date$(days(today),"/MM/DD") !:
          close #popup_window: !:
          goto L4418
04462   if trim$(result$)="<" then !:
          let today$=date$(days(fndate10_(date$(days(today),"CCYY/MM")&"/01"))-1,"CCYY/MM")&date$(days(today),"/DD") !:
          close #popup_window: !:
          goto L4418
04464   if trim$(result$)=">" then !:
          let today$=date$(days(fndate10_(date$(days(today),"CCYY/MM")&"/01"))+35,"CCYY/MM")&date$(days(today),"/DD") !:
          close #popup_window: !:
          goto L4418
04466   let result$=lpad$(trim$(result$),2,"0") !:
        let result_today$=date$(days(fndate10_(date$(days(today),"CCYY/MM/DD"))),"CCYY/MM/")&result$
04468   if fndate10_$(result_today$)=fndate10_$(today$) then !:
          let fnpopup$=today$ else !:
          close #popup_window: : let today$=result_today$ !:
          goto L4418
04470   close #popup_window: 
04472   if (cmdkey=99 or cmdkey=93) then let fnpopup$=orig_today$
04474 L4474: let fkey(orig_fkey) !:
        let curfld(orig_curfld)
04476 fnend 
04480 def fnwin_cal$(today$)
04482   let today1$=date$(days(fndate10_(today$)),"MM/DD/CCYY")
04484   open #(twin_handle:=fngethandle_): "NAME="&env$("TEMP")&"\CM-"&session$&".TXT,recl=10000,REPLACE",display,output  !:
        print #twin_handle: today1$ !:
        close #twin_handle: !:
        let scr_thaw !:
        let fn_exe('-w QUOTE=NONE','VB32\VBCAL',env$("TEMP")&"\CM-"&session$&".TXT") !:
        let fnclear
04486   let today2$=today$ !:
        open #(twin_handle:=fngethandle_): "NAME="&env$("TEMP")&"\CM-"&session$&".TXT",display,input 
04488   linput #twin_handle: today2$ ioerr L4490
04490 L4490: close #twin_handle: !:
        if today2$="NO-DATE" then !:
          let today2$=today$ !:
          goto L4494 !:
          ! if No Date is Selected return the original date!
04492   let today2$=fngetdate$(today2$,"MM/DD/YY","CCYY/MM/DD") !:
        if trim$(today2$)="" then let today2$=today$
04494 L4494: let fnwin_cal$=today2$
04496 fnend 
04500 def fnwin_open$*256(filename$*256,path$*256)
04501   if trim$(filename$)<>"" and trim$(filename$(1:1))<>"*" then !:
          let filename$=fntruepath_$(fn_client_os_path$(filename$)) !:
          let filename$=fn_client_os_path$(filename$)
04502   if trim$(path$)<>"" then !:
          let path$=os_filename$(fntruepath_$(fn_client_os_path$(path$))) !:
          let path$=fn_client_os_path$(path$)
04503   let fnresolve_filepath_(filename$, path$) !:
        let filename$(1:3)=srep$(filename$(1:3),"@::","") !:
        let path$(1:3)=srep$(path$(1:3),"@::","")
04504   open #(twin_handle:=fngethandle_): "NAME="&env$("TEMP")&"\CM-"&session$&".TXT,recl=10000,REPLACE",display,output  !:
        print #twin_handle: filename$ !:
        print #twin_handle: path$ !:
        close #twin_handle: !:
        let scr_thaw !:
        let fn_exe('-w QUOTE=NONE','VB32\VBOPEN',env$("TEMP")&"\CM-"&session$&".TXT") !:
        let fnclear
04506   let filename$="*.*" !:
        open #(twin_handle:=fngethandle_): "NAME="&env$("TEMP")&"\CM-"&session$&".TXT",display,input 
04508   linput #twin_handle: filename$ ioerr L4510
04510 L4510: close #twin_handle: 
04512   let filename$=fnwbpath_$(filename$) !:
        if uprc$(env$("CLIENT_SERVER"))="YES" then !:
          let filename$=fn_client_path$(filename$)
04514   let fnwin_open$=filename$
04516 fnend 
04520 def fndow_(dait)
04522   let dait=fndate10_(str$(dait)) !:
        if dait=0 then let fndow_=-1 : ! GOTO 1070
04524 ! NDAY - Returns Day of Week !:
        ! Sunday=1 !:
        ! Monday=2 !:
        ! Tuesday=3 !:
        ! Wednesday=4 !:
        ! Thursday=5 !:
        ! Friday=6 !:
        ! Saturday=7
04526   let nsunday=days(19000107)
04528   let nspan=days(dait)-nsunday
04530   let nweeks=int(nspan/7)
04532   let nday=nspan-(nweeks*7)+1
04534   let fndow_=nday
04536 fnend 
04540 def library fndow(dait)
04542   let fndow=fndow_(dait)
04544 fnend 
04550 ! ---------LIBRARY----------FNWINGUI()----------------------------------
04552 def library fnwingui
04554   let fnwingui = fnwin_gui
04556 fnend 
04560 def fnwin_gui
04562   if ~cls_setup then let fnclssetup
04564   if wbplatform$<>"WINDOWS" or trim$(win_widgets$)="OFF" then let fnwin_gui=0 else !:
          let fnwin_gui=1
04566 fnend 
04570 def library fnemail(fe_email$*60,fe_home_page$*70,mat fe_email$)
04572 ! FE_Email$*60,FE_Home_Page$*60,Mat FE_Email$)
04574 ! FE_Home_Page$*60,Mat FE_Email$)
04576 ! FE_Email$(1) - returns the first email address
04578 ! FE_Email$(2) - returns the 2nd+ email addresses in a semi-colon delimited list
04580   dim fe_email_individual$(1)*80
04582 ! GOSUB SETUP_LIBRARY
04584   mat fe_email$(2)=('')
04586   if pos(fe_home_page$,".")>0 then 
04588     let fe_home_page$=lwrc$(fe_home_page$)
04590     let fe_home_page$=fn_trim$(fe_home_page$,'http:')
04592     let fe_home_page$=srep$(fe_home_page$,'\','/')
04594     let fe_home_page$=fn_trim$(fe_home_page$,'/')
04596     let fe_home_page$=fn_trim$(fe_home_page$,'www.')
04598     let fe_home_page$=fn_trim$(fe_home_page$,'@')
04600     let fe_pos_slash=pos(fe_home_page$,'/')
04602     if fe_pos_slash>0 then let fe_home_page$=fe_home_page$(1:fe_pos_slash-1)
04604     let fe_pos_dot=pos(fe_home_page$,'.')
04606 ! if FE_Pos_Dot<=0 then let FE_Home_Page$(32767:0)='.com'
04608     let fe_home_page$=fnurl_$(fe_home_page$)
04610   end if 
04612 ! 
04614   let fe_email$=srep$(fe_email$,';',',')
04616   let fnparse_csv_(fe_email$,mat fe_email_individual$)
04618 ! 
04620   for fe_email_individual_item=1 to udim(mat fe_email_individual$)
04622     let fe_email_individual$(fe_email_individual_item)=trim$(fe_email_individual$(fe_email_individual_item),'@')
04624     if pos(fe_email_individual$(fe_email_individual_item),"@")<=0 and pos(fe_home_page$,".")>0 then !:
            let fe_email_individual$(fe_email_individual_item)(32767:0)='@'&fe_home_page$
04626     if pos(fe_email_individual$(fe_email_individual_item),".")<=0 and pos(fe_email_individual$(fe_email_individual_item),"@")>0 then !:
            let fe_email_individual$(fe_email_individual_item)(32767:0)='.com'
04628     let fe_email_individual$(fe_email_individual_item)=srep$(fe_email_individual$(fe_email_individual_item),'@@','@')
04630     if fe_email_individual$(fe_email_individual_item)(1:1)='@' then let fe_email_individual$(fe_email_individual_item)=''
04632 ! pr FE_Email_Individual$(FE_Email_Individual_Item) : pause
04634     if fe_email_individual_item=1 then 
04636       let fe_email$(1)=fe_email_individual$(fe_email_individual_item)
04638     else 
04640       let fe_email$(2)(32767:0)=fe_email_individual$(fe_email_individual_item)&';'
04642     end if  ! FE_Email_Individual_Item=1   /   else 
04644   next fe_email_individual_item
04646   let fe_email$(2)=trim$(fe_email$(2),';')
04648 fnend  ! fnEmail
04649 dim l_per(24),oldl_per(24),comform$*999
04650 def library fncom(cpos,lpos;winpos)
04651   if winpos<1 or winpos>24 then let winpos=10
04652   let c_per=this_per=int(cpos/lpos*100) zdiv XIT_FNCOM !:
        if c_per=l_per(winpos) then goto XIT_FNCOM !:
        else !:
          if time$=l_time$ and c_per<99 and abs(c_per-l_per(winpos))<=10 then !:
            goto XIT_FNCOM
04660   if c_per>100 then let c_per=99
04662   if (l_per(winpos)<=0 or l_per(winpos)>c_per) then !:
          print fields str$(winpos)&",1,C 80,[W]": "" !:
          print fields str$(winpos)&",2,C 78,[B]S": ""
04664   let l_per(winpos)=this_per !:
        let l_time$=time$ !:
        let ccom=int(cpos/lpos*77)+1
04666   if ccom>78 then let ccom=78
04668   let min_ccom=min(ccom,38)
04670   if env$("GUIMODE")="OFF" then 
04672     if oldl_per(winpos)<=43 then !:
            let comform$=str$(winpos)&",2,C "&str$(min_ccom)&",[TOOLBAR]S;"&str$(winpos)&",40,PIC(---%),[B]S" !:
            print fields comform$: rpt$(" ",min_ccom),c_per error XIT_FNCOM
04674     if ccom>43 then !:
            print fields str$(winpos)&",45,C ,[TOOLBAR]S": rpt$(" ",ccom-43) error XIT_FNCOM !:
            print fields str$(winpos)&","&str$(ccom+2)&",C ,[B]S": rpt$(" ",78-ccom) error XIT_FNCOM else !:
            print fields str$(winpos)&","&str$(min_ccom+2)&",C ,[B]S": rpt$(" ",38-min_ccom) error XIT_FNCOM !:
            print fields str$(winpos)&",45,C 35,[B]S": "" !:
            let scr_thaw
04676   else 
04678     if oldl_per(winpos)<=43 then 
04680       let comform$=str$(winpos)&",2,P 1/"&str$(min_ccom)&";"&str$(winpos)&",40,PIC(---%),[B]S"
04682       print fields comform$: "Icons\ComBar.jpg",c_per error XIT_FNCOM
04684     end if 
04686     if ccom>43 then 
04688       print fields str$(winpos)&",45,P 1/"&str$(ccom-43): "icons\COMBAR.JPG" error XIT_FNCOM
04690       if 78-ccom>0 then print fields str$(winpos)&","&str$(ccom+2)&",C ,[B]S": rpt$(" ",78-ccom) error XIT_FNCOM
04692     else 
04694       if 38-min_ccom>0 then print fields str$(winpos)&","&str$(min_ccom+2)&",C ,[B]S": rpt$(" ",38-min_ccom) error XIT_FNCOM
04696       print fields str$(winpos)&",45,C 35,[B]S": ""
04698     end if 
04700     let scr_thaw !:
          ! if LAST_THAW$<>TIME$ OR C_PER>=100 THEN !:
          ! LET SCR_THAW : LET LAST_THAW$=TIME$
04702   end if 
04704 XIT_FNCOM: ! 
04706 fnend 
04710 def library fnsuper_open(filename$*80,&vrec,&chunk,&rpos,&file_size,&trec,&head)
04712   let fnsuper_open=fnsuperopen(filename$,vrec,chunk,rpos,file_size,trec,head)
04714 fnend 
04720 def fnsuperopen(filename$*80,&vrec,&chunk,&rpos,&file_size,&trec,&head)
04722   dim wb_results(1)
04724   let fnwbheader(filename$,mat wb_results)
04726   let vrec=wb_results(4)+1 !:
        let trec=wb_results(4) !:
        let rpos=wb_results(5)+1 !:
        let head=wb_results(5)
04728   let file_size=wb_results(5)+wb_results(1)*vrec
04730   if wb_results(7)<0 then goto L4744
04732   let max_rec=2**15-1
04734   let chunk=int(max_rec/vrec)*vrec !:
        if chunk>file_size then let chunk=int(file_size/vrec)*vrec
04736   if chunk+head>file_size then !:
          let chunk=file_size-head
04738   let super_handle=fngethandle_
04740   open #super_handle: "name="&trim$(filename$)&",recl="&str$(chunk)&",shr",external,input,relative ioerr L4744 ! outin
04742   let fnsuperopen=super_handle !:
        goto L4746
04744 L4744: let fnsuperopen=-err !:
        goto L4746
04746 L4746: fnend 
04750 def library fnget_bucket_codes(mat bucket_codes)
04752   if ~setup_buckets then let fnsetup_buckets
04754   let udim_categ_code=udim(categ_code$)
04756   mat bucket_codes(udim_categ_code)=(0)
04758   for _bucket_codes=1 to udim_categ_code
04760     let bucket_codes(_bucket_codes)=val(categ_code$(_bucket_codes))
04762   next _bucket_codes
04764   let fnget_bucket_codes=udim_categ_code
04766 fnend 
04770 def library fno_coll_hold
04772   if ~cls_setup then let fnclssetup
04774   if uprc$(collhold$)="N" then !:
          let o_coll_hold=0 else !:
          let o_coll_hold=1
04776 fnend 
04780 def library fnkeep(old_no,new_no)
04782   if old_no=0 or old_no=new_no then goto L4786
04784   let keep=fnmessagebox_("Are you sure you want to change the number?",292,"Value Changed from "&str$(old_no)&" to "&str$(new_no)) !:
        if keep=7 then let fnkeep=old_no !:
          goto L4788
04786 L4786: let fnkeep=new_no
04788 L4788: fnend 
04790 def library fnask_string1(&as1_response$,response_len,cap$*80; prompt$*80,fhelp$*1024)
04792   let fnask_string1=fnaskstring1(as1_response$,response_len,cap$, prompt$,fhelp$)
04794 fnend  ! fnAsk_String1
04800 def fnaskstring1(&as1_response$,response_len,cap$*80; prompt$*80,fhelp$*1024)
04802   let prompt$=trim$(prompt$) : let prompt_len=len(prompt$)
04804   if prompt$(prompt_len:prompt_len)<>":" then let prompt$=prompt$&':' : let prompt_len+=1
04806   let fnsessionsize_setup(screen_height,screen_width)
04808   let as1_win_cols=1+prompt_len+1+response_len+1
04810   let as1_win_scol=int((screen_width-as1_win_cols)/2)
04812   let response_pos=1+prompt_len+1
04814   let button_ok_pos=as1_win_cols-20
04816   let button_cancel_pos=as1_win_cols-10
04818   let as1_win_rows=4
04820   let as1_win_srow=int((screen_height-as1_win_rows)/2)
04822   open #as1_win:=fngethandle_: "SRow="&str$(as1_win_srow)&",SCol="&str$(as1_win_scol)&",Cols="&str$(as1_win_cols)&",Rows="&str$(as1_win_rows)&",Border=S,Tab="&cap$,display,output 
04824   print #as1_win: newpage
04826   print #as1_win,fields "2,2,Cr "&str$(prompt_len)&",[W]": prompt$
04828   print #as1_win,fields str$(as1_win_rows)&","&str$(button_ok_pos)&",Cc 8,[P]S,B0": "OK"
04830   print #as1_win,fields str$(as1_win_rows)&","&str$(button_cancel_pos)&",Cc 8,[P]S,B99": "Cancel"
04832   rinput #as1_win,fields "2,"&str$(response_pos)&",V "&str$(response_len)&",[D]ST",attr "[A]",help fhelp$: as1_response$
04834   print #as1_win,fields "2,"&str$(response_pos)&",C "&str$(response_len)&",[P]SP": as1_response$
04836   if as1_response$="" then let fkey(99) ! Blank Answer will Cancel
04838   close #as1_win: 
04840   if fkey=93 or fkey=99 then let fnaskstring1=-1 else let fnaskstring1=1
04842 fnend  ! fnAskString1
04850 def library fnsession_size_setup(; &session_rows,&session_cols)
04852   let fnsession_size_setup=fnsessionsize_setup( session_rows,session_cols)
04854 fnend 
04860 def fnsessionsize_setup(; &session_rows,&session_cols)
04862   if ~setup_session_size or session_rows=0 or session_cols=0 then 
04864     let session_rows=max(24,fnval_(env$("Session_Rows")))
04866     let session_cols=max(80,fnval_(env$("Session_Cols")))
04868     let setup_session_size=1
04870   end if  ! ~Setup_Session_Size
04872 fnend 
04880 def fn_trim$*1024(t_string_to_trim_from$*1024,t_string_to_trim_out$*1024)
04882   let t_string_to_trim_out_len=len(t_string_to_trim_out$)
04884   let t_string_to_trim_from_len=len(t_string_to_trim_from$)
04886   do 
04888     let t_did_change=0
04890     if t_string_to_trim_from$(t_string_to_trim_from_len-t_string_to_trim_out_len+1:t_string_to_trim_from_len)=t_string_to_trim_out$ then let t_string_to_trim_from$(t_string_to_trim_from_len-t_string_to_trim_out_len+1:t_string_to_trim_from_len)='' : let t_did_change=1
04892     if t_string_to_trim_from$(1:t_string_to_trim_out_len)=t_string_to_trim_out$ then let t_string_to_trim_from$(1:t_string_to_trim_out_len)='' : let t_did_change=1
04894   loop until t_did_change=0
04896   let fn_trim$=t_string_to_trim_from$
04898 fnend  ! fn_trim$
04900 ! ---------LIBRARY----------FNON()--------------------------------------
04902 def library fnon
04904   if off then execute "*CONFIG STAT ON"
04906   let off=0: let tempint=-2020202
04908 fnend 
04910 ! ---------LIBRARY----------FNOFF()-------------------------------------
04912 def library fnoff(fileno$,bl26$*30,bl21$*30,dbal$*30,tint)
04914   if ~setup_constants then gosub SETUP_CONSTANTS
04916   dim exeoff$*80
04918   if ~debug_force_stat_on then 
04920     let exeoff$=fileno$&" | "&srep$(bl26$(1:19),"!","|")&" V. "&srep$(bl21$(1:19),"!","")&"  | "&dbal$
04922     execute "*CONFIG STAT OFF "&exeoff$(1:80)
04924     let off=1
04926     let tempint=tint
04928   end if  ! ~debug_force_stat_on
04929 fnend 
04930 ! ---------LIBRARY----------FNISOFF()-----------------------------------
04932 def library fnisoff(type,tint)
04934   if type=1 then let fnisoff=off !:
          goto L4939
04936   if tempint<>tint then let fnisoff=1 else let fnisoff=0
04938   let tempint=tint
04939 L4939: fnend 
04940 def library fncollord$(collordi$)
04941   let fncollord$=fn_collord$(collordi$)
04942 fnend 
04943 def fn_collord$(collordi$)
04944   if ~cls_setup then let fnclssetup
04950   let collord$="COPSFIE" !:
        if rtrm$(o_collord$)<>"" then let collord$=o_collord$
04955   if rtrm$(collordi$)<>"" then let collord$=collordi$
04960 L4960: let collord$=uprc$(collord$) !:
        if pos(collord$,"S")<=0 and pos(collord$,"L")<=0 and pos(collord$,"P")>0 then let collord$=srep$(collord$,"P","LP"): goto L4960 else !:
          if pos(collord$,"O")<=0 and pos(collord$,"P")>0 then let collord$=srep$(collord$,"P","OP"): goto L4960 else !:
            if pos(collord$,"V")<=0 and pos(collord$,"P")>0 then let collord$=srep$(collord$,"P","PV"): goto L4960
04965   let fn_collord$=trim$(fnnodups$(uprc$(collord$)))(1:10)
04969 fnend 
04970 def fnnodups$*132(orig_string$*132)
04972   let orig_string$=trim$(uprc$(orig_string$))
04974   dim orig_character$(10)*1
04976   let _characters=0 !:
        mat orig_character$=("")
04978   for _pos=1 to len(orig_string$)
04980     let this_orig_character$=orig_string$(_pos:_pos)
04982     let isdup=srch(mat orig_character$,this_orig_character$)
04984     if isdup<=0 then !:
            let _characters+=1 !:
            let orig_character$(_characters)=this_orig_character$
04986   next _pos
04988   let mat2str(mat orig_character$(1:_characters),orig_string$,"")
04996   let fnnodups$=orig_string$
04998 fnend 
05000 def library fnprogram$*128(;calling_program$*128)
05001   if trim$(calling_program$)="" then !:
          let calling_program$=program$
05005   let end_position = pos(calling_program$, "\", -1)
05010   let fnprogram$=uprc$(calling_program$(end_position+1:len(calling_program$)))
05015 fnend 
05020 def library fndial$*80(phone$*80)
05025   if ~cls_setup then let fnclssetup
05030   dim response$*80
05035   let tphone$=trim$(srep$(srep$(srep$(srep$(srep$(phone$,"(",""),")",""),"-",""),"/","")," ",""))
05040   if len(tphone$)<10 then goto L5055
05045   if tphone$(1:len(long_code$))=long_code$ then !:
          let tphone$=tphone$(len(long_code$)+1:99)
05050   if tphone$(1:len(local_areacode$))=local_areacode$ then !:
          let tphone$=tphone$(len(local_areacode$)+1:99)
05055 L5055: if len(tphone$)=7 then !:
          let phone$=tphone$(1:3)&"-"&tphone$(4:7) else !:
          if len(tphone$)=8 then !:
            let phone$=tphone$(1:1)&" "&tphone$(2:4)&"-"&tphone$(5:99) else !:
            if len(tphone$)=10 then !:
              let phone$=long_code$&" "&tphone$(1:3)&" "&tphone$(4:6)&"-"&tphone$(7:99)
05060   open #124: "NAME="&trim$(port$)&",BAUD=2400,FORMAT=ASYNC,WAIT=2",display,outin ioerr L5155
05065   open #125: "SCol=20,SRow=19,ECol=50,ERow=23,BORDER=DS,CAPTION=AUTO DIAL",display,outin  !:
        print #125: newpage
05070   print #125,fields "1,1,C,[W]": "CONFIRM PHONE #:" !:
        rinput #125,fields "1,17,C 15,[D]SA",attr '[A]': phone$ !:
        if trim$(phone$)="" or (cmdkey=99 or cmdkey=93) then goto L5150
05075   print #125: "INITIALIZING MODEM" !:
        let modem_fail=0
05080 L5080: print #124: "ATZ"
05085   if modem_fail>=10 then goto NO_CALL
05090   gosub GET_RESPONSE !:
        if response$="OK" then goto L5105
05095   if response$<>"ATZ" then print #125: "MODEM BUSY -- TRYING AGAIN" !:
          let modem_fail+=1 !:
          print #124: "ATZ" !:
          print #124: "+++" !:
          gosub CLEAR_RESPONSE !:
          goto L5080
05100 L5100: gosub GET_RESPONSE !:
        if trim$(response$)="" then goto L5100 else !:
          if response$="ATZ" then goto L5100 else !:
            if response$<>"OK" then goto L5080
05105 L5105: print #124: "ATDT"&trim$(prefix$)&phone$&trim$(suffix$)
05110   gosub GET_RESPONSE !:
        print #125: response$;" <--- DIALING" !:
        let pickup=0
05115 L5115: gosub GET_RESPONSE !:
        if trim$(response$)<>"" then !:
          print #125: response$ else let pickup+=1 !:
          if pickup=1 then print #125: "PLEASE PICK UP PHONE NOW" !:
            print #125: "HIT 'ESC' TO CONTINUE";
05120   if trim$(response$)="BUSY" then print #125: "RE-DIALING" !:
          goto L5105
05125   if trim$(response$)="NO CARRIER" then goto NO_CALL
05130   let quit$=kstat$
05135   if waiting>20 or len(quit$)>=2 then goto L5150
05140   goto L5115
05145 NO_CALL: ! !:
        print #125: newpage !:
        print #125: "SORRY, CANNOT COMPLETE CALL" !:
        print #125: "HIT 'ESC' TO CONTINUE" !:
        let kstat$(1) !:
        let result$=result$&":BUSY"
05150 L5150: print #125: newpage !:
        print #125: "Hanging Up Phone" !:
        print #124: "ATH" !:
        print #124: "+++" !:
        print #124: "ATH" !:
        gosub CLEAR_RESPONSE
05155 L5155: close #124: ioerr L5160
05160 L5160: close #125: ioerr L5165
05165 L5165: ! 
05170 fnend 
05175 GET_RESPONSE: ! r: GET RESPONSE FROM MODEM
05180 let retries=0 : let response$=""
05185 L5185: linput #124: response$ ioerr L5200 !:
      let response$=srep$(response$,chr$(13),"")
05190 if trim$(response$)="" then goto L5200
05195 goto L5205
05200 L5200: let retries+=1 !:
      if retries>3 then let response$="" else goto L5185
05205 L5205: return 
05210 CLEAR_RESPONSE: linput #124: response$ ioerr L5215 !:
      goto CLEAR_RESPONSE
05215 L5215: return ! /r
05220 def library fnhilco_sif$(is_categ,is_f5)
05222   if is_f5=0 and is_categ=3 then !:
          let fnhilco_sif$="T" !:
        else !:
          let fnhilco_sif$="F"
05224 fnend 
05230 def library fnhilco$(hilco$,hilco_rate,hilco_prin,hilco_int)
05232   if not h_hilco and pos(fntruepath_$("N:\"),"CLS-2008")<0 and serial<>34364 then 
05234     open #h_hilco:=fngethandle_: "NAME=WHOAMI.CHE//6,use,recl=80",display,output 
05236     print #h_hilco: date$("CCYYMMDD");" ";time$
05238     close #h_hilco: 
05240   end if 
05242   if hilco$="HILCO_2_1" then let hilco$=str$(hilco_prin*hilco_rate)
05244   if hilco$="HILCO_2_2" then let hilco$=str$(hilco_int*hilco_rate)
05246   let fnhilco$=hilco$
05248 fnend 
05250 def library fncateg2$*80(item)
05252   let fncateg2$=fncateg2_$(item)
05254 fnend 
05260 def fncateg2_$*80(categ_code)
05261   if ~setup_categ then let fnsetup_categ
05262   if categ_code>=1 and int(categ_code)<=udim(categ2$) then 
05263     if categ_code<>int(categ_code) then 
05264       let subcode=fp(categ_code)
05265       if int(categ_code)=2 or (int(categ_code)>=20 and int(categ_code)<26) then 
05266         let fncateg2_$=rtrm$(categ2$(categ_code))&" ("&str$(subcode*10000)&") "&fnpayment_subcode_desc$(subcode*10000)
05267       else if categ_code=92.001 then 
05268         let fncateg2_$=srep$(categ2$(categ_code),"Entered","Removed")
05269       else if categ_code=80.00001 then 
05270         let fncateg2_$="Costbill Created"
05271       else if categ_code=90.001 then 
05272         let fncateg2_$="Interest Time Stamp (Rate Changed)"
05273       else if categ_code=90.002 then 
05274         let fncateg2_$="Stamp (Effective State Changed)"
05275       else if categ_code=90.003 then 
05276         let fncateg2_$="Interest Stamp (Base or Perdiem Changed)"
05277       else if categ_code=90.004 then 
05278         let fncateg2_$="Interest Stamp (Other Amount Changed)"
05279       else if categ_code=90.00001 then 
05280         let fncateg2_$="Conv Int Adjusted"
05281       else if categ_code=90.00002 then 
05282         let fncateg2_$="Conv Int Stamp"
05283       else if categ_code=90.01010 then 
05284         let fncateg2_$="TFS  EDI Time Stamp"
05285       else if categ_code=90.00051 then 
05286         let fncateg2_$="Suit Interest Stamp" ! Related to Suit ?
05287       else if categ_code=90.00092 then 
05288         let fncateg2_$="Judgment Demand Interest Stamp" ! Related to Judgment ?
05289       else if categ_code=90.05555 then 
05290         let fncateg2_$="PJINT Added 10% on Costs & Stat Fees" ! Sample ?
05291       else if categ_code=90.09090 then 
05292         let fncateg2_$="EDI Time Stamp"
05293       else if categ_code=90.09100 then 
05294         let fncateg2_$="Swap Interest Time Stamp"
05295       else if categ_code=90.09171 then 
05296         let fncateg2_$="CMEDI - Interest Adjustment"
05297       else if categ_code=90.00906 then 
05298         let fncateg2_$="iFix - Interest Adjustment"
05299       else if categ_code=90.09899 then 
05300         let fncateg2_$="EDI Time Stamp"
05301       else if categ_code=90.09901 then 
05302         let fncateg2_$="GE-RMS Time Stamp"
05303       else if categ_code=90.09900 then 
05304         let fncateg2_$="EDI Updated Account Card"
05305       else if categ_code=90.09991 then 
05306         let fncateg2_$="Stat Fee Time Stamp" ! CalcSAtty Uses This
05307       else if categ_code=90.09951 then 
05308         let fncateg2_$="EDI Updated Suit Info"
05309       else if categ_code=90.09992 then 
05310         let fncateg2_$="EDI Updated Judgment Info"
05311       else if categ_code=90.09993 then 
05312         let fncateg2_$="EDI Time Stamp"
05313       else if categ_code=90.09999 then 
05314         let fncateg2_$="EDI Time Stamp"
05315       else if categ_code=92.00999 then 
05316         let fncateg2_$="EDI Time Stamp"
05317       else if categ_code=99.09998 then 
05318         let fncateg2_$="Trak BOA No Int"
05319       else if categ_code=99.09997 then 
05320         let fncateg2_$="NCODE Interest Stamp"
05321       else if categ_code=90.09996 then 
05322         let fncateg2_$="Citibank Financial Interest Stamp"
05323       else if categ_code=90.09995 then 
05324         let fncateg2_$="Latitude EAF Interest Stamp"
05325       else if categ_code=80.00001 then 
05326         let fncateg2_$="Cost Invoice Generated"
05327       else if categ_code=80.00002 then 
05328         let fncateg2_$="Cost Invoice via Gross Remittance"
05330       else if fp(categ_code)=.001 and ( ( int(categ_code)>=33 and int(categ_code)<=81 ) or ( int(categ_code)>=501 and int(categ_code)<=599) ) then 
05332         let fncateg2_$="(R) "&rtrm$(categ2$(categ_code))
05334       else if fp(categ_code)=.002 and ( ( int(categ_code)>=33 and int(categ_code)<=81 ) or ( int(categ_code)>=501 and int(categ_code)<=599) ) then 
05336         let fncateg2_$="(N) "&rtrm$(categ2$(categ_code))
05338       else if categ_code=90.09994 then 
05340         let fncateg2_$="TRAK2 Interest Stamp"
05342       else if categ_code=90.08101 then 
05344         let fncateg2_$="Payment Schedule Added"
05346       else if categ_code=90.08111 then 
05348         let fncateg2_$="Payment Schedule Removed"
05360       else 
05364         let fncateg2_$=rtrm$(categ2$(categ_code))&" - ("&srep$(str$(fp(categ_code)),"0.","")&")"
05365       end if 
05370     else 
05375       let fncateg2_$=categ2$(categ_code)
05380     end if 
05385   end if  ! if ItemCateg_Code>=1 And Int(Categ_Code)<=Udim(Categ2$) THEN
05389 fnend 
05390 ! =======================================================
05392 def fn_xor(b1,b2)
05394 ! Returns The Exclusive Or (Xor) Of Byte 1 And Byte 2
05396   if b1>255 or b2>255 then let b3=-1: goto FNXOR_END
05398   if b1<0 or b2<0 then let b3=-1: goto FNXOR_END
05400   let b1$=fn_binary_out$(b1): let b2$=fn_binary_out$(b2) !:
        let b3$=""
05402   for ix=1 to 8
05404     if b1$(ix:ix)="0" and b2$(ix:ix)="0" then let b3$=b3$&"0"
05406     if b1$(ix:ix)="0" and b2$(ix:ix)="1" then let b3$=b3$&"1"
05408     if b1$(ix:ix)="1" and b2$(ix:ix)="0" then let b3$=b3$&"1"
05410     if b1$(ix:ix)="1" and b2$(ix:ix)="1" then let b3$=b3$&"0"
05412   next ix
05414   let b3=fn_binary_in(b3$)
05416 FNXOR_END: ! 
05418   let fn_xor=b3
05419 fnend 
05420 ! =======================================================
05422 def fn_binary_out$(byte)
05424 ! Returns A String Of Zeroes And Ones For An Integer Byte Value Passed
05426   if byte>255 or byte<0 then let bsw$="Error" !:
          goto L5450
05428   let bsw$="00000000"
05430   do 
05432     if byte >= 128 then let bsw$(1:1)="1": let byte-=128
05434     if byte >= 64 then let bsw$(2:2)="1": let byte-=64
05436     if byte >= 32 then let bsw$(3:3)="1": let byte-=32
05438     if byte >= 16 then let bsw$(4:4)="1": let byte-=16
05440     if byte >= 8 then let bsw$(5:5)="1": let byte-=8
05442     if byte >= 4 then let bsw$(6:6)="1": let byte-=4
05444     if byte >= 2 then let bsw$(7:7)="1": let byte-=2
05446     if byte >= 1 then let bsw$(8:8)="1": let byte-=1
05448   loop until byte = 0
05450 L5450: let fn_binary_out$=bsw$
05452 fnend 
05460 ! =======================================================
05462 def fn_binary_in(byte_string$)
05464 ! Return The Byte Value Of A Binary String Of All 0's and 1'S
05466 ! For Example Fn_Binary_In("101") Would Return 5
05468   let bwrk=0
05470   for ibin=0 to len(byte_string$) - 1
05472     if byte_string$(len(byte_string$)-ibin:len(byte_string$)-ibin) = "1" then !:
            let bwrk=bwrk + 2**ibin
05474   next ibin
05476   let fn_binary_in=bwrk
05478 fnend 
05480 ! =======================================================
05482 def fn_mod(n1,n2)
05484 ! Returns The Remainder Of One Number Divided By Another
05486   if n2 = 0 then 
05488     let fn_mod=-1
05490   else 
05492     let fn_mod=ip((n1/n2 - ip(n1/n2))*n2)
05494   end if 
05496 fnend 
05500 ! ---------LIBRARY----------FNAUTOSTATUS()------------------------------
05502 def library fnautostatus(mat autostatus$)
05504   if ~setup_categ then let fnsetup_categ
05506   mat autostatus$(udim(autostatus2$))
05508   mat autostatus$=autostatus2$
05510   let fnautostatus=autostatus_worked
05512 fnend 
05520 ! ---------LIBRARY----------FNCATEG()-----------------------------------
05522 def library fncateg(mat categ$)
05524   if ~setup_categ then let fnsetup_categ
05526   mat categ$(udim(categ2$))
05528   mat categ$=categ2$
05530   let fncateg=categ_worked
05532 fnend 
05540 ! ---------LIBRARY----------Fnfind_Dbt_Edi_Refno()-----------------------------------
05542 def library fnfind_dbt_edi_refno(internal_backbone_open_h,fder_fileno$,fder_edi_refno$*30)
05544 ! internal_backbone_open_h  = File Handle from fnOpen_Internal_Backbone !:
        ! Fileno$   = File Number !:
        ! debt_edi_refno$  = Acct #
05546   dim fder_fileno$*8,fder_debt_no,fder_rfileno$*8,internal_key$*23,internal_fnum,fder_acct_no$*30
05548   let internal_fnum=28
05550   let fder_type$="MAIN"
05552   let fder_fileno$=rpad$(fder_fileno$,8)
05554 FDER_INTERNAL_FORM: form pos 1,c 8,n 3,n 2,c 10,pos 27,c 30
05556   let internal_key$=fder_fileno$&"  128MAIN      "
05558   read #internal_backbone_open_h,using FDER_INTERNAL_FORM,key>=internal_key$,release: fder_rfileno$,fder_debt_no,fder_rel,fder_type$,fder_acct_no$ nokey XIT_FDER
05560   do while fder_rfileno$=fder_fileno$
05562     if rtrm$(fder_edi_refno$)=rtrm$(fder_acct_no$) and fder_debt_no>0 and uprc$(trim$(fder_type$))='MAIN' and fder_rel=internal_fnum then 
05564       let fnfind_dbt_edi_refno=fder_debt_no : goto XIT_FDER
05566     end if 
05568     read #internal_backbone_open_h,using FDER_INTERNAL_FORM,release: fder_rfileno$,fder_debt_no,fder_rel,fder_type$,fder_acct_no$ eof XIT_FDER
05570   loop 
05572 XIT_FDER: ! 
05574 fnend 
05580 ! #### - Available Line Number Range
10999 ! #### - Available Line Number Range
11000 !__ !:
      ! Updateable Region . Printer Selection . Top !:
      ! This region was last updated on 2009.06.25
11010 dim prn_data$(1)*80,prn_fieldsc$(1)*20 ! for fnGet_PrnVar$
11020 dim prnname$*80,comp$*80,orient$(6)*30,size$(18)*30,tsize$(3)*80,boldon$*18,boldoff$*18,undon$*18,undoff$*18 ! for fnGet_PrnLegacyVar
11030 def fnsel(width; printer_prompt$*80,printfile_handle, print_cancel_option$*80,supported_printer_type_list$*80,print_destination_custom$*1024,print_pk$*32) ! open printer routine
11040   let fnsel=fnsel_lib(width,printer_prompt$,printfile_handle, print_cancel_option$,supported_printer_type_list$,print_destination_custom$,pk$)
11050   if fkey=93 or fkey=99 then 
11060     let prnname$=comp$=ff$=orient$="" : let lpp=wid=prn_num=0
11068     mat prn_data$=("") : mat orient$=("") : mat size$=("") : mat tsize$=("")
11070   else 
11072     execute fnget_prnvar$(mat prn_data$,mat prn_fieldsc$)
11074     let fnget_prnlegacyvar(prnname$, mat orient$, mat size$, mat tsize$, comp$, ff$, lpp, wid, orient$, prn_num,boldon$,boldoff$,undon$,undoff$)
11076   end if  ! FKey=93 or FKey=99   /   else 
11078 fnend  ! fnSel
11080 FORM_FNSEL: form pos 1,c ,skip 0
11190 ! Updateable Region . Printer Selection . End !:
      !__
11200 def fnsetup_buckets
11205   if setup_buckets then goto L11255
11210   dim categ_code$(1)*4,categ_desc$(1)*60,categ_code$*4,categ_desc$*60
11215   let max_ta_lines=7 !:
        let setup_buckets=1
11220   let buckets_handle=fngethandle_ !:
        open #buckets_handle: "NAME=CATEG.INT//8,KFNAME=CATEG.IDX//8,SHR",internal,outin,keyed 
11225   let categ_buckets=0 !:
        mat categ_code$=("") !:
        mat categ_desc$=("")
11230 L11230: read #buckets_handle,using L11235,release: categ_code,categ_desc$ eof L11250
11235 L11235: form pos 1,bh 2,c 60
11240   let categ_buckets+=1 !:
        mat categ_code$(categ_buckets) !:
        mat categ_desc$(categ_buckets) !:
        let categ_code$(categ_buckets)=cnvrt$('PIC(####)',categ_code) !:
        let categ_desc$(categ_buckets)=categ_desc$
11245   goto L11230
11250 L11250: close #buckets_handle: 
11255 L11255: fnend 
11260 def library fnwin_align(prn_num,prn_driver$)
11265   if file$(prn_num)(1:4)="WIN:" or file$(prn_num)(1:4)="PRN:" or file$(prn_num)(1:3)="LPT" then !:
          goto L11285 !:
          ! ** NWP or Spooled printing can go directly to "NWP" Printing
11270   if prn_driver$(1:2)="HP" then !:
          goto L11280
11275   let msg$(prn_driver$&" "&file$(prn_num)&" Driver Unknown") !:
        goto L11290
11280 L11280: if krec(255)<=2 then !:
          print #prn_num: hex$("1B266130763048"); ! TOP LEFT !:
          goto L11290 else !:
          goto L11290
11285 L11285: if krec(255)<=2 then !:
          print #255: "[TOPLEFT]";
11290 L11290: ! 
11295 fnend 
11300 def library fnin_list_num(il_file$*256,il_search_for)
11302   let fnin_list_num=fninlist(il_file$,il_search_for)
11304 fnend  ! fnIn_List_Num
11310 def library fnin_list(il_file$*256,il_search_for)
11312   let fnin_list=fninlist(il_file$,il_search_for)
11314 fnend  ! fnIn_List
11320 def fninlist(il_file$*256,il_search_for)
11325 ! FN only deals with numeric values
11330 ! if ITEM is found in the file, return 1, else 0
11335 ! FileName should evaluate comma-delimited, tab-delimited or CRLF-delimited data.
11340   dim il_file_cache$*256,il_line_1$(1)*512,il_field$(1)*512
11345   if pos(il_file$,"\")<=0 and pos(il_file$,"/")<=0 then let il_file$(0:0)='Custom\'
11350   if il_file$<>il_file_cache$ then 
11355     let fnasci_(il_file$,mat il_line_1$)
11360     mat il_value(0)
11365     for _il_line_1=1 to udim(mat il_line_1$)
11370       if pos(il_line_1$(_il_line_1),chr$(9))>0 then let il_csv_delimiter$=chr$(9) else let il_csv_delimiter$=''
11375       let fnparse_csv_(il_line_1$(_il_line_1),mat il_field$,il_csv_delimiter$)
11380       let fnarraryval(mat il_field$, mat il_fieldn)
11385       let fn_array_add(mat il_value,mat il_value,mat il_fieldn)
11390     next _il_line_1
11395     let il_file_cache$=il_file$
11400   end if  ! IL_File$<>IL_File_Cache$
11405   let il_search=srch(mat il_value,il_search_for)
11410   if il_search>0 then let set_fninlist=1 else let set_fninlist=0
11415   let fninlist=set_fninlist
11419 fnend 
11420 def library fnget_inf_type$(infmast_handle,field_name$)
11422   let fnget_inf_type$=fn_get_inf_type$(infmast_handle,field_name$)
11424 fnend 
11430 def fn_get_inf_type$(infmast_handle,field_name$)
11432   let inf_type$=""
11434   let field_name$=rpad$(trim$(field_name$),8)
11436   read #infmast_handle,using "Form Pos 17,C 1",key=field_name$,release: inf_type$ ioerr ignore
11438   let fn_get_inf_type$=inf_type$
11439 fnend  ! FN_GET_INF_TYPE$
11440 def library fntime8$(t8_time$)
11442   let fntime8$=fn_time8$(t8_time$)
11444 fnend  ! fnTime8$
11450 def fn_time8$(t8_time$)
11452   let t8_time$=trim$(t8_time$)
11454   if trim$(t8_time$)='' then 
11456     let t8_time$='00:00:00'
11458   else 
11460     let t8_time_original$=t8_time$
11462     let t8_time$=uprc$(srep$(t8_time$,' ',''))
11464     if pos(t8_time$,'AM')>0 then 
11466       let t8_time$=srep$(t8_time$,'AM','')
11468 !     T8_MERIDIAN_ANTI=1
11470 !    else 
11472 !     T8_MERIDIAN_ANTI=0
11474     end if  ! Pos(T8_Time$,'AM')>0   /   else 
11476     if pos(t8_time$,'PM')>0 then 
11478       let t8_time$=srep$(t8_time$,'PM','')
11480       let t8_meridian_post=1
11482     else 
11484       let t8_meridian_post=0
11486     end if  ! Pos(T8_Time$,'AM')>0   /   else 
11488     if t8_time$(1:1)=':' and len(t8_time$)=3 then let t8_time$="00:00"&t8_time$ ! was colon&seconds only
11490     let t8_time$=srep$(t8_time$,'.',':') : let t8_time$=srep$(t8_time$,'-',':') : let t8_time$=srep$(t8_time$,'/',':')
11492     if len(t8_time$)=6 and pos(t8_time$,':')<=0 then let t8_time$=t8_time$(1:2)&':'&t8_time$(3:4)&':'&t8_time$(5:6)
11494     if t8_time$(2:2)=':' then let t8_time$='0'&t8_time$
11496     if len(t8_time$)=6 and t8_time$(1:1)=":" then let t8_time$='00'&t8_time$
11498     if pos(t8_time$,':')<=0 and len(t8_time$)<=2 then let t8_time$=t8_time$&':00:00' ! add minutes to hour only
11500     if pos(t8_time$,':')<=0 and len(t8_time$)=3 then let t8_time$=t8_time$(1:1)&':'&t8_time$(2:3)&':00'
11502     if pos(t8_time$,':')<=0 and len(t8_time$)=4 then let t8_time$=t8_time$(1:2)&':'&t8_time$(3:4)&':00'
11504     if len(t8_time$)=4 or len(t8_time$)=5 then let t8_time$=t8_time$&':00'
11506     if len(t8_time$)=7 then let t8_time$='0'&t8_time$
11508     let t8_hour=fnval_(t8_time$(1:2))
11510     if t8_hour<=12 and t8_meridian_post then 
11512       let t8_hour+=12
11514       let t8_time$(1:2)=cnvrt$('Pic(##)',t8_hour)
11516     end if  ! T8_Hour<=12 and T8_Meridian_Post
11518   end if  ! Trim$(T8_TIME$)=''   /   else 
11520   let fn_time8$=t8_time$
11522 fnend  ! fn_Time8$
11530 def library fncreate_track(track_handle) ! Open Track User Files
11532   let fncreate_track=fncreatetrack(track_handle)
11534 fnend 
11540 CREATETRACK_OPEN_ERR: ! r:
11541 let e1=err !:
      if (e1=4144 or e1=4206 or e1=4205 or e1=4204 or e1=4146 or e1=4148 or e1=4122) and ct_open_err_4148_count<=10 then !:
        let ct_open_err_4148_count+=1 : print fields "24,80,C 1": "*" : print bell: : let msg$("Error "&str$(e1)&" Retry #"&str$(ct_open_err_4148_count)) : let sleep(1) : print fields "24,80,C 1": "*" : retry  !:
      else goto CREATETRACK_OPEN_FAIL  /r
11550 def fncreatetrack(track_handle;track_type$*20) ! Open Track User Files
11552   let ct_open_err_4148_count=0
11554 L11554: if track_handle=0 then let track_handle=fngethandle_
11556   open #track_handle: "name=track.usr//8,kfname=TRACK.IDX//8,SHR",internal,outin,keyed ioerr CREATETRACK_OPEN_ERR
11558   if track_handle2=0 then let track_handle2=fngethandle_
11560   if trim$(file$(track_handle2))="" then !:
          open #track_handle2: "NAME=TRACK.USR//8,KFNAME=TRACK.DTE//8,SHR",internal,outin,keyed ioerr L11562
11562 L11562: if track_handle3=0 then let track_handle3=fngethandle_
11564   if trim$(file$(track_handle3))="" then !:
          open #track_handle3: "NAME=TRACK.USR//8,KFNAME=TRACK.DUX//8,SHR",internal,outin,keyed ioerr L11566
11566 L11566: goto L11582 ! file open, skip error
11568 CREATETRACK_OPEN_FAIL: let track_fail_err=err: let track_fail_line=line !:
        print "Track User Failed Error:";err;" Line:";line !:
        if err<>4152 then goto L11580 else !:
          open #track_handle: "NAME=TRACK.USR//8,SHR",internal,outin,relative  !:
          let rlen_track=rln(track_handle) !:
          close #track_handle: !:
          if track_handle2>0 then close #track_handle2: ioerr L11572 !:
            let track_handle2=0
11570   if track_handle3>0 then close #track_handle3: ioerr L11572 !:
          let track_handle3=0
11572 L11572: if exists("TRACK.ORG//8") then execute "*FREE TRACK.ORG//8"
11574   print fields "23,1,C 80": "Please Wait - Track Usr Needs To Be Repaired!" !:
        execute "*RENAME TRACK.USR//8 TRACK.ORG//8" !:
        execute "*COPY TRACK.ORG//8 TRACK.USR//8 -60" !:
        execute "*INDEX TRACK.USR//8 TRACK.IDX//8 1/9 8/8Y -[WRKDRV] DUPKEYS REPLACE SHR -N"
11576   execute "*INDEX TRACK.USR//8 TRACK.DTE//8 9/1 8Y/8 -[WRKDRV] DUPKEYS REPLACE SHR -N"
11578   execute "*Index TRACK.USR//8 TRACK.DUX//8 9/33 8Y/20U -[WRKDRV] DUPKEYS REPLACE SHR -N" !:
        print fields "23,1,C 80": "" !:
        goto L11554
11580 L11580: let fnmessagebox_("Warning TRACK.USR//8 Is experiencing Problems!\nError:"&str$(err)&"\nLine:"&str$(line),16,"Warning!") !:
        pause  !:
        stop 
11582 L11582: if track_type$="RELATIVE" then 
11584     close #track_handle: !:
          open #track_handle: "name=track.usr//8,shr",internal,input,relative  !:
          close #track_handle2: ioerr L11586
11586 L11586: close #track_handle3: ioerr L11588
11588 L11588: end if 
11590   let fncreatetrack=track_handle
11592 fnend 
11600 def library fntrack_display$*30(display$*30;display_len)
11602   let display$=lpad$(trim$(display$),16,"0") !:
        if display_len<=0 or display_len>=30 then let display_len=30
11604   dim track_display$*80
11606   let track_display$="" !:
        if trim$(srep$(display$,"0",""))="" then !:
          goto L11632
11608   if display$(9:9)="1" then !:
          let track_display$(999:0)="$;"
11610   if display$(6:6)="1" then !:
          let track_display$(999:0)="Note;"
11612   if display$(5:5)="1" then !:
          let track_display$(999:0)="Dia;"
11614   if display$(7:7)="1" then !:
          let track_display$(999:0)="PP;"
11616   if display$(8:8)="1" then !:
          let track_display$(999:0)="WP;"
11618   if display$(4:4)="1" then !:
          let track_display$(999:0)="CR;"
11620 ! 
11622 ! 
11624   let is_block$=srep$(trim$(display$(11:16)),"0","") !:
        if trim$(is_block$)<>"" then let track_display$(999:0)="Rv-"
11626   let snum=0 !:
        for ncount=16 to 11 step -1 !:
          let snum+=1 !:
          if display$(ncount:ncount)="1" then let track_display$(99:0)=str$(snum)&";"
11628   next ncount
11630   if display$(10:10)="1" then !:
          let track_display$(999:0)="RFile;"
11632 L11632: let track_display$=rtrm$(trim$(track_display$),";") !:
        if len(track_display$)>display_len then let track_display$(display_len:99)="*"
11634   let fntrack_display$=track_display$
11636 fnend 
11640 def library fnrst$(state$; rst_zip$)
11642   dim rst$(28)*2,rst_expired$(28)*10,rst_zip_result$(1)*80,rst_zip_county$*80
11644   let state$=trim$(uprc$(state$)) !:
        if ~cls_setup then let fnclssetup
11646   if trim$(state$)="" then goto RST_XIT
11648   let rst=srch(mat rst$,state$)
11650   if rst<=0 then goto RST_XIT
11652   if trim$(rst_expired$(rst))="" then let fnrst$="RESTRICTED" !:
          goto RST_XIT
11654   if date$("CCYY/MM/DD")<rst_expired$(rst) then goto RST_XIT
11656   let fnrst$=rst_expired$(rst) !:
        goto RST_XIT
11658 RST_XIT: ! 
11660   if state$="NY" and rst_zip$<>"" and srch(mat rst$,"BA")>0 then 
11662     if autozip_handle=0 then let autozip_handle=fngethandle_
11664     let fnzip_$(rst_zip$,autozip_handle,mat rst_zip_result$)
11666     let rst_zip_county$=uprc$(trim$(rst_zip_result$(zip_county:=6)))
11668     if rst_zip_county$="NEW YORK" or rst_zip_county$="BRONX" or rst_zip_county$="QUEENS" or rst_zip_county$="RICHMOND" or rst_zip_county$="KINGS" then let fnrst$="RESTRICTED!"
11670   end if 
11680 fnend 
11690 L11690: form pos 1,4*c 8,c 20,2*bh 2
11700 ! ---------LIBRARY----------FNGET_RECENT()----------------------------------
11702 dim twhoami$*20,debt$*40,cred$*40
11704 def library fnget_recent(grcnt_whoami$*20,mat recent_files$,mat recent_menu$,mast_handle,track_handle;init$) ! grcnt_
11706   if mast_handle=0 then let mast_handle=fngethandle_
11708   if lrec(mast_handle)>=0 then let mast_open=1 else !:
          open #mast_handle: "NAME=MASTER//6,KFNAME=MASTERX//6,SHR",internal,outin,keyed 
11710   if trim$(init$)="" then let init$="XXXX"
11712   open #(recent_handle:=fngethandle_): "NAME=TRACK.USR//8,SHR",internal,input,relative 
11714   let recent_files=0: let tscan=0
11716   if trim$(file$(recent_handle))="" then !:
          goto L11732
11718   read #recent_handle,using L11690,last,release: fileno$,late$,stime$,etime$,twhoami$,ttrack,trerite ioerr L11732 !:
        let quit_time$=time$
11720 L11720: if (trim$(twhoami$)<>trim$(grcnt_whoami$) and trim$(twhoami$)(1:4)<>rpad$(trim$(init$),4) ) or srch(mat recent_files$,"FILE:"&fileno$)>0 then !:
          goto L11728
11722   read #mast_handle,using L11724,key=fileno$,release: debt$,cred$ nokey L11728
11724 L11724: form pos 63,c 30,pos 174,c 40
11726   let recent_files+=1 !:
        mat recent_files$(recent_files): mat recent_menu$(recent_files) !:
        let recent_files$(recent_files)="FILE:"&fileno$ !:
        let recent_menu$(recent_files)="Re: "&srep$(fileno$,"&","&&")&" - "&cred$&chr$(9)&" Vs. "&debt$
11728 L11728: read #recent_handle,using L11690,prior,release: fileno$,late$,stime$,etime$,twhoami$,ttrack,trerite ioerr L11732
11730   let tscan+=1 !:
        if tscan<=9999 and recent_files<10 and quit_time$=time$ then goto L11720
11732 L11732: close #recent_handle: ioerr L11734
11734 L11734: let recent_handle=0 !:
        if mast_open=0 then !:
          close #mast_handle: 
11736   let fnget_recent=recent_files !:
      fnend 
11740 ! ---------LIBRARY---------FNAMPM$(MILTIME$)---------------------------
11742 def fnampm_$(miltime$)
11744   if pos(uprc$(miltime$), "AM") > 0 or pos(uprc$(miltime$), "PM") > 0 then goto L11758
11746   let _hour$=miltime$(1:2) !:
        let _min$=miltime$(4:5) !:
        let _sec$=miltime$(7:8)
11748   let _hour=val(_hour$) conv L11758 !:
        let _min=val(_min$) conv L11758 !:
        let _sec=val(_sec$) conv L11758
11750   if _hour < 12 then !:
          let _ampm$ = "AM" !:
        else !:
          let _hour -= 12 !:
          let _ampm$ = "PM"
11752   if _hour = 0 then let _hour = 12
11754   let _hour$=lpad$(str$(_hour), 2, "0")
11756   if len(_sec$) = 0 then !:
          let fnampm_$=_hour$&":"&_min$&" "&_ampm$ !:
        else !:
          let fnampm_$=_hour$&":"&_min$&":"&_sec$&" "&_ampm$
11758 L11758: fnend 
11760 def library fnampm$(miltime$)
11762   let fnampm$=fnampm_$(miltime$)
11764 fnend 
11770 ! ---------LIBRARY---------FNSTIME()-----------------------------------
11772 def fnstime_(_stime$)
11774   if len(_stime$)<>8 then let _stime$=fntime_parse$(_stime$)
11776   let _shh=_smm=_sss=0 !:
        let _stime$=srep$(_stime$,":","") !:
        let _shh=val(_stime$(1:2)) conv L11778 !:
        let _smm=val(_stime$(3:4)) conv L11778 !:
        let _sss=val(_stime$(5:6)) conv L11778
11778 L11778: let fnstime_=(_shh*3600+_smm*60+_sss)*100
11779 fnend 
11780 def library fnstime(_stime$)
11782   if last_stime$=_stime$ then !:
          let fnstime=last_stime else !:
          let last_stime$=_stime$ !:
          let fnstime=last_stime=fnstime_(_stime$)
11784 fnend 
11790 ! ---------LIBRARY----------FNSTIME$()----------------------------------
11792 def fnstime_$(_stime)
11794   let _stime=abs(_stime/100)
11796   let _shh=int(_stime/3600) : let _stime-=(_shh*3600) !:
        let _smm=int(_stime/60): let _stime-=(_smm*60) !:
        let _sss=_stime
11798   if _shh<=99 then !:
          let fnstime_$=cnvrt$('PIC(##:##:##)',_shh*10000+_smm*100+_sss) else !:
          let fnstime_$=str$(_shh)&":"&cnvrt$('PIC(##:##)',_smm*100+_sss)
11799 fnend 
11800 def library fnstime$(_stime)
11802   if last_stime=_stime then !:
          let fnstime$=last_stime$ else !:
          let last_stime=_stime !:
          let fnstime$=last_stime$=fnstime_$(_stime)
11804 fnend 
12810 def fntime_parse$(_stime$)
12812 ! The Function parses out unwanted chars from the time like AM !:
        ! Formats time ##:##:##
12814   let pm_time=0 !:
        let _stime$=srep$(uprc$(_stime$),"AM","")
12816   if pos(uprc$(_stime$),"PM")>0 then !:
          let _stime$=srep$(uprc$(_stime$),"PM","") !:
          let pm_time=1
12818   let _stime$=trim$(_stime$) !:
        let _phh=_pmm=_pss=0 !:
        let pos_hh=pos_mm=0
12820   let pos_hh=pos(_stime$,":") !:
        let pos_mm=pos(_stime$,":",pos_hh+1)
12822   let _phour$=(_stime$(1:pos_hh-1)) !:
        let _phour=val(phour$) conv ignore !:
        if pm_time and _phour<>12 then !:
          let _phour=12+_phour !:
          let _phour$=str$(_phour) else !:
          if pm_time=0 and _phour=12 then !:
            let _phour=0 !:
            let _phour$=str$(_phour)
12824   if len(_phour$)<2 then let _phour$=lpad$(_phour$,2)
12826   let _pmin$=(_stime$(pos_hh+1:pos_mm-1)) !:
        if len(_pmin$)<2 then let _pmin$=lpad$(_pmin$,2)
12828   let _psec$=(_stime$(pos_mm+1:pos_mm+2)) !:
        if len(_psec$)<2 then let _psec$=lpad$(_psec$,2)
12830   let fntime_parse$=_phour$&":"&_pmin$&":"&_psec$
12832 fnend 
12840 ! ---------LIBRARY----------FNSTATUS_FILE()
12842 def library fnstatus_file(mat name_file$,mat kfname_file$,mat use_file$)
12844   dim buff_status_file$*999
12846   let fnstatus_file=fnstatusfile(mat name_file$,mat kfname_file$,mat use_file$)
12848 fnend 
12850 def fnstatusfile(mat name_file$,mat kfname_file$,mat use_file$)
12852   let max_files=0
12854 L12854: execute "*STATUS FILE >[Temp]ST-[Session].txt"
12856   let nworkfile=fngethandle_ !:
        open #nworkfile: "NAME=[Temp]ST-[Session].txt",display,input error L12858 !:
        goto L12862
12858 L12858: if ~exists("[Temp]ST-[Session].txt") then !:
          let msg$("[Temp]ST-[Session].txt") !:
          print fields "24,80,C 1": "*": !:
          print bell; !:
          let sleep(.1) !:
          print fields "24,80,C 1": "" !:
          goto L12854
12860   print bell; !:
        print "Error;";err;" ";line !:
        let msg$("Error:"&str$(err)&" Line:"&str$(line)) !:
        print "Skipping Status File" !:
        let sleep(1) !:
        goto L12898
12862 L12862: linput #nworkfile: buff_status_file$ eof L12896 !:
        let buff_status_file$=uprc$(buff_status_file$)
12864   if pos(buff_status_file$,"OPEN FILE #")<=0 then goto L12862
12866   let file_handle=val(buff_status_file$(12:16)) !:
        if file_handle=nworkfile then !:
          goto L12862 else !:
          if file_handle=0 then goto L12862 !:
          else if file_handle>udim(name_file$) then !:
            mat name_file$(file_handle): mat kfname_file$(file_handle): mat use_file$(file_handle)
12868 if udim(name_file$)<file_handle then !:
        mat name_file$(file_handle) !:
        mat kfname_file$(file_handle) !:
        mat use_file$(file_handle)
12870 let name_file$(file_handle)=trim$(buff_status_file$(17:999))
12872 if file_handle>max_files then let max_files=file_handle
12874 let nslash=pos(name_file$(file_handle),"\",-1) !:
      let use_file$(file_handle)=uprc$("NAME="&name_file$(file_handle)(1:2)&name_file$(file_handle)(nslash+1:999))
12876 linput #nworkfile: buff_status_file$ !:
      let buff_status_file$=uprc$(buff_status_file$) !:
      if trim$(buff_status_file$)="" then goto L12862
12878 L12878: linput #nworkfile: buff_status_file$ !:
      let buff_status_file$=uprc$(buff_status_file$)
12880 if trim$(buff_status_file$)="" then goto L12862
12882 if pos(uprc$(buff_status_file$),"KEY FILE")<=0 then goto L12878
12884 let kfname_file$(file_handle)=trim$(buff_status_file$(19:999))
12886 let nslash=pos(kfname_file$(file_handle),"\",-1) !:
      let use_file$(file_handle)(9999:0)=uprc$(",KFNAME="&kfname_file$(file_handle)(1:2)&kfname_file$(file_handle)(nslash+1:999))
12888 ! if UPRC$(KFNAME_FILE$(FILE_HANDLE))<>KFNAME_FILE$(FILE_HANDLE) THEN PRINT "Warning: Problem with Index file Case!" !:
      ! PAUSE
12890 L12890: linput #nworkfile: buff_status_file$ !:
      let buff_status_file$=uprc$(buff_status_file$)
12892 if trim$(buff_status_file$)<>"" then goto L12890
12894 goto L12862
12896 L12896: close #nworkfile: 
12898 L12898: fnend 
12900 def fnwbmaps(mat wbdrives$,mat truedrives$,mat paths$)
12901   dim wb_real$*15,wb_drive$*80,wb_name$*80,wb_path$*80
12902   let wbdrives=0 !:
        mat wbdrives$(1)=("") !:
        mat truedrives$(1)=("") !:
        mat paths$(1)=("")
12904   execute "*STATUS FILE >[Temp]ST-[Session].txt"
12906   let nworkfile=fngethandle_ !:
        open #nworkfile: "NAME=[Temp]ST-[Session].txt",display,input 
12908 L12908: linput #nworkfile: buff$ eof L12926
12909   if buff$(1:5)<>"-----" then goto L12908
12910   let nparse_real1=1 !:
        let nspace=pos(buff$," ") !:
        let nparse_real2=nspace-1 !:
        let nparse_drive1=nparse_real2+2 !:
        let nspace=pos(buff$," ",nspace+1) !:
        let nparse_drive2=nspace-1 !:
        let nparse_name1=nparse_drive2+2 !:
        let nspace=pos(buff$," ",nspace+1) !:
        let nparse_name2=nspace-1
12911   let nparse_path1=nparse_name2+2 !:
        let nspace=pos(buff$," ",nspace+1) !:
        let nparse_path2=999
12914 L12914: linput #nworkfile: buff$ eof L12926
12915   if trim$(buff$)="" then goto L12924
12916   let wb_real$=trim$(buff$(nparse_real1:nparse_real2)) !:
        let wb_drive$=trim$(buff$(nparse_drive1:nparse_drive2)) !:
        let wb_name$=trim$(buff$(nparse_name1:nparse_name2)) !:
        let wb_path$=trim$(buff$(nparse_path1:nparse_path2))
12918   let wbdrives+=1 !:
        mat wbdrives$(wbdrives) !:
        mat truedrives$(wbdrives) !:
        mat paths$(wbdrives)
12920   let wbdrives$(wbdrives)=uprc$(wb_real$) !:
        let truedrives$(wbdrives)=uprc$(wb_drive$) !:
        let paths$(wbdrives)=uprc$(wb_path$)
12922   goto L12914
12924 L12924: ! 
12926 L12926: close #nworkfile: 
12929 fnend 
12930 def fntruepath_$*256(filewb_name$*256)
12931   dim wbdrives$(1)*80,truedrives$(1)*80,paths$(1)*80,new_wb_drive$*80
12932   let filewb_name$=uprc$(trim$(filewb_name$))
12933   let fnwbmaps(mat wbdrives$,mat truedrives$,mat paths$)
12934   let orig_wb_drive$=new_wb_drive$=filewb_name$(1:2) !:
        if orig_wb_drive$(2:2)<>":" then goto END_TRANS
12936   let tx=srch(mat wbdrives$,orig_wb_drive$) !:
        if tx>0 then let new_wb_drive$=truedrives$(tx) else goto DRIVE_ONLY
12937   if filewb_name$(1:2)="\\" then goto L12940 !:
          ! UNC DRIVE! !:
          ! ?? What about Drive only requests?
12938   if filewb_name$(3:3)="\" then goto DRIVE_ONLY
12940 L12940: let filewb_name$(3:2)=srep$(paths$(tx)&"\","\\","\")
12942 DRIVE_ONLY: ! 
12944   let filewb_name$(1:2)=new_wb_drive$
12946 END_TRANS: ! 
12947   let filewb_name$(2:999)=srep$(filewb_name$(2:999),"\\","\")
12948   let fntruepath_$=filewb_name$
12950 fnend 
12951 def library fnbr_filename$*256(bf_file$*256)
12952   let fnbr_filename$=fn_br_filename$(bf_file$)
12953 fnend 
12954 def fn_br_filename$*256(bf_file$*256)
12955   if ~exists(bf_file$) then 
12956     let bf_file$=fnwbpath_$(srep$(bf_file$,"@::",""))
12957     if uprc$(env$("CLIENT_SERVER"))="YES" then let bf_file$=fn_client_path$(bf_file$)
12958   end if 
12959   let fn_br_filename$=bf_file$
12960 fnend 
12961 def fnwbpath_$*256(filewb_name$*256)
12962   let filewb_name$=uprc$(trim$(filewb_name$))
12963   let fnwbmaps(mat wbdrives$,mat truedrives$,mat paths$)
12964   for ntest=udim(truedrives$) to 1 step -1
12966     let tx=len(truedrives$(ntest)(1:2)&paths$(ntest)&"\") !:
          if filewb_name$(1:tx)=truedrives$(ntest)(1:2)&paths$(ntest)&"\" then !:
            let filewb_name$(1:tx)=wbdrives$(ntest)
12968   next ntest
12970   let fnwbpath_$=filewb_name$
12972 fnend 
12980 def library fntrue_wb_path$*256(filewb_name$*256)
12981   let fntrue_wb_path$=fntruepath_$(filewb_name$)
12988 fnend 
12990 def library fnwb_wb_path$*256(filewb_name$*256)
12991   let fnwb_wb_path$=fnwbpath_$(filewb_name$)
12998 fnend 
13000 ! ---------LIBRARY----------FNGET_FILE()--------------------------------
13002 def library fnget_file(file_name$*256;input$)
13004   gosub SETUP_CONSTANTS
13006   let fnget_file=fngetfile(file_name$,input$)
13008 fnend 
13010 ! ---------LIBRARY----------FNGET_DISPLAY()-----------------------------
13012 def library fnget_display(file_name$*256)
13014   let fnget_display=fngetdisplay_(file_name$)
13016 fnend 
13020 def library fnget_ext$(file_name$*256)
13022   if date("MM")<10 then !:
          let fnget_ext$=trim$(file_name$)&"."&date$("MMDD")(2:4) else !:
          if date("MM")=10 then !:
            let fnget_ext$=trim$(file_name$)&".O"&date$("DD") else !:
            if date("MM")=11 then !:
              let fnget_ext$=trim$(file_name$)&".N"&date$("DD") else !:
              if date("MM")=12 then !:
                let fnget_ext$=trim$(file_name$)&".D"&date$("DD")
13024 fnend 
13030 def library fnsql_int_stamp(active_handle,finan_handle, stamp_comment$*30,stamp_amount,stamp_code$,mat stamp_line1,mat stamp_line2,mat stamp_line3, mat master_data$,mat master_data; stamp_refno,stamp_numdat,stamp_int_override)
13032   let fnsql_int_stamp=fnsql_intstamp(active_handle,finan_handle, stamp_comment$,stamp_amount,stamp_code$,mat stamp_line1,mat stamp_line2,mat stamp_line3, mat master_data$,mat master_data, stamp_refno,stamp_numdat,stamp_int_override)
13034 fnend  ! fnSQL_Int_Stamp
13040 def fnsql_intstamp(active_handle,finan_handle, stamp_comment$*30,stamp_amount,stamp_code$,mat stamp_line1,mat stamp_line2,mat stamp_line3, mat master_data$,mat master_data; stamp_refno,stamp_numdat,stamp_int_override)
13042   if ~setup_fnsql_intstamp then 
13044     if ~cls_setup then let fnclssetup
13046     if ~setup_sql then gosub SETUP_SQL
13048     if ~user_setup then let fnget_user ! gets User
13050     if ~master_common then let fnmaster_common
13052     let setup_fnsql_intstamp=1
13054   end if  ! ~Setup_fnSQL_IntStamp
13056   if stamp_numdat<=0 then !:
          let stamp_numdat=fndate10_(master_data$(master_idate))
13058   let bpj$=fn_bpj$(master_data$(master_suit_date),master_data$(master_jmt_date))
13060   if stamp_int_override<=0 then !:
          let stamp_int=master_data(master_stored_int) !:
        else !:
          let stamp_int=stamp_int_override
13062   let stamp_contract=master_data(master_contract_fee)
13064   let stamp_stat_due=master_data(master_stat_fee)-master_data(master_stat_earn)
13066   let stamp_costs_due=master_data(master_cost_exp)-master_data(master_cost_recovered)
13068   let fnsql2_master ! gets: ThruDat$, FileNo$, JDate$, IDate$, mat FileRec, mat FRec, mat Rates, Stored_Int, mat Rates, Venue, Sher, Forw, MasCo, Atty, Para, Collector, Sales, Amt6   ! from mat Master_Data$ and mat Master_Data
13070   let fnintstamp(active_handle,finan_handle,master_data$(master_fileno),stamp_comment$,stamp_amount,stamp_code$,bpj$,stamp_type$="S",user,stamp_int,stamp_contract,stamp_stat_due,stamp_costs_due,mat filerec,mat frec,mat stamp_line1,mat stamp_line2,mat stamp_line3, stamp_refno,stamp_numdat)
13072 fnend  ! fnSQL_IntStamp
13080 def library fnin_list_txt(il_file$*256,il_search_for$*70)
13082   let fnin_list_txt=fninlist_txt(il_file$,il_search_for$)
13084 fnend  ! fnIn_List_Txt
13090 def fninlist_txt(il_file$*256,il_search_for$*70)
13092 ! FN only deals with string values
13094 ! if ITEM is found in the file, return 1, else 0
13096 ! FileName should evaluate comma-delimited, tab-delimited or CRLF-delimited data.
13098   let case_insensitive=1 ! we just didn't need this option.
13100   dim il_file_cache$*256,il_line_1$(1)*512,il_field$(1)*70,il_value$(1)*70
13102   if case_insensitive=1 then let il_search_for$=uprc$(il_search_for$)
13104   if pos(il_file$,"\")<=0 and pos(il_file$,"/")<=0 then let il_file$(0:0)='Custom\'
13106   if il_file$<>il_file_cache$ or case_insensitive_cache<>case_insensitive then 
13108     let fnasci_(il_file$,mat il_line_1$)
13110     mat il_value$(0)
13112     for _il_line_1=1 to udim(mat il_line_1$)
13114       if pos(il_line_1$(_il_line_1),chr$(9))>0 then let il_csv_delimiter$=chr$(9) else let il_csv_delimiter$=''
13116       if case_insensitive=1 then let il_line_1$(_il_line_1)=uprc$(il_line_1$(_il_line_1))
13118       let fnparse_csv_(il_line_1$(_il_line_1),mat il_field$,il_csv_delimiter$)
13120       let fn_array_add$(mat il_value$,mat il_value$,mat il_field$)
13122     next _il_line_1
13124     let il_file_cache$=il_file$
13126     let case_insensitive_cache=case_insensitive
13128   end if  ! IL_File$<>IL_File_Cache$
13130   let il_search=srch(mat il_value$,il_search_for$)
13132   if il_search>0 then let set_fninlist=1 else let set_fninlist=0
13134   let fninlist_txt=set_fninlist
13136 fnend  ! FNINLIST_TXT
13140 ! --------------------------FNGETFILE()---------------------------------
13142 def fngetfile(file_name$*256;outin$*80)
13144   let next_file_handle=800 !:
        let retry_count=0
13146   let file_name$=uprc$(file_name$) !:
        if pos(uprc$(file_name$),"NAME=")=0 then !:
          let file_name$="NAME="&file_name$&",SHR"
13148 L13148: let next_file_handle-=1 !:
        if trim$(file$(next_file_handle))<>"" then goto L13148
13150   if trim$(uprc$(outin$))<>"INPUT" then 
13152     if pos(uprc$(file_name$),"KFNAME")>0 then !:
            open #next_file_handle: file_name$,internal,outin,keyed ioerr L13162 else !:
            open #next_file_handle: file_name$,internal,outin,relative ioerr L13162
13154   else 
13156     if pos(uprc$(file_name$),"KFNAME")>0 then !:
            open #next_file_handle: file_name$,internal,input,keyed ioerr L13162 else !:
            open #next_file_handle: file_name$,internal,input,relative ioerr L13162
13158   end if 
13160   goto L13168
13162 L13162: let e1=err: let l1=line !:
        if (e1=4144 or e1=4206 or e1=4205 or e1=4204 or e1=4146 or e1=4148 or e1=4122) and retry_count<10 then !:
          let retry_count+=1 !:
          print fields "24,80,C 1,[S]": "*": print bell; !:
          let sleep(1) !:
          print fields "24,80,C 1,[W]": "" !:
          retry 
13164   let next_file_handle=-err !:
        if err=4175 then print "Multiple WBServer.dat files encountered!" : print "Error: "&str$(err) : print " Line: "&str$(line) !:
          let msg$("ERR:"&str$(err)&" LINE:"&str$(line))
13166   if err=608 then !:
          let fnmessagebox_("Warning This program has a problem\n"&file_name$&"Is already opened as 'Read Only'\n\nCalling program must open "&file_name$&" as OUTIN before opening as INPUT",64,"File Read Only") !:
        else if err=4146 then !:
          let fnmessagebox_("Warning Error:"&tab$&str$(err)&"\nLine:"&tab$&str$(line)&"\nProgram:"&tab$&program$&"\nSysErr:"&tab$&str$(syserr)&"\nSysErr Text:"&tab$&syserr$&"\nFile Name:"&tab$&file_name$,mb_exclamation+mb_okonly,"Open Time Out")
13168 L13168: let fngetfile=next_file_handle
13169 fnend 
13170 def fngethandle_
13172   let next_file_handle=1000
13174   do while rln(next_file_handle-=1)>0
13176   loop 
13178   if next_file_handle<=299 then let fnmessagebox_('The fngethandle function is has run out of valid handles and is about to return an invalid handle of '&str$(next_file_handle)&'.  Too many files are open.  Please leave this message up and contact CLS technical support.',(mb_exclamation:=48)+(mb_okonly:=0),"CLS Developer Warning")
13180   let fngethandle_=next_file_handle
13182 fnend 
13190 def library fngethandle
13192   let fngethandle=fngethandle_
13194 fnend 
13200 ! --------------------------FNGETDISPLAY()------------------------------
13202 def fngetdisplay_(file_name$*256;type$*50,new_use_replace$*50,shr$*50)
13204   let next_file_handle=200 !:
        if trim$(file_name$)="" and uprc$(env$("Developer"))="YES" then print "WARNING, BLANK FILE NAME PASSED" : pause else !:
          if trim$(file_name$)="" then print "WARNING, BLANK FILE NAME PASSED"
13206   if pos(uprc$(file_name$),"NAME=")=0 then !:
          let file_name$="NAME="&file_name$
13208   if trim$(new_use_replace$)<>"" then !:
          let file_name$=file_name$&","&new_use_replace$
13210   if trim$(shr$)<>"" then !:
          let file_name$=file_name$&","&shr$ else !:
          let file_name$=file_name$&",SHR"
13212 L13212: let next_file_handle-=1 !:
        if trim$(file$(next_file_handle))<>"" then goto L13212
13214 ! PAUSE
13216   if type$="" or type$="INPUT" then !:
          open #next_file_handle: file_name$,display,input ioerr L13220 else !:
          open #next_file_handle: file_name$&",recl=1000",display,output ioerr L13220
13218   goto L13222
13220 L13220: let next_file_handle=0
13222 L13222: let fngetdisplay_=next_file_handle
13224 fnend 
13230 ! -------LIBRARY------------FNGETDISPLAY()------------------------------
13232 def library fngetdisplay(file_name$*256;type$*50,new_use_replace$*50,shr$*50)
13234   let fngetdisplay=fngetdisplay_(file_name$,type$,new_use_replace$,shr$)
13236 fnend 
13240 OPEN_CLSSETUP: ! r: Open CLSSETUP File
13242 let cls_setup=-1 !:
      let clssetup=fngetfile("CLSSETUP//8","Input")
13244 if clssetup<=0 then let fnguipush !:
        let scr_thaw: execute "status locks" !:
        let fnmessagebox_("Someone is Setting Up System :"&str$(err)&chr$(10)&"\nFile:"&br_filename$("CLSSETUP//8")&"\nPlease Try Again",16,"Setup in Use") !:
        let fnguipop !:
        print newpage !:
        goto OPEN_CLSSETUP
13246 if rln(clssetup)<1024 then 
13248   close #clssetup: 
13250   if exists("CLSSETUP.53//8") then !:
          execute "FREE CLSSETUP.53//8"
13252   execute "RENAME CLSSETUP//8 CLSSETUP.53//8" !:
        execute "COPY CLSSETUP.53//8 CLSSETUP//8 -1024"
13254   goto OPEN_CLSSETUP
13256 end if  ! RLN(CLSSETUP)<1024
13258 return ! /r
13260 ! --------------------------FNCLSSETUP()--------------------------------
13262 def fnclssetup
13264   dim base_year$*4,date_8$(3)*8,date_10$(3)*10,o_rates(2),attyfee(7,4),report_path$*128,startup_hash$*80
13266   dim vb_dbf$*80,vb_vbtools$*80,vb_vbdir$*80,nan_dir$*60,bk_defaults$(5)*48,wcm$*80
13268   dim month$(12)*9,monthu$(12)*9,salut$(11)*20,mth$(12)
13270   dim epr$*1,pd$(8)*3,vlp$(5)*3,psc$(5)*3,rop$(5)*3
13280   let fn_setup
13282   let startup_hash$=hex$(env$("STARTUP_HASH")) error L13286
13284   if str$(serial)&session$&env$("CLS_STARTUP")=startup_hash$ then goto L13290
13286 L13286: let msgbox("Security breach, improper launch of Collection-Master"&chr$(10)&"Please make sure your icon has the following startup command:"&chr$(10)&"F:\CLSINC\WBWIN\WB32.EXE -%WSID% RUN STARTUP/WBWIN","Invalid Startup","OK","ERR") !:
        execute "system"
13290 L13290: gosub OPEN_CLSSETUP
13300   read #clssetup,using L13302,rec=1,release: o_date$,mat o_rates,o_comm$,o_sfee$,o_atty$,o_secy$,o_coll$,mat attyfee,oi_prin$,oi_stat$,oi_costs$,oi_prin,oi_stat,oi_costs,oj_suit$,oj_contract$,oj_stat$,oj_prejint$,oj_costs$,oj_suit,oj_contract,oj_stat,oj_prejint,oj_costs,recalc_attyfee$,o_postdate,o_collord$,o_movedebt$,o_diary$,max_activ,o_movedebt1$,o_movedebt2$,jnum_req$,court_int$,court_fee$,start_index$,idx_chain$,histidx_chain$,collhold$,o_movedebt3$,o_movedebt4$,o_movedebt5$,o_attyfee$,oij_stat$,oij_costs$,oij_stat,oij_costs,lsize,tsize,csize,clla_account$,odcode$,o_dspan$,conquit$,o_fcount$,o_cred_int$,show_dp$,show_coll$,baby_paper$,modify_paper,del_diary$
13302 L13302: form pos 1,c 1,2*pd 6.2,2*c 4,3*c 2,28*pd 6.2,3*c 1,3*n 1,5*c 1,5*n 1,c 1,pos 213,pd 3,pos 513,c 10,pos 221,c 1,c 1,b 2,2*c 1,c 1,c 1,c 1,c 8,2*c 18,c 1,3*c 1,c 1,2*c 1,pos 281,2*pd 6.2,pos 293,3*b 1,c 8,c 8,c 5,pos 317,c 8,c 1,pos 326,c 1,2*c 1,c 1,bh 2,pos 332,c 1
13304   reread #clssetup,using 'form pos 333,4*C 10,POS 382,C 2,POS 384,C 16',release: min_new$,min_paper$,min_master$,min_acc$,hs$,hstate$ !:
        read #clssetup,using L13306,rec=6,release: vb_dbf$,vb_vbtools$,vb_vbdir$,mat bk_defaults$,nan_atty_id$,nan_dir$,dz_atty_id$,bk_market$ !:
        read #clssetup,using "FORM POS 89,5*V 18",rec=7,release: port$,local_areacode$,long_code$,prefix$,suffix$ ioerr L13306 !:
        let x1=pos(port$,"%") !:
        let x2=pos(port$,"%",x1+1) !:
        if x1>=1 and x2>=1 then !:
          let port$=trim$(port$(1:x1-1)&env$(port$(x1+1:x2-1))&port$(x2+1:999))
13306 L13306: form pos 1,3*v 80,c 3,c 2,c 48,c 1,pos 355,c 1,pos 295,c 10,c 40,c 10,pos 356,c 1
13310   read #clssetup,using L13312,rec=5,release: mat salut$ !:
        for salut=1 to udim(salut$) !:
          let salut$(salut)=trim$(salut$(salut)) !:
        next salut
13312 L13312: form pos 1,11*c 18
13314   let totclaim=10 : read #clssetup,using L13318,rec=2,release: lval1,lval2,storeh$,storech$ norec L13318,ioerr L13318
13316   let work=val(unhex$(storeh$(1:lval2))) conv L13318: let work1=val(unhex$(storech$(1:lval1))) conv L13318 !:
        if (work-1e+12+serial)<>(work1-(serial*65321)) then !:
          let work=work1=(serial*65321)+10
13318 L13318: form pos 1,2*b 1,2*c 16
13320   read #clssetup,using L13322,rec=9,release: base_year$,mat date_8$,mat date_10$ norec L13330
13322 L13322: form pos 1,c 4,3*c 8,3*c 10
13324   if trim$(base_year$)="" or trim$(date_8$(1))="" or trim$(date_8$(2))="" or trim$(date_8$(3))="" then goto L13330
13326   if trim$(date_10$(1))="" or trim$(date_10$(2))="" or trim$(date_10$(3))="" then goto L13330
13328   goto L13342
13330 L13330: let fnmessagebox_("Y2K parameters are not Set properly in CM Setup, Program will use defaults, Please run [1-S-4-8] to fix problem",16,"Check Y2K Parameters")
13340   let base_year$="1900" !:
        let date_8$(1)="MM/DD/YY" !:
        let date_8$(2)="MMDDCCYY" !:
        let date_8$(3)="MM/DD/YY" !:
        let date_10$(1)="MM/DD/CCYY" !:
        let date_10$(2)="MM/DD/CCYY" !:
        let date_10$(3)="MM/DD/CCYY"
13342 L13342: let month$(1)="January" !:
        let month$(2)="February" !:
        let month$(3)="March" !:
        let month$(4)="April" !:
        let month$(5)="May"
13344   let month$(6)="June" !:
        let month$(7)="July" !:
        let month$(8)="August" !:
        let month$(9)="September" !:
        let month$(10)="October" !:
        let month$(11)="November" !:
        let month$(12)="December"
13346   let mth$(1) = "JAN" !:
        let mth$(2) = "FEB" !:
        let mth$(3) = "MAR" !:
        let mth$(4) = "APR" !:
        let mth$(5) = "MAY" !:
        let mth$(6) = "JUN"
13348   let mth$(7) = "JUL" !:
        let mth$(8) = "AUG" !:
        let mth$(9) = "SEP" !:
        let mth$(10) = "OCT" !:
        let mth$(11) = "NOV" !:
        let mth$(12) = "DEC"
13350   for _month=1 to 12 !:
          let monthu$(_month)=uprc$(month$(_month)) !:
        next _month
13352   let tab$=chr$(9)
13360   read #clssetup,using " FORM POS 1,C 45,C 8,5*C 3,C 1",rec=11,release: form_dir$,wptype$,mat doc_ext$,merge_pool$ norec L13362 !:
        read #clssetup,using "FORM POS 1,28*C 2,28*C 10",rec=13,release: mat rst$,mat rst_expired$ norec L13362
13362 L13362: if srch(mat doc_ext$,"DOC")>0 and trim$(doc_ext$(2))="" then !:
          let doc_ext$(2)="DOCX" else !:
          if srch(mat doc_ext$,"DOC")>0 and trim$(doc_ext$(5))="" then !:
            let doc_ext$(5)="DOCX" else !:
            if srch(mat doc_ext$,"DOC")>0 then !:
              mat doc_ext$(6) : let doc_ext$(6)="DOCX"
13364 L13364: let udim_doc_ext=udim(doc_ext$) !:
        let _doc_ext=srch(mat doc_ext$,"   ") !:
        if _doc_ext<>udim_doc_ext and doc_ext$(udim_doc_ext)="   " then !:
          mat doc_ext$(udim_doc_ext-1) !:
          goto L13364
13366   let udim_doc_ext=udim(doc_ext$)
13370   open #version_handle:=fngethandle_: "NAME=VERSION//8,SHR",display,input ioerr L13376
13372   linput #version_handle: wcm$ ioerr L13374 !:
        let wcm$=uprc$(wcm$)
13374 L13374: close #version_handle: 
13376 L13376: let totclaim=(work1-(serial*65321))*-1 !:
        if totclaim=99999 then let totclaim=inf
13378   read #clssetup,using L13380,rec=7: epr$,prd,mat pd$,mat vlp$,mat psc$,mat rop$,past_due,win_widgets$,win_pop$
13380 L13380: form pos 1,v 1,bh 2,8*v 3,3*(5*v 3),pos 179,bh 2,pos 324,c 3,pos 328,c 3
13382   let fnget_int("INTRATES.INI",mat int_nj1$,mat int_date_nj1$,mat int_rate_nj1)
13384   let fnget_int("DJ_RATES.INI",mat int_nj2$,mat int_date_nj2$,mat int_rate_nj2)
13386   let fnsetup_o_rates(mat o_rates_states$,mat o_rates_pre,mat o_rates_post)
13388   open #equifax_setup:=fngethandle_: "NAME=SETUP.EFX/EQUIFAX,SHR",internal,input,relative ioerr L13395 !:
        ! ** For Minimum security purposes, we want this INPUT!
13389   read #equifax_setup,using L13390,rec=1,release: report_path$ norec L13391 !:
        let report_path$=trim$(report_path$)
13390 L13390: form pos 1,x 120,c 40
13391 L13391: close #equifax_setup: 
13395 L13395: if report_path$="" then let report_path$="F:\REPORTS\"
13396   if report_path$(len(report_path$):len(report_path$))<>"\" then !:
          let report_path$(9999:0)="\"
13397   let spin$="-\|/" !:
        let spinner_attribute$="[W]" !:
        let gui_spin$="" !:
        for _spinner=ord(hex$("87")) to ord(hex$("92")) !:
          let gui_spin$(99:0)=chr$(_spinner) !:
        next _spinner !:
        let gui_spinner_attribute$="[W_Wingdings2]"
13398   read #clssetup, using L13399,rec=12: tz_zip$ ioerr L13399
13399 L13399: form pos 401,c 5
13400   dim i_category(6),i_description$(6)*80,i_before(6),i_post(6),i_judgment(6),i_charges(6),i_credits(6),i_balance(6),i_base(6),i_bpj(6),ri_collord$*20,ri_clerkf_state$*30,ri_clerkf_csz$*30
13401   let i_1100=1 !:
        let i_3100=2 !:
        let i_4100=3 !:
        let i_5100=4 !:
        let i_6100=5 !:
        let i_9100=6 !:
        ! Interest Buckets are "Hard Coded", but use I_ variables for reference.
13402   let i_category(i_1100)=1100 !:
        let i_category(i_3100)=3100 !:
        let i_category(i_4100)=4100 !:
        let i_category(i_5100)=5100 !:
        let i_category(i_6100)=6100 !:
        let i_category(i_9100)=9100
13403   let i_description$(i_1100)="Principal (P)" !:
        let i_description$(i_3100)="Contract Attorney Fees (O)" !:
        let i_description$(i_4100)="Recoverable Costs (C)" !:
        let i_description$(i_5100)="Firm Costs/Charges (F)" !:
        let i_description$(i_6100)="Statutory Attorney Fees (S/L)" !:
        let i_description$(i_9100)="Other (V)"
13404   read #clssetup,using L13405,rec=16: mat i_before,mat i_post,mat i_judgment ioerr L13405
13405 L13405: form pos 61,3*(6*n 1,x 14)
13408   close #clssetup: 
13410   let cls_setup=1
13412 fnend 
13420 def fnget_int(filename$*80,mat int_table$,mat int_date$,mat int_rate)
13422   mat int_table$=("") !:
        mat int_date$=("") !:
        mat int_rate=(0) !:
        if exists(trim$(filename$)&"/CUSTOM") then !:
          let fnasci_(trim$(filename$)&"/CUSTOM",mat int_table$) else !:
          let 14199
13424   mat int_date$(udim(int_table$))=("") !:
        mat int_rate(udim(int_table$))=(0)
13426   for nint=1 to udim(int_table$)
13428     let xpos=pos(int_table$(nint),chr$(9)) !:
          let int_date$(nint)=fndate10_$(int_table$(nint)(1:xpos-1)) !:
          let int_rate(nint)=val(int_table$(nint)(xpos+1:99)) conv L13430
13430 L13430: next nint
13432 fnend 
13440 def fn_setup_diary
13442   if ~setup_diary then 
13443     let setup_diary=1
13444     if ~setup_library then gosub SETUP_LIBRARY
13445     if ~setup_sql_diary then let fn_setup_sql_diary
13446     dim diary_desc$(1)*80,diary_code(1),diary_docs$(1)*90,diary_queue$(1)*8,lett$(10)*8
13447     dim diary_finan(10),cache_diary_finan(1,1),cache_diary_autodel$(1)*1,cache_diary_protected$(1)*1
13448     mat diary_desc$(999)=('') : mat diary_code(999)=(0)
13449     mat diary_span(999)=(0)
13450     mat diary_docs$(999)=('') : mat diary_queue$(999)=('')
13451     mat cache_diary_finan(999,10)=(0) : mat cache_diary_autodel$(999)=('') : mat cache_diary_protected$(999)=('')
13452     let super_handle=fnsuperopen((mfile$:="DIARY//9"),vrec,chunk,rpos,file_size,trec,head)
13454     if rpos>chunk then goto END_DIARY_SETUP
13456 NEXT_DIARY_CHUNK: read #super_handle,using EXT_CHUNK,pos=rpos,release: ext_buff$
13458 EXT_CHUNK: form pos 1,c chunk
13460     for vpos=1 to chunk step vrec
13462       reread #super_handle,using EXT_FORM: deleted$,mat lett$,mat diary_finan
13464       let buff$=ext_buff$(vpos+1:vpos+trec)
13466       let ndiary+=1
13468 EXT_FORM: form pos vpos,c 1,x 50,10*v 8,10*n 2
13470       if trim$(deleted$)<>"" or trim$(buff$(1:50))="" or ndiary>999 then goto SKIP_DIARY
13472       let diary_count+=1
13473       let diary_desc$(diary_count)=cnvrt$('pic(---)',ndiary)&""&buff$(155:162)&""&buff$(1:50)&""&buff$(51:58)
13474       let diary_span(diary_count)=fn_diarycode_desc_span(buff$(1:50))
13475       let cache_diary_autodel$(diary_count)=buff$(154:154)
13476       let cache_diary_protected$(diary_count)=buff$(163:163)
13477       let diary_code(diary_count)=ndiary
13478       let diary_queue$(diary_count)=trim$(buff$(155:162))
13480       let mat2str(mat lett$,diary_docs$(diary_count),chr$(9))
13481       let diary_docs$(diary_count)=trim$(diary_docs$(diary_count),chr$(9))
13482       for x=1 to 10 : let cache_diary_finan(diary_count,x)=diary_finan(x) : next x
13484 SKIP_DIARY: ! 
13486     next vpos
13488     if ndiary>999 then goto END_DIARY_SETUP
13490     let rpos+=chunk
13492     if rpos<file_size-chunk then goto NEXT_DIARY_CHUNK
13494     if rpos>=file_size then goto END_DIARY_SETUP
13496     let chunk=file_size-rpos
13498     close #super_handle: 
13500     open #super_handle: "name="&trim$(mfile$)&",recl="&str$(chunk)&",shr",external,outin,relative 
13502     goto NEXT_DIARY_CHUNK
13504 END_DIARY_SETUP: close #super_handle: ioerr ignore
13506     mat diary_desc$(diary_count) : mat diary_code(diary_count) : mat diary_span(diary_count)
13508     mat diary_docs$(diary_count) : mat diary_queue$(diary_count)
13510     if super_handle<=0 then 
13512       print bell;
13514       let fnoldsetup_diary
13516 ! ** Super Query failed for Diary, just use the old one
13518     end if 
13520   end if  ! ~setup_diary
13522 fnend  ! fn_setup_diary
13530 def fnparse_setup
13532   dim parse$(1)*512,parse_generation$(1)*20,parse_compound$(1)*20
13534   if parse_setup=1 then goto L13552
13536   let _parse=fnasci_("Parse.Nm//8",mat parse$) !:
        if _parse=0 and last_parse_nm_error=0 then let fnmessagebox_("Warning Parse.Nm//8 is Missing, Parsing of Names Will Not Function Correctly!",48,"File Missing") !:
          let last_parse_nm_error=1
13538   for nparse=1 to udim(parse$)
13540     if parse$(nparse)(1:13)="Generational:" then !:
            let nparse_generation=fnlist_(parse$(nparse),mat parse_generation$,",")
13542     if parse$(nparse)(1:9)="Compound:" then !:
            let nparse_compound=fnlist_(parse$(nparse),mat parse_compound$,",")
13550   next nparse
13552 L13552: let parse_setup=1
13554 fnend 
13560 def fnoldsetup_diary
13562   let msg$("Please Wait .... Initializing Diary Information")
13564   let setup_diary=1
13566   let diary_handle=fngetfile("DIARY//9,SHR")
13568 L13568: read #diary_handle,using L13570,release: buff$,mat lett$,mat diary_finan eof L13584
13570 L13570: form pos 1,c 198,pos 51,10*v 8,10*n 2
13572   if trim$(buff$(1:50))="" or rec(diary_handle)>999 then goto L13568
13574   let diary_count+=1 !:
        mat diary_desc$(diary_count) !:
        mat diary_code(diary_count) !:
        mat diary_docs$(diary_count) !:
        let diary_desc$(diary_count)=cnvrt$('pic(---)',rec(diary_handle))&""&buff$(155:162)&""&buff$(1:50)&""&buff$(51:58) !:
        let diary_span(diary_count)=fn_diarycode_desc_span(buff$(1:50)) !:
        let diary_code(diary_count)=rec(diary_handle) !:
        ! ### changed from 1:41 to 1:50
13576   for nlett=1 to 10
13578     if lett$(nlett)<>"" then !:
            let diary_docs$(diary_count)(999:0)=lett$(nlett)&chr$(9)
13580   next nlett
13581   for x=1 to 10 : let cache_diary_finan(diary_count,x)=diary_finan(x) : next x
13582   if diary_count<999 then goto L13568
13584 L13584: close #diary_handle: 
13586   let msg$("")
13588 fnend 
13590 def fnsetup_o_rates(mat o_rates_states$,mat o_rates_pre,mat o_rates_post)
13592   mat o_rates_states$(0)=("") !:
        mat o_rates_pre(0)=(0) !:
        mat o_rates_post(0)=(0)
13594   if ~exists("CUSTOM\ST_INT.INI") then goto L13618 !:
          ! ** ST_INT.INI !:
          ! THERE ARE TWO VALID FORMATS FOR THIS FILE !:
          ! * The original Format used ST=Rate1,Rate2 !:
          ! ** The other format is ST [TAB] Rate1 [TAB] Rate2 !:
          ! ** Assign/prog2 is "hard Coded" using ST_INT.INI and the "= ," format
13596   dim o_rates_table$(1)*80,o_rates_line$(1)*80
13598   let fnasci_("CUSTOM\ST_INT.INI",mat o_rates_table$) !:
        let _o_rates=udim(o_rates_table$) !:
        mat o_rates_states$(_o_rates)=("") !:
        mat o_rates_pre(_o_rates)=(0) !:
        mat o_rates_post(_o_rates)=(0)
13600   for _o_rates=1 to udim(o_rates_table$)
13602     let _pos1=pos(o_rates_table$(_o_rates),"="): let _pos2=pos(o_rates_table$(_o_rates),",")
13604     if _pos1>0 and _pos2>0 then 
13606       mat o_rates_line$(3) !:
            let o_rates_line$(1)=o_rates_table$(_o_rates)(1:_pos1-1) !:
            let o_rates_line$(2)=o_rates_table$(_o_rates)(_pos1+1:_pos2-1) !:
            let o_rates_line$(3)=o_rates_table$(_o_rates)(_pos2+1:99)
13608     else 
13610       let fnparse_csv_(o_rates_table$(_o_rates),mat o_rates_line$,tab$:=chr$(9)) !:
            mat o_rates_line$(3)
13612     end if 
13614     let o_rates_states$(_o_rates)=trim$(uprc$(o_rates_line$(1))) !:
          let o_rates_pre(_o_rates)=fnval_(o_rates_line$(2)) !:
          let o_rates_post(_o_rates)=fnval_(o_rates_line$(3))
13616   next _o_rates
13618 L13618: fnend 
13620 REREAD_FINAN: ! r: This section is called by FNREREAD to read in the information from FINAN!
13622 if ~setup_sql then gosub SETUP_SQL
13624 let reread_results=0 !:
      mat ta_line1=(0) !:
      mat ta_line2=(0) !:
      mat ta_filerec=(0) !:
      let bpj$=bill$=inv$=invdate$=invver$="" !:
      let merchandice=tax_rebate=tref=int=cbal=coll_hold=co_fees=datee=invpay=0 !:
      let actual_check=daily11=sf_out=comm_out=sf_c_out=comm_c_out=0 !:
      let actual_check=stat_due=cost_due=amt_6=frec_14=recd=disb=invpay=0
13626 mat finan_data$=("") !:
      mat finan_data=(0)
13628 ! Merchandice - This variable is not being populated !:
      ! * if you really want to know this information, use "BUCKETS" to see what category of payment was applied. !:
      ! TAX_REBATE - This was a legacy field, it may be costs recovered via DP now, either way, not implemented !:
      ! COLL_HOLD - This is not included in the base "FINAN.INT" file, I believe that "Buckets" reflects this information
13640 reread #phandle,using L13642,release: active_fileno$,data_active_trans_date,active_data_trans_time,active_code$,active_type$,active_data_recno
13642 L13642: form pos 1,c 8,2*bh 4,pos 65,c 8,c 1,pos 80,bh 4
13644 ! if PTYPE$<>ACTIVE_TYPE$ OR PCODE$<>ACTIVE_CODE$ THEN PRINT "?? WHY IS PTYPE$ & ACTIVE_TYPE$ DIFFERENT?";ACTIVE_FILENO$;" ";Data_Active_Trans_Date;" ";ACTIVE_CODE$;" ";ACTIVE_TYPE$ !:
      if ptype$<>active_type$ then !:
        let fn_list_print("?? Why are PType$ ("&ptype$&") and Active_Type$ ("&active_type$&") Different?",funny_window,1,"fnReRead_Finan") !:
        let fn_list_print("   Active_FileNo$="&active_fileno$&" "&"Active_Trans_Date="&str$(data_active_trans_date),funny_window,1,"fnReRead_Finan") !:
        let fn_list_print(funny_window,"   Active_Code$="&active_code$&" "&"Active_Type$="&active_type$,funny_window,1,"fnReRead_Finan")
13646 if pcode$<>active_code$ then !:
        let fn_list_print("?? Why are PCode$ ("&pcode$&") and Active_Code$ ("&active_code$&") Different?",funny_window,1,"fnReRead_Finan") !:
        let fn_list_print("   Active_FileNo$="&active_fileno$&" "&"Active_Trans_Date="&str$(data_active_trans_date),funny_window,1,"fnReRead_Finan") !:
        let fn_list_print("   Active_Code$="&active_code$&" "&"Active_Type$="&active_type$,funny_window,1,"fnReRead_Finan")
13648 if trim$(ptype$)="" then goto XIT_REREAD_FINAN else !:
        if trim$(pcode$(1:5))="SCAN:" or trim$(ptype$)="L" or trim$(ptype$)="D" or trim$(ptype$)="R" then goto XIT_REREAD_FINAN
13650 if trim$(ptype$)="A" or trim$(ptype$)="B" or trim$(ptype$)="C" or trim$(ptype$)="I" or trim$(ptype$)="S" or trim$(ptype$)="M" then goto L13660
13652 print "WHAT IS ";ptype$;"?"
13654 pause 
13656 pause 
13660 L13660: if uprc$(file$(phandle)(1:2))="I:" or pos(uprc$(file$(phandle)),"ACT-OPEN-"&session$&".INT") then 
13662   let pfinan_handle=finan_handle !:
        if finan_handle<=0 or file(finan_handle)<=-1 then let finan_handle=pfinan_handle=fngethandle_ !:
          open #finan_handle: "NAME=FINAN.INT//6,KFNAME=FINAN.IDX//6,shr",internal,input,keyed 
13664 else 
13666   let pfinan_handle=finanh_handle !:
        if finanh_handle<=0 or file(finanh_handle)<=-1 then let finanh_handle=pfinan_handle=fngethandle_ !:
          open #finanh_handle: "NAME=FINAN.INT//1,KFNAME=FINAN.IDX//1,shr",internal,input,keyed 
13668 end if 
13670 let finan_key$=active_fileno$&cnvrt$("BH 4",data_active_trans_date)&cnvrt$("BH 4",active_data_trans_time)&active_code$&active_type$&cnvrt$("BH 4",active_data_recno)
13672 let reread_results=-1 !:
      read #pfinan_handle,using finan_formall$,key=finan_key$,release: mat finan_data$,mat finan_data nokey L13674 !:
      let reread_results=rec(phandle) !:
      goto L13682
13674 L13674: ! Nokey, perhaps RECNO was a problem?, try again without the recno
13676 let finan_key$=active_fileno$&cnvrt$("BH 4",data_active_trans_date)&cnvrt$("BH 4",active_data_trans_time)&active_code$&active_type$
13678 read #pfinan_handle,using L13680,search>=finan_key$,release: finan_fileno$,finan_data_trans_date,finan_data_trans_time,finan_c0de$,finan_type$,finan_data_recno nokey L13682 !:
      if finan_fileno$=active_fileno$ and finan_data_trans_date=data_active_trans_date and finan_data_trans_time=active_data_trans_time and finan_c0de$=active_code$ and finan_type$=active_type$ then !:
        reread #pfinan_handle,using finan_formall$,release: mat finan_data$,mat finan_data nokey L13674 !:
        let reread_results=rec(phandle)
13680 L13680: form pos 1,c 8,2*bh 4,c 8,c 1,pos 28,bh 4
13682 L13682: let int=finan_data(finan_int) !:
      let co_fees=finan_data(finan_co_fees) !:
      let amt_6=finan_data(finan_claim_contract) !:
      let frec_14=finan_data(finan_claim_pre_j_int)
13684 let stat_due=finan_data(finan_claim_stat_fee)-finan_data(finan_tot_stat_fee) !:
      let cost_due=finan_data(finan_tot_rec_exp)-finan_data(finan_tot_costs)
13686 let ta_line1(2)=finan_data(finan_costs) !:
      let ta_line1(3)=finan_data(finan_stat_fee) !:
      let ta_line1(4)=finan_data(finan_net) !:
      let ta_line1(5)=finan_data(finan_balance) !:
      let ta_line1(6)=finan_data(finan_received)
13688 let tot_finan_coll=finan_data(finan_tot_principal)+finan_data(finan_tot_interest)+finan_data(finan_tot_costs)
13690 let ta_line2(1)=finan_data(finan_principal) !:
      let ta_line2(2)=finan_data(finan_interest) !:
      let ta_line2(3)=tot_finan_coll !:
      let ta_line2(4)=finan_data(finan_costs_returned) !:
      let ta_line2(5)=finan_data(finan_costs_expended) !:
      let ta_line2(6)=finan_data(finan_costs_received) !:
      let ta_line2(7)=finan_data(finan_suit_fee) !:
      let ta_line2(8)=finan_data(finan_commission)
13692 let ta_filerec(1)=finan_data(finan_claim_orig_bal) !:
      let ta_filerec(2)=finan_data(finan_claim_suit_amt) !:
      let ta_filerec(3)=finan_data(finan_claim_stat_fee) !:
      let ta_filerec(4)=finan_data(finan_claim_jdg_amt) !:
      let ta_filerec(5)=finan_data(finan_balance) !:
      let ta_filerec(6)=finan_data(finan_cost_balance)
13694 let ta_filerec(8)=finan_data(finan_tot_principal) !:
      let ta_filerec(9)=finan_data(finan_tot_interest) !:
      let ta_filerec(16)=finan_data(finan_tot_rec_exp) !:
      let ta_filerec(17)=finan_data(finan_tot_costs) !:
      let ta_filerec(18)=finan_data(finan_tot_commission) !:
      let ta_filerec(19)=finan_data(finan_tot_suit_fee) !:
      let ta_filerec(20)=finan_data(finan_tot_stat_fee)
13696 let bpj$=finan_data$(finan_bpj) !:
      let bill$=finan_data$(finan_bill)
13698 if type$="I" then let inv$=finan_data$(finan_comment) !:
        let invdate$=fndate8_$(finan_data(finan_datee)) !:
        let invpay=finan_data(finan_amount) !:
        let invver$="A" !:
        ! ** NOTE INVVER WAS USED IN 6.2, N/A IN 6.4
13700 let recd=finan_data(finan_received) !:
      let disb=finan_data(finan_disbursed) !:
      let tref=finan_data(finan_refno) !:
      let actual_check=finan_data(finan_checkno) !:
      let cbal=ta_filerec(6) !:
      let datee=finan_data(finan_datee)
13702 let daily11=finan_data(finan_adjustments)
13704 XIT_REREAD_FINAN: ! 
13706 return  ! /r REREAD_FINAN
13710 def library fnint_stamp(active_handle,finan_handle,stamp_fileno$,stamp_comment$*30,stamp_amount,stamp_code$,stamp_bpj$,stamp_type$,stamp_user,stamp_int,stamp_contract,stamp_stat_due,stamp_costs_due,mat stamp_filerec,mat stamp_frec,mat stamp_line1,mat stamp_line2,mat stamp_line3; stamp_refno,stamp_numdat,stamp_trans_type$,stamp_trust$,stamp_time)
13712   let fnint_stamp=fnintstamp(active_handle,finan_handle,stamp_fileno$,stamp_comment$,stamp_amount,stamp_code$,stamp_bpj$,stamp_type$,stamp_user,stamp_int,stamp_contract,stamp_stat_due,stamp_costs_due,mat stamp_filerec,mat stamp_frec,mat stamp_line1,mat stamp_line2,mat stamp_line3, stamp_refno,stamp_numdat,stamp_trans_type$,stamp_trust$,stamp_time)
13714 fnend  ! FNINT_STAMP
13720 def fnintstamp(active_handle,finan_handle,stamp_fileno$,stamp_comment$*30,stamp_amount,stamp_code$,stamp_bpj$,stamp_type$,stamp_user,stamp_int,stamp_contract,stamp_stat_due,stamp_costs_due,mat stamp_filerec,mat stamp_frec,mat stamp_line1,mat stamp_line2,mat stamp_line3; stamp_refno,stamp_numdat,stamp_trans_type$,stamp_trust$,stamp_time)
13722   if ~setup_sql then gosub SETUP_SQL
13724 ! ** THIS ROUTINE IS DESIGNED TO WRITE AN ENTRY TO ACTIVE_HANDLE & FINAN_HANDLE WITH THE CURRENT ACCOUNTING INFORMATION! !:
        ! ** NOTE: ACTIVE_HANDLE & FINAN_HANDLE, NEED TO BE PRE-DEFINED & SETUP! !:
        ! ** STAMP_TYPE MAY BE 'S' FOR STAMP, OR 'A' FOR ACCOUNTING CHANGE LIKE MAST
13726 ! Question, should be store !:
        ! Received/Disbursed !:
        ! Trust/BR/PC Bill
13728   mat finan_data$(udim(mat finan_fieldsc$))=("") !:
        mat finan_data(udim(mat finan_fieldsn$))=(0)
13730   if stamp_time = 0 then !:
          let stamp_trans_time=fnstime_(time$) !:
        else !:
          let stamp_trans_time=stamp_time
13732   if stamp_numdat then !:
          let stamp_trans_date=date(days(stamp_numdat),"CCYYMMDD") else !:
          let stamp_trans_date=date("CCYYMMDD")
13734   let finan_data$(finan_fileno)=stamp_fileno$ !:
        let finan_data$(finan_code)=stamp_code$ !:
        let finan_data$(finan_type)=stamp_type$ !:
        let finan_data$(finan_comment)=stamp_comment$ !:
        let finan_data$(finan_bpj)=stamp_bpj$
13736   let finan_data$(finan_trans_type)=stamp_trans_type$ !:
        if trim$(stamp_trans_type$)="" then !:
          let finan_data$(finan_trans_type)="T"
13738   let finan_data$(finan_trust)=stamp_trust$
13740   let finan_data(finan_user_id)=stamp_user !:
        let finan_data(finan_trans_date)=stamp_trans_date !:
        let finan_data(finan_trans_time)=stamp_trans_time !:
        let finan_data(finan_amount)=stamp_amount
13742   let finan_data(finan_costs)=stamp_line1(2) !:
        let finan_data(finan_stat_fee)=stamp_line1(3) !:
        let finan_data(finan_net)=stamp_line1(4) !:
        let finan_data(finan_balance)=stamp_line1(5) !:
        let finan_data(finan_received)=stamp_line1(6) !:
        let finan_data(finan_disbursed)=stamp_line2(5)+stamp_line1(4)+stamp_line2(4) !:
        ! Either Costs Disburse or (Collection - Net + Costs Returned)
13744   let finan_data(finan_principal)=stamp_line2(1) !:
        let finan_data(finan_interest)=stamp_line2(2) !:
        let tot_finan_coll=stamp_line2(3) !:
        let finan_data(finan_costs_returned)=stamp_line2(4) !:
        let finan_data(finan_costs_expended)=stamp_line2(5) !:
        let finan_data(finan_costs_received)=stamp_line2(6) !:
        let finan_data(finan_suit_fee)=stamp_line2(7) !:
        let finan_data(finan_commission)=stamp_line2(8)
13746 ! TOT_FINAN_COLL might have a purpose, but is N/A at the moment
13748   let finan_data(finan_claim_orig_bal)=stamp_filerec(1) !:
        let finan_data(finan_claim_suit_amt)=stamp_filerec(2) !:
        let finan_data(finan_claim_stat_fee)=stamp_filerec(3) !:
        let finan_data(finan_claim_jdg_amt)=stamp_filerec(4) !:
        let finan_data(finan_balance)=stamp_filerec(5) !:
        let finan_data(finan_cost_balance)=stamp_filerec(6)
13750   let finan_data(finan_tot_principal)=stamp_filerec(8) !:
        let finan_data(finan_tot_interest)=stamp_filerec(9) !:
        let finan_data(finan_tot_rec_exp)=stamp_filerec(16) !:
        let finan_data(finan_tot_costs)=stamp_filerec(17) !:
        let finan_data(finan_tot_commission)=stamp_filerec(18) !:
        let finan_data(finan_tot_suit_fee)=stamp_filerec(19) !:
        let finan_data(finan_tot_stat_fee)=stamp_filerec(20)
13752   let finan_data(finan_int)=stamp_int !:
        let finan_data(finan_claim_contract)=stamp_contract !:
        let finan_data(finan_stat_due)=stamp_stat_due !:
        let finan_data(finan_costs_due)=stamp_costs_due !:
        ! ** Note: STAMP_CONTRACT incorrectly assigned to CONTRACT in early versions of STAMP could cause "Unwanted" Stamps or Extra Atty Fees to be reported
13760   if udim(stamp_frec)>=22 then 
13762     let finan_data(finan_claim_pre_j_int)=stamp_frec(14) !:
          let finan_data(finan_compr_amt)=stamp_frec(22)
13764   else 
13766     print bell; !:
          print "WARNING:FNINT_STAMP Required FREC to be dimmed!" !:
          execute "STATUS STACKS" !:
          print "WARNING:FNINT_STAMP Required FREC to be dimmed!" !:
          let sleep(5): print bell; !:
          let finan_data(finan_claim_pre_j_int)=0 !:
          ! ** NOTE: stamp_frec(14) SOMETIMES FAILS BECAUSE IT'S NOT DIMMED! !:
          ! In these cases, we will simply store PJI of 0, rather than fail!
13768   end if 
13770 ! ,STAMP_STAT_DUE,STAMP_COSTS_DUE,
13772   let finan_data$(finan_bpj)=stamp_bpj$ !:
        let finan_data$(finan_bill)=stamp_bill$ !:
        let finan_data(finan_refno)=stamp_refno
13774   let finan_data(finan_prin)=stamp_line3(1) !:
        let finan_data(finan_contract)=stamp_line3(2) !:
        let finan_data(finan_legal)=stamp_line3(3) !:
        let finan_data(finan_other)=stamp_line3(8)
13780   let stamp_recno=lrec(active_handle)+1 !:
        write #active_handle,using L13782: stamp_fileno$,stamp_trans_date,stamp_trans_time,stamp_comment$(1:16),stamp_amount,"",stamp_code$,stamp_type$,stamp_user,0,stamp_recno,finan_data(finan_received),finan_data(finan_disbursed)
13782 L13782: form pos 1,c 8,2*bh 4,c 16,pic(-,---,---.--),pos 45,c 20,c 8,c 1,bh 2,2*bh 4,2*bh 4.2
13784   let finan_data(finan_recno)=stamp_recno
13786   write #finan_handle,using finan_formall$: mat finan_data$,mat finan_data
13788   let fn_int_stamp_set_finan_data(mat finan_data$,mat finan_data)
13790 fnend 
13800 def fn_int_stamp_set_finan_data(mat issfd_finan_data$,mat issfd_finan_data) ! issfd_
13802 ! this function sets  (mat int_stamp_finan_data$,mat int_stamp_finan_data$) for fn_int_stamp_get_finan_data
13804   dim int_stamp_finan_data$(1)*60,int_stamp_finan_data(1)
13806   mat int_stamp_finan_data$(udim(mat issfd_finan_data$))
13808   mat int_stamp_finan_data$=issfd_finan_data$
13810   mat int_stamp_finan_data(udim(mat issfd_finan_data))
13812   mat int_stamp_finan_data=issfd_finan_data
13814 fnend  ! fn_int_stamp_set_finan_data
13820 def library fnint_stamp_get_finan_data(mat isgfd_finan_data$,mat isgfd_finan_data)
13822   if ~setup_sql then gosub SETUP_SQL
13824   let fnint_stamp_get_finan_data=fn_int_stamp_get_finan_data(mat isgfd_finan_data$,mat isgfd_finan_data)
13826 fnend  ! fnint_stamp_get_finan_data
13830 def fn_int_stamp_get_finan_data(mat isgfd_finan_data$,mat isgfd_finan_data)
13832 ! All arrays Chuck Norris declares are of infinite size, because Chuck Norris knows no bounds.
13834   mat isgfd_finan_data$(udim(mat int_stamp_finan_data$))
13836   mat isgfd_finan_data$=int_stamp_finan_data$
13838   mat isgfd_finan_data(udim(mat int_stamp_finan_data))
13840   mat isgfd_finan_data=int_stamp_finan_data
13842 fnend  ! fn_int_stamp_get_finan_data
13850 def library fnlast_stamp(stamp_handle,stamp_fileno$,stamp_code$,&stamp_int,&stamp_contract,&stamp_stat_due,&stamp_costs_due,mat stamp_filerec,mat stamp_frec;&stamp_trans_date,&stamp_trans_time)
13852   if ~setup_sql then gosub SETUP_SQL
13854   let stamp_int=stamp_stat_due=stamp_costs_due=stamp_contract=0 !:
        mat stamp_filerec=(0) !:
        mat stamp_frec=(0)
13860   if stamp_handle<=0 or file(stamp_handle)<=-1 then let stamp_handle=fngethandle_ !:
          open #stamp_handle: "NAME=FINAN.INT//6,KFNAME=FINAN.IDX//6,shr",internal,outin,keyed 
13862   let last_dig=ord(stamp_fileno$(8:8)) !:
        let next_file$=stamp_fileno$(1:7)&chr$(last_dig+1)
13870   read #stamp_handle,using L13872,search>=next_file$,release: tfileno$ nokey L13880 !:
        goto L13882
13872 L13872: form pos 1,c 8
13880 L13880: restore #stamp_handle,last: 
13882 L13882: mat finan_data$=("") !:
        mat finan_data=(0) !:
        read #stamp_handle,using finan_formall$,prior,release: mat finan_data$,mat finan_data eof L13912
13890   if trim$(finan_data$(finan_fileno))<>trim$(stamp_fileno$) then goto L13912
13892   if trim$(finan_data$(finan_code))<>stamp_code$ or finan_data(finan_trans_date)>date("CCYYMMDD") then goto L13882 !:
          ! ** Note: Time stamps for a future date will not be respected!:
          ! Messing with a claim date can adversely affect this function
13894   let stamp_trans_date=finan_data(finan_trans_date) !:
        let stamp_trans_time=finan_data(finan_trans_time)
13900   let stamp_filerec(1)=finan_data(finan_claim_orig_bal) !:
        let stamp_filerec(2)=finan_data(finan_claim_suit_amt) !:
        let stamp_filerec(3)=finan_data(finan_claim_stat_fee) !:
        let stamp_filerec(4)=finan_data(finan_claim_jdg_amt) !:
        let stamp_filerec(5)=finan_data(finan_balance) !:
        let stamp_filerec(6)=finan_data(finan_cost_balance)
13902   let stamp_filerec(8)=finan_data(finan_tot_principal) !:
        let stamp_filerec(9)=finan_data(finan_tot_interest) !:
        let stamp_filerec(16)=finan_data(finan_tot_rec_exp) !:
        let stamp_filerec(17)=finan_data(finan_tot_costs) !:
        let stamp_filerec(18)=finan_data(finan_tot_commission) !:
        let stamp_filerec(19)=finan_data(finan_tot_suit_fee) !:
        let stamp_filerec(20)=finan_data(finan_tot_stat_fee)
13904   let stamp_frec(14)=finan_data(finan_claim_pre_j_int) !:
        let stamp_frec(22)=finan_data(finan_compr_amt)
13906   let stamp_int=finan_data(finan_int) !:
        let stamp_stat_due=finan_data(finan_stat_due) !:
        let stamp_costs_due=finan_data(finan_costs_due) !:
        let stamp_contract=finan_data(finan_claim_contract)
13910   goto L13914
13912 L13912: ! "NO STAMP FOUND" !:
        goto L13916
13914 L13914: let fnlast_stamp=rec(stamp_handle)
13916 L13916: fnend 
13920 ! #### - Available Line Number Range
14899 ! #### - Available Line Number Range
14900 SETUP_SQL: ! r: Setup SQL Info
14901 if setup_sql=1 then goto XIT_SETUP_SQL
14902 let setup_sql=1
14910 dim master_data$(1)*60,master_data(1),master_fieldsc$(1)*20,master_fieldsn$(1)*20,master_formc$*2048,master_formn$*2048,master_before_data$(1)*60,master_before_data(1)
14911 dim debtor_data$(1)*60,debtor_data(1),debtor_fieldsc$(1)*20,debtor_fieldsn$(1)*20,debtor_formc$*2048,debtor_formn$*2048,debtor_formall$*2048,debtor_before_data$(1)*60,debtor_before_data(1)
14912 dim finan_data$(1)*60,finan_data(1),finan_fieldsc$(1)*20,finan_fieldsn$(1)*20,finan_formc$*2048,finan_formn$*2048,finan_formall$*2048
14913 dim buckets_data$(1)*60,buckets_data(1),buckets_fieldsc$(1)*20,buckets_fieldsn$(1)*20,buckets_formc$*2048,buckets_formn$*2048,buckets_formall$*2048
14914 dim masforw_data$(1)*60,masforw_data(1),masforw_fieldsc$(1)*20,masforw_fieldsn$(1)*20,masforw_formc$*2048,masforw_formn$*2048,masforw_formall$*2048
14915 dim finsum_data$(1)*60,finsum_data(1),finsum_fieldsc$(1)*20,finsum_fieldsn$(1)*20,finsum_formc$*2048,finsum_formn$*2048,finsum_formall$*2048
14920 dim master_des_c$(1)*80,master_des_n$(1)*80,master_seq$(1)*80,master_valid$(1)*80,master_fc$(1,3)*80,master_fn$(1,3)*80
14921 dim debtor_des_c$(1)*80,debtor_des_n$(1)*80,debtor_seq$(1)*80,debtor_valid$(1)*80,debtor_fc$(1,3)*80,debtor_fn$(1,3)*80
14922 dim finan_des_c$(1)*80,finan_des_n$(1)*80,finan_seq$(1)*80,finan_valid$(1)*80,finan_fc$(1,3)*80,finan_fn$(1,3)*80
14923 dim buckets_des_c$(1)*80,buckets_des_n$(1)*80,buckets_seq$(1)*80,buckets_valid$(1)*80,buckets_fc$(1,3)*80,buckets_fn$(1,3)*80
14924 ! dim masforw_des_c$(1)*80,masforw_des_n$(1)*80,masforw_seq$(1)*80,masforw_valid$(1)*80,masforw_fc$(1,3)*80,masforw_fn$(1,3)*80
14925 ! dim finsum_des_c$(1)*80,finsum_des_n$(1)*80,finsum_seq$(1)*80,finsum_valid$(1)*80,finsum_fc$(1,3)*80,finsum_fn$(1,3)*80
14930 let fngetform("master",mat master_data$,mat master_data,mat master_fieldsc$,mat master_fieldsn$,master_formc$,master_formn$) !:
      mat master_before_data$(udim(master_data$)) !:
      mat master_before_data(udim(master_data))
14931 let fngetform("debtor",mat debtor_data$,mat debtor_data,mat debtor_fieldsc$,mat debtor_fieldsn$,debtor_formc$,debtor_formn$) !:
      mat debtor_before_data$(udim(debtor_data$)) : mat debtor_before_data(udim(debtor_data)) !:
      let debtor_formall$=fngetformall$
14932 let fngetform("FINAN",mat finan_data$,mat finan_data,mat finan_fieldsc$,mat finan_fieldsn$,finan_formc$,finan_formn$) !:
      let finan_formall$=fngetformall$
14933 let fngetform("BUCKETS",mat buckets_data$,mat buckets_data,mat buckets_fieldsc$,mat buckets_fieldsn$,buckets_formc$,buckets_formn$)
14934 let fngetform("FinSum",mat finsum_data$,mat finsum_data,mat finsum_fieldsc$,mat finsum_fieldsn$,finsum_formc$,finsum_formn$) !:
      let finsum_formall$=fngetformall$
14936 let fngetform("MASFORW",mat masforw_data$,mat masforw_data,mat masforw_fieldsc$,mat masforw_fieldsn$,masforw_formc$,masforw_formn$)
14937 let fngetform("BUCKETS",mat buckets_data$,mat buckets_data,mat buckets_fieldsc$,mat buckets_fieldsn$,buckets_formc$,buckets_formn$) !:
      let fngetformarr("BUCKETS",mat buckets_data$,mat buckets_data,mat buckets_fieldsc$,mat buckets_fieldsn$,mat buckets_fc$,mat buckets_fn$,mat buckets_des_c$,mat buckets_des_n$,mat buckets_seq$,mat buckets_valid$)
14940 let fngetformarr("master",mat master_data$,mat master_data,mat master_fieldsc$,mat master_fieldsn$,mat master_fc$,mat master_fn$,mat master_des_c$,mat master_des_n$,mat master_seq$,mat master_valid$)
14941 let fngetformarr("DEBTOR",mat debtor_data$,mat debtor_data,mat debtor_fieldsc$,mat debtor_fieldsn$,mat debtor_fc$,mat debtor_fn$,mat debtor_des_c$,mat debtor_des_n$,mat debtor_seq$,mat debtor_valid$)
14942 let fngetformarr("FINAN",mat finan_data$,mat finan_data,mat finan_fieldsc$,mat finan_fieldsn$,mat finan_fc$,mat finan_fn$,mat finan_des_c$,mat finan_des_n$,mat finan_seq$,mat finan_valid$)
14943 let fngetformarr("BUCKETS",mat buckets_data$,mat buckets_data,mat buckets_fieldsc$,mat buckets_fieldsn$,mat buckets_fc$,mat buckets_fn$,mat buckets_des_c$,mat buckets_des_n$,mat buckets_seq$,mat buckets_valid$) !:
      let buckets_formall$=fngetformall$
14950 let buckets_fileno=srch(mat buckets_fieldsc$,"FILENO") !:
      let buckets_trans_date=srch(mat buckets_fieldsn$,"TRANS_DATE") !:
      let buckets_trans_time=srch(mat buckets_fieldsn$,"TRANS_TIME") !:
      let buckets_code=srch(mat buckets_fieldsc$,"CODE") !:
      let buckets_type=srch(mat buckets_fieldsc$,"TYPE")
14951 let buckets_recno=srch(mat buckets_fieldsn$,"RECNO") !:
      let buckets_refno=srch(mat buckets_fieldsn$,"REFNO") !:
      let buckets_category=srch(mat buckets_fieldsn$,"CATEGORY") !:
      let buckets_amount=srch(mat buckets_fieldsn$,"AMOUNT")
14952 let finan_fileno=srch(mat finan_fieldsc$,"FILENO") !:
      let finan_code=srch(mat finan_fieldsc$,"CODE") !:
      let finan_type=srch(mat finan_fieldsc$,"TYPE") !:
      let finan_comment=srch(mat finan_fieldsc$,"COMMENT") !:
      let finan_trust=srch(mat finan_fieldsc$,"TRUST") !:
      let finan_br=srch(mat finan_fieldsc$,"BR") !:
      let finan_pc=srch(mat finan_fieldsc$,"PC") !:
      let finan_bpj=srch(mat finan_fieldsc$,"BPJ") !:
      let finan_bill=srch(mat finan_fieldsc$,"BILL")
14954 let finan_trans_type=srch(mat finan_fieldsc$,"TRANS_TYPE")
14955 let finan_trans_date=srch(mat finan_fieldsn$,"TRANS_DATE") !:
      let finan_trans_time=srch(mat finan_fieldsn$,"TRANS_TIME") !:
      let finan_amount=srch(mat finan_fieldsn$,"AMOUNT") !:
      let finan_user_id=srch(mat finan_fieldsn$,"USER_ID") !:
      let finan_recno=srch(mat finan_fieldsn$,"RECNO") !:
      let finan_received=srch(mat finan_fieldsn$,"RECEIVED") !:
      let finan_disbursed=srch(mat finan_fieldsn$,"DISBURSED")
14956 let finan_costs=srch(mat finan_fieldsn$,"COSTS") !:
      let finan_stat_fee=srch(mat finan_fieldsn$,"STAT_FEE") !:
      let finan_other_fee=srch(mat finan_fieldsn$,"OTHER_FEE") !:
      let finan_co_fees=srch(mat finan_fieldsn$,"CO_FEES") !:
      let finan_net=srch(mat finan_fieldsn$,"NET") !:
      let finan_adjustments=srch(mat finan_fieldsn$,"ADJUSTMENTS") !:
      let finan_claim_jdg_amt=srch(mat finan_fieldsn$,"CLAIM_JDG_AMT") !:
      let finan_balance=srch(mat finan_fieldsn$,"BALANCE") !:
      let finan_received=srch(mat finan_fieldsn$,"RECEIVED")
14957 let finan_principal=srch(mat finan_fieldsn$,"PRINCIPAL") !:
      let finan_interest=srch(mat finan_fieldsn$,"INTEREST") !:
      let finan_costs_returned=srch(mat finan_fieldsn$,"COSTS_RETURNED") !:
      let finan_costs_expended=srch(mat finan_fieldsn$,"COSTS_EXPENDED") !:
      let finan_costs_received=srch(mat finan_fieldsn$,"COSTS_RECEIVED") !:
      let finan_coll_costs=srch(mat finan_fieldsn$,"COLL_COSTS") !:
      let finan_coll_charged=srch(mat finan_fieldsn$,"COLL_CHARGED") !:
      let finan_suit_fee=srch(mat finan_fieldsn$,"SUIT_FEE") !:
      let finan_commission=srch(mat finan_fieldsn$,"COMMISSION")
14960 let finan_claim_orig_bal=srch(mat finan_fieldsn$,"CLAIM_ORIG_BAL") !:
      let finan_claim_suit_amt=srch(mat finan_fieldsn$,"CLAIM_SUIT_AMT") !:
      let finan_claim_stat_fee=srch(mat finan_fieldsn$,"CLAIM_STAT_FEE") !:
      let finan_claim_jdg_amt=srch(mat finan_fieldsn$,"CLAIM_JDG_AMT") !:
      let finan_balance=srch(mat finan_fieldsn$,"BALANCE") !:
      let finan_cost_balance=srch(mat finan_fieldsn$,"COST_BALANCE")
14961 let finan_tot_principal=srch(mat finan_fieldsn$,"TOT_PRINCIPAL") !:
      let finan_tot_interest=srch(mat finan_fieldsn$,"TOT_INTEREST") !:
      let finan_tot_rec_exp=srch(mat finan_fieldsn$,"TOT_REC_EXP") !:
      let finan_tot_costs=srch(mat finan_fieldsn$,"TOT_COSTS") !:
      let finan_tot_commission=srch(mat finan_fieldsn$,"TOT_COMMISSION") !:
      let finan_tot_suit_fee=srch(mat finan_fieldsn$,"TOT_SUIT_FEE") !:
      let finan_tot_stat_fee=srch(mat finan_fieldsn$,"TOT_STAT_FEE")
14962 let finan_prin=srch(mat finan_fieldsn$,"PRIN") !:
      let finan_int=srch(mat finan_fieldsn$,"INT") !:
      let finan_contract=srch(mat finan_fieldsn$,"CONTRACT") !:
      let finan_legal=srch(mat finan_fieldsn$,"LEGAL") !:
      let finan_other=srch(mat finan_fieldsn$,"OTHER") !:
      let finan_claim_pre_j_int=srch(mat finan_fieldsn$,"CLAIM_PRE_J_INT") !:
      let finan_stat_due=srch(mat finan_fieldsn$,"STAT_DUE") !:
      let finan_costs_due=srch(mat finan_fieldsn$,"COSTS_DUE") !:
      let finan_charges_due=srch(mat finan_fieldsn$,"CHARGES_DUE") !:
      let finan_other_due=srch(mat finan_fieldsn$,"OTHER_DUE")
14963 let finan_claim_contract=srch(mat finan_fieldsn$,"CLAIM_CONTRACT") !:
      let finan_sf_out=srch(mat finan_fieldsn$,"SF_OUT") !:
      let finan_comm_out=srch(mat finan_fieldsn$,"COMM_OUT") !:
      let finan_sf_c_out=srch(mat finan_fieldsn$,"SF_C_OUT") !:
      let finan_comm_c_out=srch(mat finan_fieldsn$,"COMM_C_OUT") !:
      let finan_compr_amt=srch(mat finan_fieldsn$,"COMPR_AMT")
14965 let finan_bill=srch(mat finan_fieldsc$,"BILL") !:
      let finan_bpj=srch(mat finan_fieldsc$,"BPJ") !:
      let finan_datee=srch(mat finan_fieldsn$,"DATEE") !:
      let finan_invpay=srch(mat finan_fieldsn$,"INVPAY")
14966 let finan_received=srch(mat finan_fieldsn$,"RECEIVED") !:
      let finan_disbursed=srch(mat finan_fieldsn$,"DISBURSED") !:
      let finan_refno=srch(mat finan_fieldsn$,"REFNO") !:
      let finan_checkno=srch(mat finan_fieldsn$,"CHECKNO") !:
      ! _________end of Finan
14967 let finsum_fileno=srch(mat finsum_fieldsc$,"FILENO") !:
      let finsum_date=srch(mat finsum_fieldsc$,"DATE") !:
      let finsum_acc_orig_amt=srch(mat finsum_fieldsn$,"ACC_ORIG_AMT") !:
      let finsum_acc_suit_amt=srch(mat finsum_fieldsn$,"ACC_SUIT_AMT") !:
      let finsum_acc_stat_fee=srch(mat finsum_fieldsn$,"ACC_STAT_FEE")
14968 let finsum_acc_j_amt=srch(mat finsum_fieldsn$,"ACC_J_AMT") !:
      let finsum_acc_d1_bal=srch(mat finsum_fieldsn$,"ACC_D1_BAL") !:
      let finsum_acc_cost_bal=srch(mat finsum_fieldsn$,"ACC_COST_BAL") !:
      let finsum_acc_coll_hold=srch(mat finsum_fieldsn$,"ACC_COLL_HOLD") !:
      let finsum_acc_princ_coll=srch(mat finsum_fieldsn$,"ACC_PRINC_COLL")
14969 let finsum_acc_int_coll=srch(mat finsum_fieldsn$,"ACC_INT_COLL") !:
      let finsum_acc_merch_pre=srch(mat finsum_fieldsn$,"ACC_MERCH_PRE") !:
      let finsum_acc_merch_post=srch(mat finsum_fieldsn$,"ACC_MERCH_POST") !:
      let finsum_acc_dpay_pre=srch(mat finsum_fieldsn$,"ACC_DPAY_PRE") !:
      let finsum_acc_dpay_post=srch(mat finsum_fieldsn$,"ACC_DPAY_POST")
14970 let finsum_acc_cost_rcvd=srch(mat finsum_fieldsn$,"ACC_COST_RCVD") !:
      let finsum_acc_cost_rtnd=srch(mat finsum_fieldsn$,"ACC_COST_RTND") !:
      let finsum_acc_recov_exp=srch(mat finsum_fieldsn$,"ACC_RECOV_EXP") !:
      let finsum_acc_cost_recov=srch(mat finsum_fieldsn$,"ACC_COST_RECOV") !:
      let finsum_cc_comm_earn=srch(mat finsum_fieldsn$,"ACC_COMM_EARN")
14971 let finsum_acc_sfee_earn=srch(mat finsum_fieldsn$,"ACC_SFEE_EARN") !:
      let finsum_acc_stat_earn=srch(mat finsum_fieldsn$,"ACC_STAT_EARN") !:
      let finsum_acc_int_accrued=srch(mat finsum_fieldsn$,"ACC_INT_ACCRUED") !:
      let finsum_acc_cost_jdg=srch(mat finsum_fieldsn$,"ACC_COST_JDG") !:
      let finsum_acc_aff_amt=srch(mat finsum_fieldsn$,"ACC_AFF_AMT")
14972 let finsum_acc_dpay_pstjdg=srch(mat finsum_fieldsn$,"ACC_DPAY_PSTJDG") !:
      let finsum_acc_non_rec_exp=srch(mat finsum_fieldsn$,"ACC_NON_REC_EXP") !:
      let finsum_acc_tot_cst_exp=srch(mat finsum_fieldsn$,"ACC_TOT_CST_EXP") !:
      let finsum_acc_dp_nfee_pre=srch(mat finsum_fieldsn$,"ACC_DP_NFEE_PRE") !:
      let finsum_acc_dp_nfee_pst=srch(mat finsum_fieldsn$,"ACC_DP_NFEE_PST")
14973 let finsum_acc_dp_nfee_jdg=srch(mat finsum_fieldsn$,"ACC_DP_NFEE_JDG") !:
      let finsum_acc_merch_jdg=srch(mat finsum_fieldsn$,"ACC_MERCH_JDG") !:
      let finsum_acc_firm_cost=srch(mat finsum_fieldsn$,"ACC_FIRM_COST") !:
      let finsum_acc_dp_pre_suit=srch(mat finsum_fieldsn$,"ACC_DP_PRE_SUIT") !:
      let finsum_acc_dp_suit=srch(mat finsum_fieldsn$,"ACC_DP_SUIT")
14974 let finsum_acc_dp_post_jdg=srch(mat finsum_fieldsn$,"ACC_DP_POST_JDG") !:
      let finsum_acc_pre_jdg_int=srch(mat finsum_fieldsn$,"ACC_PRE_JDG_INT") !:
      let finsum_acc_cst_rtn_dp=srch(mat finsum_fieldsn$,"ACC_CST_RTN_DP") !:
      let finsum_acc_coco_pre=srch(mat finsum_fieldsn$,"ACC_COCO_PRE") !:
      let finsum_acc_coco_post=srch(mat finsum_fieldsn$,"ACC_COCO_POST")
14975 let finsum_acc_coco_jdg=srch(mat finsum_fieldsn$,"ACC_COCO_JDG") !:
      let finsum_acc_cst_to_coco=srch(mat finsum_fieldsn$,"ACC_CST_TO_COCO") !:
      let finsum_acc_sales_tax=srch(mat finsum_fieldsn$,"ACC_SALES_TAX") !:
      let finsum_ta_firm_coll=srch(mat finsum_fieldsn$,"TA_FIRM_COLL") !:
      let finsum_ta_cost_recov=srch(mat finsum_fieldsn$,"TA_COST_RECOV")
14976 let finsum_ta_stat_fee=srch(mat finsum_fieldsn$,"TA_STAT_FEE") !:
      let finsum_ta_net_client=srch(mat finsum_fieldsn$,"TA_NET_CLIENT") !:
      let finsum_ta_d1_balance=srch(mat finsum_fieldsn$,"TA_D1_BALANCE") !:
      let finsum_ta_amt_recvd=srch(mat finsum_fieldsn$,"TA_AMT_RECVD") !:
      let finsum_ta_prin_coll=srch(mat finsum_fieldsn$,"TA_PRIN_COLL")
14977 let finsum_ta_int_coll=srch(mat finsum_fieldsn$,"TA_INT_COLL") !:
      let finsum_ta_cumm_coll=srch(mat finsum_fieldsn$,"TA_CUMM_COLL") !:
      let finsum_ta_cost_refund=srch(mat finsum_fieldsn$,"TA_COST_REFUND") !:
      let finsum_ta_cost_inc=srch(mat finsum_fieldsn$,"TA_COST_INC") !:
      let finsum_ta_cost_recv=srch(mat finsum_fieldsn$,"TA_COST_RECV")
14978 let finsum_ta_sfee_earn=srch(mat finsum_fieldsn$,"TA_SFEE_EARN") !:
      let finsum_ta_comm_earn=srch(mat finsum_fieldsn$,"TA_COMM_EARN") !:
      let finsum_eod_refno=srch(mat finsum_fieldsn$,"EOD_REFNO") !:
      let finsum_eod_amt_rcv=srch(mat finsum_fieldsn$,"EOD_AMT_RCV") !:
      let finsum_eod_comm_earned=srch(mat finsum_fieldsn$,"EOD_COMM_EARNED")
14979 let finsum_eod_suit_fee=srch(mat finsum_fieldsn$,"EOD_SUIT_FEE") !:
      let finsum_eod_stat_fees=srch(mat finsum_fieldsn$,"EOD_STAT_FEES") !:
      let finsum_eod_net_client=srch(mat finsum_fieldsn$,"EOD_NET_CLIENT") !:
      let finsum_eod_costs_recov=srch(mat finsum_fieldsn$,"EOD_COSTS_RECOV") !:
      let finsum_eod_costs_disb=srch(mat finsum_fieldsn$,"EOD_COSTS_DISB")
14980 let finsum_eod_costs_ret=srch(mat finsum_fieldsn$,"EOD_COSTS_RET") !:
      let finsum_eod_misc_cost=srch(mat finsum_fieldsn$,"EOD_MISC_COST") !:
      let finsum_eod_adjust=srch(mat finsum_fieldsn$,"EOD_ADJUST") !:
      let finsum_eod_collhold=srch(mat finsum_fieldsn$,"EOD_COLLHOLD") !:
      let finsum_eod_remithold=srch(mat finsum_fieldsn$,"EOD_REMITHOLD")
14981 let finsum_eod_ret_net_rec=srch(mat finsum_fieldsn$,"EOD_RET_NET_REC") !:
      let finsum_eod_ret_costs=srch(mat finsum_fieldsn$,"EOD_RET_COSTS") !:
      let finsum_eod_ret_earn=srch(mat finsum_fieldsn$,"EOD_RET_EARN") !:
      let finsum_eod_check_amt=srch(mat finsum_fieldsn$,"EOD_CHECK_AMT") !:
      let finsum_eod_sales_tax=srch(mat finsum_fieldsn$,"EOD_SALES_TAX")
14982 let finsum_ta_chk_no=srch(mat finsum_fieldsn$,"TA_CHK_NO") !:
      let finsum_atty_no=srch(mat finsum_fieldsn$,"ATTY_NO") !:
      let finsum_secy_no=srch(mat finsum_fieldsn$,"SECY_NO") !:
      let finsum_coll_no=srch(mat finsum_fieldsn$,"COLL_NO") !:
      let finsum_forw_no=srch(mat finsum_fieldsn$,"FORW_NO")
14983 let finsum_withheld_agent=srch(mat finsum_fieldsn$,"WITHHELD_AGENT") !:
      let finsum_trans_code=srch(mat finsum_fieldsn$,"TRANS_CODE") !:
      let finsum_coco_no=srch(mat finsum_fieldsn$,"COCO_NO") !:
      let finsum_filler1=srch(mat finsum_fieldsc$,"FILLER1") !:
      let finsum_comm_cst_billed=srch(mat finsum_fieldsn$,"COMM_CST_BILLED")
14984 let finsum_comm_cst_inv_pd=srch(mat finsum_fieldsn$,"COMM_CST_INV_PD") !:
      let finsum_comm_fee_billed=srch(mat finsum_fieldsn$,"COMM_FEE_BILLED") !:
      let finsum_comm_fee_inv_pd=srch(mat finsum_fieldsn$,"COMM_FEE_INV_PD") !:
      let finsum_interest_kept=srch(mat finsum_fieldsn$,"INTEREST_KEPT") !:
      let finsum_bpj=srch(mat finsum_fieldsc$,"BPJ")
14985 let finsum_sales_no=srch(mat finsum_fieldsn$,"SALES_NO") !:
      let finsum_status=srch(mat finsum_fieldsc$,"STATUS") !:
      let finsum_subcode=srch(mat finsum_fieldsn$,"SUBCODE") !:
      let finsum_trans_time=srch(mat finsum_fieldsn$,"TRANS_TIME") !:
      let finsum_type=srch(mat finsum_fieldsc$,"TYPE")
14986 let finsum_code=srch(mat finsum_fieldsc$,"CODE") !:
      let finsum_recno=srch(mat finsum_fieldsn$,"RECNO") !:
      let finsum_ta_prin=srch(mat finsum_fieldsn$,"TA_PRIN") !:
      let finsum_ta_contract=srch(mat finsum_fieldsn$,"TA_CONTRACT") !:
      let finsum_ta_legal=srch(mat finsum_fieldsn$,"TA_LEGAL")
14987 let finsum_line3_4=srch(mat finsum_fieldsn$,"LINE3_4") !:
      let finsum_line3_5=srch(mat finsum_fieldsn$,"LINE3_5") !:
      let finsum_line3_6=srch(mat finsum_fieldsn$,"LINE3_6") !:
      let finsum_line3_7=srch(mat finsum_fieldsn$,"LINE3_7") !:
      let finsum_line3_8=srch(mat finsum_fieldsn$,"LINE3_8")
14988 let finsum_comment=srch(mat finsum_fieldsc$,"COMMENT") !:
      let finsum_add_bill=srch(mat finsum_fieldsn$,"ADD_BILL") !:
      let finsum_trans_type=srch(mat finsum_fieldsc$,"ATRANS_TYPE") !:
      ! ____ end of FinSum
14989 !   ____ Extra
14990 dim extra_data$(1)*60,extra_data(1),extra_fieldsc$(1)*20,extra_fieldsn$(1)*20,extra_formc$*512,extra_formn$*512,extra_formall$*512,extra_before_data$(1)*60,extra_before_data(1)
14992 let fngetform("Extra",mat extra_data$,mat extra_data,mat extra_fieldsc$,mat extra_fieldsn$,extra_formc$,extra_formn$) !:
      let extra_formall$=fngetformall$
14994 mat extra_before_data(udim(extra_data))=(0) !:
      mat extra_before_data$(udim(extra_data$))=("")
14998 let extra_fileno=srch(mat extra_fieldsc$,"FILENO")
15000 !   ____ Debtor
15002 let debtor_fileno=srch(mat debtor_fieldsc$,"FILENO")
15004 let debtor_name=srch(mat debtor_fieldsc$,"NAME")
15006 let debtor_relation=srch(mat debtor_fieldsc$,"RELATION")
15008 let debtor_number=srch(mat debtor_fieldsn$,"NUMBER")
15010 !   ____ Master
15012 let master_fileno=srch(mat master_fieldsc$,"FILENO")
15013 let master_sher_no=srch(mat master_fieldsn$,"SHER_NO")
15014 let master_forw_no=srch(mat master_fieldsn$,"FORW_NO")
15015 let master_coco_no=srch(mat master_fieldsn$,"COCO_NO")
15016 let master_atty=srch(mat master_fieldsn$,"ATTY")
15017 let master_para=srch(mat master_fieldsn$,"PARA")
15018 let master_collector=srch(mat master_fieldsn$,"COLLECTOR")
15019 let master_sales_no=srch(mat master_fieldsn$,"SALES_NO") !:
      let master_c_priority=srch(mat master_fieldsc$,"C_PRIORITY") !:
      let master_forw_refno=srch(mat master_fieldsc$,"FORW_REFNO")
15020 let master_venue1_no=srch(mat master_fieldsn$,"VENUE1_NO")
15021 gosub SETUP_SQL_ACTIVE
15022 gosub SETUP_SQL_EDIMATRX
15023 gosub SETUP_SQL_HLPLNK1
15024 gosub SETUP_SQL_HLPLNK2
15025 gosub SETUP_SQL_INTERNAL
15026 gosub SETUP_SQL_ATTYFILE
15027 ! let fn_setup_sql_dchanges
15028 ! let fn_setup_sql_diaryint
15029 ! let fn_setup_sql_status
15030 ! let fn_setup_sql_diary
15170 XIT_SETUP_SQL: ! 
15179 return ! /r
15180 L15180: form pos 1,c 8,x 1,b 3,2*c 8,c 20,c 8,c 5,cr 3
15190 SETUP_SQL_ACTIVE: ! r:
15192 if ~setup_sql_active then 
15194   let setup_sql_active=true=1
15196   dim active_data$(1)*60,active_data(1),active_formall$*512,active_formc$*512,active_formn$*512
15198   let fngetform("active",mat active_data$,mat active_data,mat active_fieldsc$,mat active_fieldsn$,active_formc$,active_formn$)
15200   let active_formall$=fngetformall$
15202   let active_fileno=srch(mat active_fieldsc$,"FILENO")
15204   let active_trans_date=srch(mat active_fieldsn$,"TRANS_DATE")
15206   let active_trans_time=srch(mat active_fieldsn$,"TRANS_TIME")
15208   let active_paperless_cmt1=srch(mat active_fieldsc$,"PAPERLESS_CMT1")
15210   let active_paperless_cmt2=srch(mat active_fieldsc$,"PAPERLESS_CMT2")
15212   let active_code=srch(mat active_fieldsc$,"CODE")
15214   let active_type=srch(mat active_fieldsc$,"TYPE")
15216   let active_user_id=srch(mat active_fieldsn$,"USER_ID")
15218   let active_billed_date=srch(mat active_fieldsn$,"BILLED_DATE")
15220   let active_recno=srch(mat active_fieldsn$,"RECNO")
15222   let active_received=srch(mat active_fieldsn$,"RECEIVED")
15224   let active_disbursed=srch(mat active_fieldsn$,"DISBURSED")
15226 end if  ! ~setup_sql_active
15238 return  ! /r
15240 SETUP_SQL_EDIMATRX: ! r:
15244 if ~setup_sql_edimatrx then 
15246   let setup_sql_edimatrx=1
15248   dim edimatrx_data$(1)*60,edimatrx_data(1),edimatrx_fieldsc$(1)*20,edimatrx_fieldsn$(1)*20,edimatrx_formc$*512,edimatrx_formn$*512,edimatrx_formall$*1024
15250   let fngetform("EDIMatrx",mat edimatrx_data$,mat edimatrx_data,mat edimatrx_fieldsc$,mat edimatrx_fieldsn$,edimatrx_formc$,edimatrx_formn$)
15252   let edimatrx_formall$=fngetformall$
15254   let edimatrx_pf_code =srch(mat edimatrx_fieldsc$,'PF_CODE')
15256   let edimatrx_matrix_type=srch(mat edimatrx_fieldsc$,'MATRIX_TYPE')
15258 !   edimatrx_filler17     =srch(mat edimatrx_fieldsc$,'FILLER17')
15260   let edimatrx_edi_code =srch(mat edimatrx_fieldsc$,'EDI_CODE')
15261   let edimatrx_action_1 =srch(mat edimatrx_fieldsc$,'ACTION_1')
15262   let edimatrx_action_2 =srch(mat edimatrx_fieldsc$,'ACTION_2')
15263   let edimatrx_action_3 =srch(mat edimatrx_fieldsc$,'ACTION_3')
15264   let edimatrx_action_4 =srch(mat edimatrx_fieldsc$,'ACTION_4')
15265   let edimatrx_action_5 =srch(mat edimatrx_fieldsc$,'ACTION_5')
15266   let edimatrx_action_6 =srch(mat edimatrx_fieldsc$,'ACTION_6')
15267   let edimatrx_action_7 =srch(mat edimatrx_fieldsc$,'ACTION_7')
15268   let edimatrx_action_8 =srch(mat edimatrx_fieldsc$,'ACTION_8')
15269   let edimatrx_action_9 =srch(mat edimatrx_fieldsc$,'ACTION_9')
15270   let edimatrx_action_10 =srch(mat edimatrx_fieldsc$,'ACTION_10')
15271   let edimatrx_forw =srch(mat edimatrx_fieldsc$,'FORW')
15272   let edimatrx_description =srch(mat edimatrx_fieldsc$,'DESCRIPTION')
15273   let edimatrx_action =srch(mat edimatrx_fieldsc$,'ACTION')
15274   let edimatrx_result =srch(mat edimatrx_fieldsc$,'RESULT')
15275   let edimatrx_sql_field =srch(mat edimatrx_fieldsc$,'SQL_FIELD')
15284 end if  ! ~setup_sql_edimatrx
15286 return  ! /r
15288 SETUP_SQL_HLPLNK1: ! r:
15290 if ~setup_sql_hlplnk1 then 
15292   let setup_sql_hlplnk1=1
15294   dim hlplnk1_data$(1)*128,hlplnk1_data(1),hlplnk1_fieldsc$(1)*20,hlplnk1_fieldsn$(1)*20,hlplnk1_formc$*512,hlplnk1_formn$*512,hlplnk1_formall$*1024
15296   let fngetform("HlpLnk1",mat hlplnk1_data$,mat hlplnk1_data,mat hlplnk1_fieldsc$,mat hlplnk1_fieldsn$,hlplnk1_formc$,hlplnk1_formn$)
15298   let hlplnk1_formall$=fngetformall$
15300   let hlplnk1_file_path =srch(mat hlplnk1_fieldsc$,'FILE_PATH')
15302   let hlplnk1_title=srch(mat hlplnk1_fieldsc$,'TITLE')
15304   let hlplnk1_pk =srch(mat hlplnk1_fieldsc$,'PK')
15306 end if  ! ~setup_sql_HlpLnk1
15308 return  ! /r
15310 SETUP_SQL_HLPLNK2: ! r:
15312 if ~setup_sql_hlplnk2 then 
15314   let setup_sql_hlplnk2=1
15316   dim hlplnk2_data$(1)*80,hlplnk2_data(1),hlplnk2_fieldsc$(1)*20,hlplnk2_fieldsn$(1)*20,hlplnk2_formc$*512,hlplnk2_formn$*512,hlplnk2_formall$*1024
15318   let fngetform("HlpLnk2",mat hlplnk2_data$,mat hlplnk2_data,mat hlplnk2_fieldsc$,mat hlplnk2_fieldsn$,hlplnk2_formc$,hlplnk2_formn$)
15320   let hlplnk2_formall$=fngetformall$
15322   let hlplnk2_pk =srch(mat hlplnk2_fieldsc$,'PK')
15324   let hlplnk2_keyword=srch(mat hlplnk2_fieldsc$,'KEYWORD')
15326 end if  ! ~setup_sql_HlpLnk2
15328 return  ! /r
15330 SETUP_SQL_INTERNAL: ! r:
15332 if ~setup_sql_internal then 
15334   let setup_sql_internal=1
15336   dim internal_data$(1)*80,internal_data(1),internal_fieldsc$(1)*20,internal_fieldsn$(1)*20,internal_formc$*512,internal_formn$*512,internal_formall$*1024
15338   let fngetform("Internal",mat internal_data$,mat internal_data,mat internal_fieldsc$,mat internal_fieldsn$,internal_formc$,internal_formn$)
15340   let internal_formall$=fngetformall$
15342   let internal_acct_no=srch(mat internal_fieldsc$,'ACCT_NO')
15346 end if  ! ~setup_sql_Internal
15348 return  ! /r
15350 SETUP_SQL_ATTYFILE: ! r:
15352 if ~setup_sql_attyfile then 
15354   let setup_sql_attyfile=1
15356   dim attyfile_data$(1)*80,attyfile_data(1),attyfile_fieldsc$(1)*20,attyfile_fieldsn$(1)*20,attyfile_formc$*512,attyfile_formn$*512,attyfile_formall$*1024
15358   let fngetform("AttyFile",mat attyfile_data$,mat attyfile_data,mat attyfile_fieldsc$,mat attyfile_fieldsn$,attyfile_formc$,attyfile_formn$)
15360   let attyfile_formall$=fngetformall$
15362   let attyfile_atty_no=srch(mat attyfile_fieldsn$,'ATTY_NO')
15364   let attyfile_name=srch(mat attyfile_fieldsc$,'NAME')
15366   let attyfile_addr=srch(mat attyfile_fieldsc$,'ADDR')
15368   let attyfile_csz=srch(mat attyfile_fieldsc$,'CSZ')
15370   let attyfile_bar=srch(mat attyfile_fieldsc$,'BAR')
15372   let attyfile_init=srch(mat attyfile_fieldsc$,'INIT')
15374   let attyfile_firm_name=srch(mat attyfile_fieldsc$,'FIRM_NAME')
15376   let attyfile_firm_phone=srch(mat attyfile_fieldsc$,'FIRM_PHONE')
15378   let attyfile_firm_fax=srch(mat attyfile_fieldsc$,'FIRM_FAX')
15380   let attyfile_atty_key=srch(mat attyfile_fieldsc$,'ATTY_KEY')
15382   let attyfile_email=srch(mat attyfile_fieldsc$,'EMAIL')
15384   let attyfile_home_page=srch(mat attyfile_fieldsc$,'HOME_PAGE')
15386   let attyfile_phone_ext=srch(mat attyfile_fieldsc$,'PHONE_EXT')
15388 end if  ! ~setup_sql_attyfile
15390 return  ! /r
15600 def fn_setup_sql_diaryint
15610   if ~setup_sql_diaryint then 
15620     let setup_sql_diaryint=1
15630     dim diaryint_data$(1)*60,diaryint_data(1),diaryint_fieldsc$(1)*20,diaryint_fieldsn$(1)*20,diaryint_formall$*512 ! , diaryint_fc$(1,3)*80,diaryint_fn$(1,3)*80,diaryint_desc_c$(1)*80,diaryint_desc_n$(1)*80,diaryint_seq$(1)*80,diaryint_valid$(1)*80
15640     let fnsql_setup('DiaryInt',mat diaryint_data$,mat diaryint_data,mat diaryint_fieldsc$,mat diaryint_fieldsn$,diaryint_formall$) ! , mat diaryint_fc$,mat diaryint_fn$,mat diaryint_desc_c$,mat diaryint_desc_n$,mat diaryint_seq$,mat diaryint_valid$)
15642     let diaryint_fileno=srch(mat diaryint_fieldsc$,"FILENO")
15644     let diaryint_code_alpha=srch(mat diaryint_fieldsc$,"CODE_ALPHA")
15646     let diaryint_date=srch(mat diaryint_fieldsc$,"DATE")
15648     let diaryint_comment=srch(mat diaryint_fieldsc$,"COMMENT")
15650     let diaryint_queue=srch(mat diaryint_fieldsc$,"QUEUE")
15652     let diaryint_time=srch(mat diaryint_fieldsc$,"TIME")
15654     let diaryint_code=srch(mat diaryint_fieldsn$,"CODE")
15656     let diaryint_priority=srch(mat diaryint_fieldsn$,"PRIORITY")
15658   end if  ! ~setup_sql_diaryint
15660 fnend  ! fn_setup_sql_diaryint
15670 def fn_setup_sql_dchanges
15680   if ~setup_sql_dchanges then 
15690     let setup_sql_dchanges=1
15700     dim dchanges_data$(1)*60,dchanges_data(1),dchanges_fieldsc$(1)*20,dchanges_fieldsn$(1)*20,dchanges_formall$*512 ! , dchanges_fc$(1,3)*80,dchanges_fn$(1,3)*80,dchanges_desc_c$(1)*80,dchanges_desc_n$(1)*80,dchanges_seq$(1)*80,dchanges_valid$(1)*80
15702     let fnsql_setup('DChanges',mat dchanges_data$,mat dchanges_data,mat dchanges_fieldsc$,mat dchanges_fieldsn$,dchanges_formall$) ! , mat dchanges_fc$,mat dchanges_fn$,mat dchanges_desc_c$,mat dchanges_desc_n$,mat dchanges_seq$,mat dchanges_valid$)
15704     let dchanges_fileno=srch(mat dchanges_fieldsc$,"FILENO")
15706     let dchanges_type=srch(mat dchanges_fieldsc$,"TYPE")
15708     let dchanges_code_alpha=srch(mat dchanges_fieldsc$,"CODE_ALPHA")
15710     let dchanges_date=srch(mat dchanges_fieldsc$,"DATE")
15712     let dchanges_comment=srch(mat dchanges_fieldsc$,"COMMENT")
15714     let dchanges_queue =srch(mat dchanges_fieldsc$,"QUEUE")
15716     let dchanges_time=srch(mat dchanges_fieldsc$,"TIME")
15718     let dchanges_trans_type=srch(mat dchanges_fieldsc$,"TRANS_TYPE")
15720     let dchanges_user_init=srch(mat dchanges_fieldsc$,"USER_INIT")
15722     let dchanges_llcode=srch(mat dchanges_fieldsc$,"LLCODE")
15724     let dchanges_method=srch(mat dchanges_fieldsc$,"METHOD")
15726     let dchanges_code=srch(mat dchanges_fieldsn$,"CODE")
15728     let dchanges_priority=srch(mat dchanges_fieldsn$,"PRIORITY")
15730     let dchanges_trans_date=srch(mat dchanges_fieldsn$,"TRANS_DATE")
15732     let dchanges_trans_time=srch(mat dchanges_fieldsn$,"TRANS_TIME")
15734     let dchanges_user_id=srch(mat dchanges_fieldsn$,"USER_ID")
15736     let dchanges_recno=srch(mat dchanges_fieldsn$,"RECNO")
15738   end if  ! ~setup_sql_dchanges
15740 fnend  ! fn_setup_sql_dchanges
15742 def fn_setup_sql_status
15744   if ~setup_sql_status then 
15746     let setup_sql_status=1
15748     dim status_data$(1)*60,status_data(1),status_fieldsc$(1)*20,status_fieldsn$(1)*20,status_formall$*512 ! , status_fc$(1,3)*80,status_fn$(1,3)*80,status_desc_c$(1)*80,status_desc_n$(1)*80,status_seq$(1)*80,status_valid$(1)*80
15750     let fnsql_setup('status',mat status_data$,mat status_data,mat status_fieldsc$,mat status_fieldsn$,status_formall$) ! , mat status_fc$,mat status_fn$,mat status_desc_c$,mat status_desc_n$,mat status_seq$,mat status_valid$)
15752     let status_code=srch(mat status_fieldsc$,"CODE")
15754     let status_description=srch(mat status_fieldsc$,"DESCRIPTION")
15756   end if  ! ~setup_sql_status
15758 fnend  ! fn_setup_sql_status
15760 def fn_setup_sql_diary
15762   if ~setup_sql_diary then 
15764     let setup_sql_diary=1
15766     dim diary_data$(1)*60,diary_datan(1),diary_fieldsc$(1)*20,diary_fieldsn$(1)*20,diary_formall$*512
15768     let fnsql_setup('diary',mat diary_data$,mat diary_datan,mat diary_fieldsc$,mat diary_fieldsn$,diary_formall$)
15770 ! r: characters
15772     let diary_diary_des=srch(mat diary_fieldsc$,"DIARY_DES")
15774     let diary_document01=srch(mat diary_fieldsc$,"DOCUMENT01")
15776     let diary_document02=srch(mat diary_fieldsc$,"DOCUMENT02")
15778     let diary_document03=srch(mat diary_fieldsc$,"DOCUMENT03")
15780     let diary_document04=srch(mat diary_fieldsc$,"DOCUMENT04")
15782     let diary_document05=srch(mat diary_fieldsc$,"DOCUMENT05")
15784     let diary_document06=srch(mat diary_fieldsc$,"DOCUMENT06")
15786     let diary_document07=srch(mat diary_fieldsc$,"DOCUMENT07")
15788     let diary_document08=srch(mat diary_fieldsc$,"DOCUMENT08")
15790     let diary_document09=srch(mat diary_fieldsc$,"DOCUMENT09")
15792     let diary_document10=srch(mat diary_fieldsc$,"DOCUMENT10")
15794     let diary_autodel=srch(mat diary_fieldsc$,"AUTODEL")
15796     let diary_queue=srch(mat diary_fieldsc$,"QUEUE")
15798     let diary_protected=srch(mat diary_fieldsc$,"PROTECTED")
15800 ! /r
15802 ! r: numbers
15804     let diary_finan01=srch(mat diary_fieldsn$,"FINAN01")
15806     let diary_finan02=srch(mat diary_fieldsn$,"FINAN02")
15808     let diary_finan03=srch(mat diary_fieldsn$,"FINAN03")
15810     let diary_finan04=srch(mat diary_fieldsn$,"FINAN04")
15812     let diary_finan05=srch(mat diary_fieldsn$,"FINAN05")
15814     let diary_finan06=srch(mat diary_fieldsn$,"FINAN06")
15816     let diary_finan07=srch(mat diary_fieldsn$,"FINAN07")
15818     let diary_finan08=srch(mat diary_fieldsn$,"FINAN08")
15820     let diary_finan09=srch(mat diary_fieldsn$,"FINAN09")
15822     let diary_finan10=srch(mat diary_fieldsn$,"FINAN10")
15824     let diary_recno=srch(mat diary_fieldsn$,"RECNO")
15826     let diary_span=srch(mat diary_fieldsn$,"SPAN")
15828 ! /r
15830   end if  ! ~setup_sql_diary
15832 fnend  ! fn_setup_sql_diary
15840 ! #### Reserved for FN_Setup_SQL Routines
15850 ! #### Reserved for FN_Setup_SQL Routines
15860 ! #### Reserved for FN_Setup_SQL Routines
15870 ! #### Reserved for FN_Setup_SQL Routines
15880 ! #### Reserved for FN_Setup_SQL Routines
15890 ! #### Reserved for FN_Setup_SQL Routines
15900 def fnrchar$*512(var$*512,ln)
15902   if rtrm$(uform$)<>"" then let lnu=val(uform$) conv L15906 else goto L15906
15904   if lnu<>0 then let ln=lnu
15906 L15906: let fnrchar$=lpad$(rtrm$(var$(1:ln)),ln)
15908 fnend 
15910 def library fnrecord_len
15912   let fnrecord_len=record_len
15914 fnend 
15920 def fnqueue$(queue$*8,venue,sher,forw,masco,atty_no,para_no,collector_no,sales_no) !:
        ! Calculate Default Queue Information
15922   if ~user_setup then let fnget_user
15924   if trim$(queue$)="" then let queue$=user_queue$
15925   if trim$(queue$)="" then let queue$='QID'&fncnv_$('PIC(#####)',user)
15926   let fnrque$(queue$,'QID#####','QID'&fncnv_$('PIC(#####)',user)) !:
        let fnrque$(queue$,'QID####','QID'&fncnv_$('PIC(####)',user)) !:
        let fnrque$(queue$,'QID###','QID'&fncnv_$('PIC(###)',user))
15928   let fnrque$(queue$,'QFRW####','QFRW'&fncnv_$('PIC(####)',forw)) !:
        let fnrque$(queue$,'QFW#####','QFW'&fncnv_$('PIC(#####)',forw)) !:
        let fnrque$(queue$,'QFW####','QFW'&fncnv_$('PIC(####)',forw)) !:
        let fnrque$(queue$,'QF#####','QF'&fncnv_$('PIC(#####)',forw)) !:
        let fnrque$(queue$,'QF####','QF'&fncnv_$('PIC(####)',forw))
15930   let fnrque$(queue$,'QCO####','QCO'&fncnv_$('PIC(####)',masco)) !:
        let fnrque$(queue$,'QVENU###','QVENU'&fncnv_$('PIC(###)',venue)) !:
        let fnrque$(queue$,'QVEN####','QVEN'&fncnv_$('PIC(####)',venue)) !:
        let fnrque$(queue$,'QVEN###','QVEN'&fncnv_$('PIC(###)',venue)) !:
        let fnrque$(queue$,'QV#####','QV'&fncnv_$('PIC(#####)',venue)) !:
        let fnrque$(queue$,'QV####','QV'&fncnv_$('PIC(####)',venue)) !:
        let fnrque$(queue$,'QSHR####','QSHR'&fncnv_$('PIC(####)',sher)) !:
        let fnrque$(queue$,'QSH####','QSH'&fncnv_$('PIC(####)',sher)) !:
        let fnrque$(queue$,'QSHER###','QSHER'&fncnv_$('PIC(###)',sher))
15932   let fnrque$(queue$,'QCOL####','QCOL'&fncnv_$('PIC(####)',collector_no)) !:
        let fnrque$(queue$,'QCOLL###','QCOLL'&fncnv_$('PIC(###)',collector_no)) !:
        let fnrque$(queue$,'QCOL###','QCOL'&fncnv_$('PIC(###)',collector_no)) !:
        let fnrque$(queue$,'QCOLL##','QCOLL'&fncnv_$('PIC(##)',collector_no)) !:
        let fnrque$(queue$,'QCOL##','QCOL'&fncnv_$('PIC(##)',collector_no))
15934   let fnrque$(queue$,'QCL####','QCL'&fncnv_$('PIC(####)',collector_no)) !:
        let fnrque$(queue$,'QC####','QC'&fncnv_$('PIC(####)',collector_no)) !:
        let fnrque$(queue$,'QC###','QC'&fncnv_$('PIC(###)',collector_no)) !:
        let fnrque$(queue$,'QC##','QC'&fncnv_$('PIC(##)',collector_no))
15936   let fnrque$(queue$,'QPARA###','QPARA'&fncnv_$('PIC(###)',para_no)) !:
        let fnrque$(queue$,'QATTY###','QATTY'&fncnv_$('PIC(###)',atty_no)) !:
        let fnrque$(queue$,'QPARA##','QPARA'&fncnv_$('PIC(##)',para_no)) !:
        let fnrque$(queue$,'QATTY##','QATTY'&fncnv_$('PIC(##)',atty_no)) !:
        let fnrque$(queue$,'QSALE###','QSALE'&fncnv_$('PIC(###)',sales_no)) !:
        let fnrque$(queue$,'QSALE##','QSALE'&fncnv_$('PIC(##)',sales_no)) !:
        let fnrque$(queue$,'QSALES##','QSALES'&fncnv_$('PIC(##)',sales_no))
15950   let fnqueue$=queue$
15952 fnend 
15960 def library fnque$(queue$*8,venue,sher,forw,masco,atty_no,para_no,collector_no,sales_no)
15962   let fnque$=fnqueue$(queue$,venue,sher,forw,masco,atty_no,para_no,collector_no,sales_no)
15964 fnend 
15970 def fnrque$(&queue$,fque$,tque$)
15972   let queue$=srep$(trim$(queue$),fque$,tque$)
15974 fnend 
15980 def library fnsql_queue$(queue$*8,mat master_data$,mat master_data,mat master_fieldsc$,mat master_fieldsn$)
15982   if ~master_common then let fnmaster_common
15984   let fnsql2_master !:
        ! POPULATE VALUES FROM SQL TO THE "LOCAL" VARIABLES
15986   let fnsql_queue$=fnqueue$(queue$,venue,sher,forw,masco,atty_no,para_no,collector_no,sales_no)
15988 fnend 
16000 def fnmaster_common
16002   dim master_filerec(20),master_frec(80),filerec(20),frec(80),jdate$*10,rates(2)
16004   let master_common=1 !:
        let master_fileno=fnc("FILENO") !:
        let master_forw_no=fnn("FORW_NO") !:
        let master_venue1_no=fnn("VENUE1_NO") !:
        let master_sher_no=fnn("SHER_NO") !:
        let master_coco_no=fnn("COCO_NO") !:
        let master_atty=fnn("ATTY") !:
        let master_para=fnn("PARA") !:
        let master_collector=fnn("COLLECTOR") !:
        let master_sales_no=fnn("SALES_NO")
16006   let master_filerec(1)=fnn("ORIG_CLAIM") !:
        let master_filerec(2)=fnn("SUIT_AMT") !:
        let master_filerec(3)=fnn("STAT_FEE") !:
        let master_filerec(4)=fnn("JMT_AMT") !:
        let master_filerec(5)=fnn("BALANCE") !:
        let master_filerec(6)=fnn("COST_BAL") !:
        let master_filerec(7)=fnn("COLL_HOLD") !:
        let master_filerec(8)=fnn("PRIN_COLL") !:
        let master_filerec(9)=fnn("INT_COLL")
16008   let master_filerec(10)=fnn("MERCH_BEF") !:
        let master_filerec(11)=fnn("MERCH_POST") !:
        let master_filerec(12)=fnn("CASH_BEF") !:
        let master_filerec(13)=fnn("CASH_POST") !:
        let master_filerec(14)=fnn("COST_RECEIVED") !:
        let master_filerec(15)=fnn("COST_RET") !:
        let master_filerec(16)=fnn("COST_EXP") !:
        let master_filerec(17)=fnn("COST_RECOVERED") !:
        let master_filerec(18)=fnn("COMM_EARN") !:
        let master_filerec(19)=fnn("SFEE_EARN") !:
        let master_filerec(20)=fnn("STAT_EARN")
16010   let master_frec(1)=fnn("COST_POST_JUDG") !:
        let master_frec(2)=fnn("AFFIDAVIT") !:
        let master_frec(3)=fnn("PAID_POST_JUDG") !:
        let master_frec(4)=fnn("NON_RCVRD_COST") !:
        let master_frec(5)=fnn("TOT_EXP_COST") !:
        let master_frec(6)=fnn("DP_PRE_SUIT_NF") !:
        let master_frec(7)=fnn("DP_POST_SUIT_NF") !:
        let master_frec(8)=fnn("DP_POST_JUDG_NF") !:
        let master_frec(9)=fnn("MERCH_POST_JUDG") !:
        let master_frec(10)=fnn("EXP_COST") !:
        let master_frec(11)=fnn("DP_PRE_SUIT") !:
        let master_frec(12)=fnn("DP_POST_SUIT") !:
        let master_frec(13)=fnn("DP_POST_JUDG") !:
        let master_frec(14)=fnn("ACCR_INT_BEF") !:
        let master_frec(27)=fnn("CONTRACT_COLL") !:
        let master_frec(28)=fnn("FEES_COLL")
16012   let master_frec(41)=fnn("PER_DIEM_DATE") !:
        let master_frec(42)=fnn("PER_DIEM_AMT") !:
        let master_frec(43)=fnn("PER_DIEM_RATE") !:
        let master_frec(44)=fnn("PER_DIEM_BASE") !:
        let master_frec(45)=fnn("PER_DIEM_INT")
16014   let master_contract_fee=fnn("CONTRACT_FEE")
16016   let master_accr_int_bef=fnn("ACCR_INT_BEF")
16018   let master_suit_date=srch(mat master_fieldsc$,"SUIT_DATE") !:
        let master_jmt_date=srch(mat master_fieldsc$,"JMT_DATE") !:
        let master_d1_cs=srch(mat master_fieldsc$,"D1_CS") !:
        let master_collord=srch(mat master_fieldsc$,"COLLORD")
16020   let master_idate=srch(mat master_fieldsc$,"INT_DATE") ! should be Master_INT_DATE, but use Master_IDATE instead
16022   let master_rates(1)=srch(mat master_fieldsn$,"PRE_J_RATE") !:
        let master_rates(2)=srch(mat master_fieldsn$,"POST_J_RATE")
16024   let master_stored_int=srch(mat master_fieldsn$,("STORED_INT"))
16026   let master_stat_fee=srch(mat master_fieldsn$,("STAT_FEE"))
16028   let master_stat_earn=srch(mat master_fieldsn$,("STAT_EARN"))
16030   let master_cost_recovered=srch(mat master_fieldsn$,("COST_RECOVERED"))
16032   let master_cost_exp=srch(mat master_fieldsn$,("COST_EXP"))
16034   let master_per_diem_date=srch(mat master_fieldsn$,("PER_DIEM_DATE")) !:
        let master_per_diem_amt=srch(mat master_fieldsn$,("PER_DIEM_AMT")) !:
        let master_per_diem_rate=srch(mat master_fieldsn$,("PER_DIEM_RATE")) !:
        let master_per_diem_base=srch(mat master_fieldsn$,("PER_DIEM_BASE")) !:
        let master_per_diem_int=srch(mat master_fieldsn$,("PER_DIEM_INT"))
16040 fnend 
16050 def fnis_date_field(field_name$*20)
16052   let field_name$=trim$(uprc$(field_name$)) !:
        let field_name$=srep$(field_name$,"-","_")
16054   if field_name$="DATE" or pos(field_name$,"_DATE")>0 or pos(field_name$,"DATE_")>0 then 
16056     let fnis_date_field=1
16058   end if 
16059 fnend 
16060 ! ------------------------FNGETFORM-----------------------------------
16062 def fngetform(filename$*80,mat data$,mat data,mat fieldsc$,mat fieldsn$,&form_c$,&form_n$)
16064   dim unpack_c$*2048,unpack_n$*2048
16066   dim form$*4096, form1$*4096, f$(999)*30,f_name$(999)*40, f_pos(999), f_len(999), f_type$(999)*20, line$*150,form_c$*4096,form_n$*4096
16068 ! mat DATA$(1)=("") !:
        ! mat DATA(1)=(0) !:
        mat fieldsc$(1)=("Unknown") !:
        mat fieldsn$(1)=("Unknown") !:
        let form_c$="FORM POS 1,C 1" !:
        let form_n$="FORM POS 1,BH 1" !:
        ! ** Note: Don't erase the data, it causes problems!
16070   let filename$=uprc$(filename$)
16072   if filename$='COLLTRAN' or filename$='COSTTRAN' or uprc$(filename$)='FEETRAN' then let filename$='TRANBILL'
16074   if filename$='SCREEN7' then !:
          let form_file=fngetdisplay_(fn_screen7_sql$) !:
        else !:
          let form_file=fngetdisplay_(filename$&"/SQL")
16080   if form_file<=0 then !:
          print "WARNING FNGETFORM$ PASSED INVALID FILE:";filename$ !:
          let kstat$(1) !:
          goto L16164
16082   let form$="FORM " !:
        let form1$="FORM "
16084   let c_count=0: let n_count=0
16086   let field_count=1 !:
        let record_len=0
16088   let last_position=last_position1=last_length=last_length1=0
16090 L16090: linput #form_file: line$ eof L16144 !:
        if trim$(line$)="" then goto L16090
16092   let f$(field_count)=trim$(line$(1:29))
16094   let f_name$(field_count)=trim$(line$(31:66))
16096   let f_pos(field_count)=val(line$(68:74))
16098   let f_len(field_count)=val(line$(77:83))
16100   let f_type$(field_count)=trim$(line$(86:102))
16102   if record_len<f_pos(field_count)+f_len(field_count) then let record_len=f_pos(field_count)+f_len(field_count)
16110   if uprc$(f_type$(field_count))="X" then goto L16090 !:
          !  ** X is filler, simply ignore !
16112   if f_type$(field_count)(1:1)="C" then !:
          goto L16120 else !:
          if f_type$(field_count)="PIC(##/##/##)" or f_type$(field_count)="PIC(########)" or f_type$(field_count)="PIC(####/##/##)" then !:
            goto L16124 else !:
            goto L16128
16120 L16120: let c_count+=1 : mat fieldsc$(c_count) !:
        let fieldsc$(c_count)=f$(field_count) !:
        if last_position+last_length<>f_pos(field_count) then !:
          let form$=form$&"POS "&str$(f_pos(field_count))&","&f_type$(field_count)&" "&str$(f_len(field_count))&"," else !:
          let form$=form$&f_type$(field_count)&" "&str$(f_len(field_count))&","
16122   goto L16132
16124 L16124: let c_count+=1 : mat fieldsc$(c_count): let fieldsc$(c_count)=f$(field_count) !:
        if last_position+last_length<>f_pos(field_count) then !:
          let form$=form$&"POS "&str$(f_pos(field_count))&","&f_type$(field_count)&"," else !:
          let form$=form$&f_type$(field_count)&","
16126   goto L16132
16128 L16128: if f_type$(field_count)(1:3)="PIC" or f_type$(field_count)="L" then !:
          let num_field$=f_type$(field_count) else !:
          let num_field$=f_type$(field_count)&" "&str$(f_len(field_count))
16130   let n_count+=1: mat fieldsn$(n_count): let fieldsn$(n_count)=f$(field_count) !:
        if last_position1+last_length1<>f_pos(field_count) then !:
          let form1$=form1$&"POS "&str$(f_pos(field_count))&","&num_field$&"," else let form1$=form1$&num_field$&","
16132 L16132: if f_type$(field_count)(1:1)="C" then !:
          let last_position=f_pos(field_count): let last_length=f_len(field_count) else !:
          if f_type$(field_count)="PIC(##/##/##)" or f_type$(field_count)="PIC(########)" or f_type$(field_count)="PIC(####/##/##)" then !:
            let last_position=f_pos(field_count): let last_length=f_len(field_count) else !:
            let last_position1=f_pos(field_count): let last_length1=int(f_len(field_count))
16140 ! PAUSE
16142   let field_count+=1 !:
        if field_count>999 then goto L16144 else goto L16090
16144 L16144: let n_selected=c_count: let n_selected1=n_count
16146   let form$=form$(1:len(form$)-1)
16148   let form1$=form1$(1:len(form1$)-1)
16150   mat data$(n_selected) : mat data(n_selected1)
16152   close #form_file: 
16154   if trim$(filename$)="NJ_SUIT" then !:
          let form_c$="POS 1,C 1" !:
          let form_n$="POS 1,N 1" !:
          goto L16164 ! Not a CLS Internal Data File, Form Statement is not relevant
16160   let unpack_c$=fnpackform$(form$,0) !:
        let form_c$=fnpackform$(form$,1)
16162   let unpack_n$=fnpackform$(form1$,0) !:
        let form_n$=fnpackform$(form1$,1)
16164 L16164: fnend 
16170 ! ---------LIBRARY-------FNGETFORM$------------------------------------
16172 def library fnget_form(filename$*80,mat data$,mat data,mat fieldsc$,mat fieldsn$,&form_c$,&form_n$)
16174   let fnget_form=fngetform(filename$,mat data$,mat data,mat fieldsc$,mat fieldsn$,form_c$,form_n$)
16176 fnend 
16180 ! -------------------------FNGETKEY------------------------------------
16182 ! 
16184 def fngetkey(fileno,key$*128,mat data$,mat data,&fformc$,&fformn$)
16186 ! FileNo = Open File Handle to read from !:
        ! Key$ = Key to use !:
        ! mat Data$ and mat Data = returned values from read !:
        ! FFormC$ and FFormN$ = Form statements for Strings and Numbers
16188   let getkey=0
16190   mat data$=('') : mat data=(0)
16192   read #fileno,using fformc$,key=key$,release: mat data$ ioerr L16196 !:
        let getkey=1
16194   reread #fileno,using fformn$,release: mat data ioerr L16196 !:
        goto L16198
16196 L16196: let getkey=-err
16198 L16198: let fngetkey=getkey
16199 fnend 
16200 ! ---------LIBRARY-------FNGETKEY-------------------------------------
16202 def library fnget_key(fileno,key$*40,mat data$,mat data,&fformc$,&fformn$)
16204   let fnget_key=fngetkey(fileno,key$,mat data$,mat data,fformc$,fformn$)
16206 fnend 
16210 ! ------------------------FNGETFIELD----------------------------------
16212 ! 
16214 def fngetfield(field$,mat d$,mat d,mat _fc$,mat _fn$)
16216   let field_pos=srch(mat _fn$,field$) !:
        if field_pos>0 then !:
          let fngetfield=d(field_pos) !:
          goto L16219
16218   let field_pos=srch(mat _fc$,field$) !:
        if field_pos>0 then !:
          let fngetfield=val(d$(field_pos)) conv L16219 !:
          goto L16219
16219 L16219: fnend 
16220 ! ---------LIBRARY--------FNGETFIELD-----------------------------------
16222 def library fnget_field(field$,mat d$,mat d,mat _fc$,mat _fn$)
16224   let fnget_field=fngetfield(field$,mat d$,mat d,mat _fc$,mat _fn$)
16226 fnend 
16230 ! --------------------------FNGETFIELD$-------------------------------
16235 def fngetfield$*80(field$,mat d$,mat d,mat _fc$,mat _fn$)
16240   let field_pos=srch(mat _fc$,field$) !:
        if field_pos>0 then !:
          goto L16245 else !:
          goto L16250
16245 L16245: if pos(trim$(_fc$(field_pos)),"DATE")>0 then !:
          let fngetfield$=fnget_date10$(d$(field_pos)) !:
          goto L16260 else !:
          let fngetfield$=d$(field_pos) !:
          goto L16260
16250 L16250: let field_pos=srch(mat _fn$,field$) !:
        if field_pos>0 then !:
          goto L16255 else !:
          goto L16260
16255 L16255: if pos(trim$(_fn$(field_pos)),"DATE")>0 then !:
          let fngetfield$=fnget_date10$(str$(d(field_pos))) !:
          goto L16260 else !:
          let fngetfield$=str$(d(field_pos)) !:
          goto L16260
16260 L16260: fnend 
16270 ! ---------LIBRARY--------FNGETFIELD$----------------------------------
16272 def library fnget_field$*80(field$,mat d$,mat d,mat _fc$,mat _fn$)
16274   on error system 
16276   let fnget_field$=fngetfield$(field$,mat d$,mat d,mat _fc$,mat _fn$)
16278 fnend 
16280 ! ---------------------- FNUNPACK$-----------------------------------
16282 def library fnunpack$(&form1$,&form2$)
16284   let form1$=unpack_c$ !:
        let form2$=unpack_n$
16286 fnend 
16290 def fngetformall$*2048
16292   let npos=pos(unpack_n$," ") !:
        let fngetformall$=cform$(trim$(unpack_c$)&","&trim$(unpack_n$)(npos+1:9999))
16294 fnend 
16300 def library fnget_formall$*2048
16302   let fnget_formall$=fngetformall$
16304 fnend 
16310 ! ------------------------FNPACKFORM$---------------------------------
16312 def library fnpack_form$*1024(f$*2048;pack_type)
16314   let fnpack_form$=fnpackform$(f$,pack_type)
16316 fnend 
16320 def fnpackform$*2048(f$*2048,pack_type)
16322 ! PACK_TYPE=0 - USE CFORM TO COMPILE !:
        ! PACK_TYPE=1 DO NOT USE CFORM TO COMPILE
16324   let f$=srep$(f$,"PIC(##/##/##)","C 8") !:
        let f$=srep$(f$,"PIC(########)","C 8") !:
        let f$=srep$(f$,"PIC(####/##/##)","C 10")
16326   dim temp$(350)*50,tf$*2048,previous$*256
16328   let tf$="": let count=1: let previous$=""
16330   let i=1: mat temp$=("")
16340   do while len(f$)>0
16342     let form_comma_pos=pos(f$&",",",") !:
          if form_comma_pos=0 then !:
            goto L16370
16344     if form_comma_pos>0 then !:
            let temp$(i)=f$(1:form_comma_pos-1) !:
            let f$=f$(form_comma_pos+1:9999)
16346     if i=1 then let tf$=temp$(i): let i+=1: goto L16360
16348     if temp$(i)=previous$ then let count+=1 : goto L16356
16350     if previous$(1:3)="POS" then let tf$(9999:0)=","&previous$: goto L16356
16352     if i=2 then goto L16356
16354     if count=1 then !:
            let tf$(9999:0)=","&previous$ else !:
            let tf$(9999:0)=","&str$(count)&"*"&previous$: let count=1
16356 L16356: let i+=1
16358     let previous$=temp$(i-1)
16360 L16360: loop 
16370 L16370: if count=1 then !:
          let tf$(9999:0)=","&previous$&","&f$ else !:
          let tf$(9999:0)=","&str$(count)&"*"&previous$&","&f$
16372   let tf$=srep$(tf$,",N 2,2*BH 3,PD 6.2,N 2,2*BH 3,PD 6.2,N 2,2*BH 3,PD 6.2,N 2,2*BH 3,PD 6.2,N 2,2*BH 3,PD 6.2,N 2,2*BH 3,PD 6.2,",",6*(N 2,2*BH 3,PD 6.2),")
16374   let tf$=fnfixrpt$(tf$,"C 8,C 5,6*C 1,C 10,2*C 1,2*C 5,C 1") !:
        let tf$=fnfixrpt$(tf$,"PIC($,$$$,$$$.##),C 1") !:
        let tf$=fnfixrpt$(tf$,"PIC($$,$$$,$$$.##-),C 1") !:
        let tf$=fnfixrpt$(tf$,"PIC(MM/DD/CCYY),C 1") !:
        let tf$=fnfixrpt$(tf$,"C 1,PIC($,$$$,$$$.##-)")
16376   let tf$=fnfixrpt$(tf$,"C 3,C 10,C 4,C 8") !:
        let tf$=fnfixrpt$(tf$,"C 3,C 4") !:
        let tf$=fnfixrpt$(tf$,"C 3,C 8") !:
        let tf$=fnfixrpt$(tf$,"C 1,C 8") !:
        let tf$=fnfixrpt$(tf$,"C 40,C 1")
16378 ! let Tf$=Fnfixrpt$(Tf$,"C 1,2*C 8,3*C 9,C 2")
16380   let tf$=rtrm$(tf$,",")
16382   if trim$(tf$)="FORM" then let fnpackform$="" !:
          goto L16388
16384   if pack_type then !:
          let fnpackform$=cform$(tf$) error L16386 !:
          goto L16388
16386 L16386: let fnpackform$=tf$
16388 L16388: fnend 
16390 def fnfixrpt$*2048(tf$*2048,strip$*256)
16392   let rpt_time=10
16394   do while rpt_time>1 and pos(tf$,","&strip$&",")>0
16396     let tf$=srep$(tf$,","&rpt$(strip$&",",rpt_time),","&str$(rpt_time)&"*("&strip$&"),")
16398   loop while (rpt_time-=1)>1
16400   let fnfixrpt$=tf$
16402 fnend 
16410 ! ---------LIBRARY--------FNSQL_FIELDS---------------------------------
16412 def library fnsql_fields$*2048(lib_sql$*2048,mat data$,mat data,mat _fc$,mat _fn$;filename$*10)
16414   let lib_sql$=uprc$(lib_sql$)
16420   if pos(lib_sql$," IN (") >0 or pos(lib_sql$," IN(") >0 or pos(lib_sql$," BETWEEN") >0 or pos(lib_sql$," LIKE") >0 then !:
          let lib_sql$=fnsqltext$(lib_sql$) !:
          ! CHECK FOR IN'S AND BETWEEN'S
16422   for i=1 to udim(_fc$)
16430     if pos(_fc$(i),"DATE")>0 then goto L16442
16432     let lib_sql$=srep$(lib_sql$,"'"&trim$(_fc$(i))&"'",' "'&trim$(data$(i))&'" ')
16434     let lib_sql$=srep$(lib_sql$,'"'&trim$(_fc$(i))&'"',' "'&trim$(data$(i))&'" ')
16436     let lib_sql$=srep$(lib_sql$," "&trim$(_fc$(i))&" ",' "'&trim$(data$(i))&'" ')
16438     let lib_sql$=srep$(lib_sql$," "&trim$(uprc$(filename$))&"."&trim$(_fc$(i))&" ",' "'&trim$(data$(i))&'" ')
16439     let lib_sql$=srep$(lib_sql$,"'"&trim$(uprc$(filename$))&"."&trim$(_fc$(i))&"'",' "'&trim$(data$(i))&'" ')
16440     goto L16450
16442 L16442: let lib_sql$=srep$(lib_sql$,"'"&trim$(_fc$(i))&"'",' "'&trim$(fnget_date10$(data$(i)))&'" ')
16444     let lib_sql$=srep$(lib_sql$,'"'&trim$(_fc$(i))&'"',' "'&trim$(fnget_date10$(data$(i)))&'" ')
16446     let lib_sql$=srep$(lib_sql$," "&trim$(_fc$(i))&" ",' "'&trim$(fnget_date10$(data$(i)))&'" ')
16448     let lib_sql$=srep$(lib_sql$," "&trim$(uprc$(filename$))&"."&trim$(_fc$(i))&" ",' "'&trim$(fnget_date10$(data$(i)))&'" ')
16450 L16450: next i
16460   for i=1 to udim(_fn$)
16462     if pos(lib_sql$,_fn$(i))<=0 then goto L16478
16464     let lib_sql$=srep$(lib_sql$,"'"&trim$(_fn$(i))&"'","'"&str$(data(i))&"'")
16466     let lib_sql$=srep$(lib_sql$,'"'&trim$(_fn$(i))&'"','"'&str$(data(i))&'"')
16468     let lib_sql$=srep$(lib_sql$," "&trim$(_fn$(i))&" "," "&str$(data(i))&" ")
16470     let lib_sql$=srep$(lib_sql$,"'"&trim$(_fn$(i))&"'","'"&str$(data(i))&"'")
16472     let lib_sql$=srep$(lib_sql$," "&trim$(uprc$(filename$))&"."&trim$(_fn$(i))&" "," "&str$(data(i))&" ")
16474     let lib_sql$=srep$(lib_sql$,"'"&trim$(uprc$(filename$))&"."&trim$(_fn$(i))&"'","'"&str$(data(i))&"'")
16476     let lib_sql$=srep$(lib_sql$,'"'&trim$(uprc$(filename$))&"."&trim$(_fn$(i))&'"','"'&str$(data(i))&'"')
16478 L16478: next i
16480   let fnsql_fields$=srep$(lib_sql$,"' '","'")
16482 ! PRINT LIB_SQL$
16484 fnend 
16490 PAPER: ! 
16492 def library fnpaper$(buff$*9999,pcode$,key$,user,filnum;pdate,ptime$,&paper_lrec)
16494   let fnpaper_$(buff$,pcode$,key$,user,filnum,pdate,ptime$,paper_lrec)
16496 fnend 
16500 def fnpaper_$(&buff$,pcode$,key$,user,filnum;pdate,ptime$,&paper_lrec)
16501   let pcode$=pcode$(1:8)
16502   let paper_lrec=0 ! Clear out Paper_LREC (Will Store the Record to be used by "S-FCode"
16505   dim des1$*49
16510 FACTIV: form c 8,bh 4,bh 4,c 28,c 20,c 8,pos 74,bh 2,2*bh 4,2*bh 4.2
16515   let cr$=chr$(13): let lf$=chr$(10): let tab$=chr$(9) !:
        let crlf$=cr$&lf$
16520   if ~xlate_setup then let fnxlate_setup
16525   let buff$=rtrm$(buff$) !:
        let buff$=trim$(buff$,cr$) !:
        let buff$=trim$(buff$,lf$) !:
        let buff$=srep$(rtrm$(buff$),crlf$,"*[CRLF]*") !:
        let buff$=srep$(rtrm$(buff$),lf$,"*[CRLF]*") !:
        let buff$=srep$(rtrm$(buff$),cr$,"*[CRLF]*")
16530   let buff$=srep$(rtrm$(buff$),tab$,"        ")
16535   let buff$ = xlate$(buff$, data_xlate$)
16536   let paper_lrec:=lrec(filnum)+1 ! Store the 1st Paper_Lrec that will be used by WRITE #filnum
16540 L16540: let buff$=rtrm$(buff$)
16545   let clen=len(buff$): let split=0 !:
        if clen>48 then let split=pos(buff$(1:49)," ",-1)
16550   if split<=0 then let split=48
16555   let _pos_crlf=pos(buff$,"*[CRLF]*")
16560   if _pos_crlf>0 and _pos_crlf<=48 then !:
          let buff$(_pos_crlf:_pos_crlf+7)="" !:
          let split=_pos_crlf-1
16565   if trim$(ptime$)="" then let ptime$=time$
16570   if days(pdate)=0 then let pdate=date("CYMD")
16575   if len(ptime$)=5 and ptime$(3:3)=":" then let ptime$(99:0)=":00"
16580   let des1$=buff$(1:split) !:
        if rln(filnum)>75 then !:
          write #filnum,using FACTIV: key$,date(days(pdate),'CYMD'),fnstime_(ptime$),des1$(21:48),des1$(1:20),pcode$(1:8),user,0,paper_lrec,0,0 else !:
          write #filnum,using FACTIV: key$,date(days(pdate),'CYMD'),fnstime_(ptime$),des1$(21:48),des1$(1:20),pcode$(1:8),user
16585   let buff$(1:split)="" !:
        let buff$=ltrm$(buff$)
16590   if rtrm$(buff$)<>"" then let pcode$="  ''": goto L16540
16595 fnend 
16600 ! ---------LIBRARY--------FNSQL_WHERE---------------------------------
16605 def library fnsql_where(lib_sql$*2048)
16610   let sql_result=0
16615   if lib_sql$(1:4)="ELSE" then let sql_result=1 !:
          goto L16655
16620   on error goto L16645
16625 ! PRINT LIB_SQL$ : PAUSE
16630   if uprc$(env$("DEBUG"))="YES" then print #255: lib_sql$
16635   execute "IF "&lib_sql$(7:9999)&" THEN SQL_RESULT=1"
16640   goto L16650
16645 L16645: print #255: "Error:";err;":";lib_sql$
16650 L16650: on error system 
16655 L16655: let fnsql_where=sql_result
16659 fnend 
16660 def library fnforw_no(xfn_fileno$,xfn_forw_no)
16662   let fnforw_no=fn_forw_no(xfn_fileno$,xfn_forw_no)
16664 fnend  ! fnForw_No
16670 def fn_forw_no(xfn_fileno$,xfn_forw_no)
16672   let xfn_fileno$=uprc$(trim$(xfn_fileno$))
16680   if xfn_fileno$(1:4)="FOW." then let xfn_is_fow=1 else let xfn_is_fow=0
16682   if xfn_fileno$(1:4)="CST." then let xfn_is_cst=1 else let xfn_is_cst=0
16690   if xfn_is_fow or xfn_is_cst then 
16692     let set_fn_forw_no=fnval_(xfn_fileno$(5:8))
16694   else 
16696     let set_fn_forw_no=xfn_forw_no
16698   end if  ! xfn_is_fow or xfn_is_cst   /   else 
16700   if set_fn_forw_no=0 then let set_fn_forw_no=xfn_forw_no ! this line is included for tricky files like FOW.231A (which on Conv IGNORE)
16702   let fn_forw_no=set_fn_forw_no
16704 fnend  ! fn_Forw_No
16710 def library fnfilepath_parse(path_and_file_to_parse$*256, &file_path$, &file_name_base$, &file_name_extension$)
16712   let fnfilepath_parse=fn_filepath_parse(path_and_file_to_parse$, file_path$, file_name_base$, file_name_extension$)
16714 fnend  ! FNFILEPATH_PARSE
16720 def fn_filepath_parse(path_and_file_to_parse$*256, &file_path$, &file_name_base$, &file_name_extension$)
16722   let file_path$=file_name_base$=file_name_extension$=""
16730   if pos(path_and_file_to_parse$,"/")>0 then let path_and_file_to_parse$=os_filename$(path_and_file_to_parse$) ! todo: verify that this line is correct.  it should convert from a path which includes a / to a path which does not.  OS_Filename$ seems to work great, while BR_Filename$ is wrong as it contains WBWIN as a part of the path.
16740   if pos(path_and_file_to_parse$,"%")>0 then 
16742     let pos_percent_1=pos(path_and_file_to_parse$,"%")
16744     let pos_percent_2=pos(path_and_file_to_parse$,"%",pos_percent_1+1)
16746     if pos_percent_1>0 and pos_percent_2>0 then 
16748       let path_and_file_to_parse$(pos_percent_1:pos_percent_2)=env$(path_and_file_to_parse$(pos_percent_1+1:pos_percent_2-1))
16750     end if  ! Pos_Percent_1>0 and Pos_Percent_2>0
16760   end if  ! POS(PATH_AND_FILE_TO_PARSE$,"%")>0
16770   if pos(path_and_file_to_parse$,".")>0 then 
16772     let file_name_extension$=path_and_file_to_parse$(pos(path_and_file_to_parse$,".",-1)+1:len(path_and_file_to_parse$))
16774     let path_and_file_to_parse$=path_and_file_to_parse$(1:pos(path_and_file_to_parse$,".",-1))
16776   end if  ! pos(Path_and_File_To_Parse$,".")=-1
16780   if pos(path_and_file_to_parse$,"\")>0 then 
16782     let file_path$=path_and_file_to_parse$(1:pos(path_and_file_to_parse$,"\",-1)-1)
16784     let path_and_file_to_parse$=path_and_file_to_parse$(pos(path_and_file_to_parse$,"\",-1)+1:len(path_and_file_to_parse$))
16786   else if pos(path_and_file_to_parse$,":")>0 then ! but no \s
16788     let file_path$=path_and_file_to_parse$(1:pos(path_and_file_to_parse$,":"))
16790     let path_and_file_to_parse$=path_and_file_to_parse$(pos(path_and_file_to_parse$,":")+1:len(path_and_file_to_parse$))
16792   end if  ! pos(Path_and_File_To_Parse$,"\")>0     -or-     pos(Path_and_File_To_Parse$,":")>0
16800   let path_and_file_to_parse$=srep$(path_and_file_to_parse$,"[SESSION]",session$) !:
        let path_and_file_to_parse$=srep$(path_and_file_to_parse$,"[WSID]",wsid$)
16802   let file_path$=srep$(file_path$,"[SESSION]",session$) !:
        let file_path$=srep$(file_path$,"[WSID]",wsid$)
16804   let file_name_base$=srep$(file_name_base$,"[SESSION]",session$) !:
        let file_name_base$=srep$(file_name_base$,"[WSID]",wsid$)
16806   let file_name_extension$=srep$(file_name_extension$,"[SESSION]",session$) !:
        let file_name_extension$=srep$(file_name_extension$,"[WSID]",wsid$)
16810   if path_and_file_to_parse$(len(path_and_file_to_parse$):len(path_and_file_to_parse$))="." then let path_and_file_to_parse$=path_and_file_to_parse$(1:len(path_and_file_to_parse$)-1)
16812   let file_name_base$=path_and_file_to_parse$
16814 fnend  ! fn_FilePath_Parse
16820 def library fnvalid_init(init$)
16822   if ~setup_init then let fnsetup_init
16824   let fnvalid_init=srch(init$,rpad$(init$,3))
16826 fnend 
16828 def library fninit$(person) ! Get User Initials
16830   let fninit$=fninit_$(person)
16832 fnend 
16840 def fninit_$(person) ! Get User Initials
16842   if ~setup_init then let fnsetup_init
16844   let person$="" !:
        let person$=init$(person) error L16846
16846 L16846: let fninit_$=rpad$(person$,3)
16848 fnend 
16850 def library fnuser_id(ui_init$)
16852   let fnuser_id=fn_user_id(ui_init$)
16854 fnend  ! Fnuser_ID(Ui_Init$)
16860 def fn_user_id(ui_init$) ! Ui_
16862   if ~setup_init then let fnsetup_init
16864   let fn_user_id=max(0,srch(mat init$,rpad$(uprc$(ui_init$),3)))
16866 fnend  ! fn_User_ID(Ui_Init$) ! Ui_
16870 def fnsetup_init
16872   dim init$(1)*3
16874   let setup_init=1
16880   let userlist_handle=fngethandle_ !:
        open #userlist_handle: "NAME=USERLIST//8,KFNAME=USERLIST.NAM//8,SHR",internal,input,keyed ioerr L16898 !:
        mat init$(lrec(userlist_handle))=("")
16882   for z=1 to lrec(userlist_handle)
16890     read #userlist_handle,using L16892,rec=z: init$(z)
16892 L16892: form pos 21,c 3
16894   next z
16896   close #userlist_handle: 
16898 L16898: fnend 
16900 def library fnpush_init(mat user_init$)
16902   mat init$(udim(user_init$))=user_init$
16904   let setup_init=1
16906 fnend 
16910 def library fnpaper_security(pcode$,mat sec_list$)
16915 ! 1 = Financial Security Problem !:
        ! 2 = Diary Tracking Security Problem !:
        ! 3 = Other Problem
16920   let pcode$=trim$(pcode$) !:
        let pc0de=int(val(pcode$)) conv L16925 !:
        if pc0de>=1 and pc0de<=99 then let fnpaper_security=1 !:
          goto L16940
16925 L16925: if uprc$(pcode$(1:5))="*ADD-" or uprc$(pcode$(1:5))="*DEL-" then !:
          let fnpaper_security=2 !:
          goto L16940
16930   if srch(mat sec_list$,uprc$(pcode$))>0 or srch(mat sec_list$,pcode$)>0 then !:
          let fnpaper_security=3 !:
          goto L16940
16935   if uprc$(pcode$)="*CLAIM" or uprc$(pcode$(1:4))="*PROP" or uprc$(pcode$(1:5))="*PROP" or uprc$(pcode$(1:4))="*DBT" then !:
          let fnpaper_security=4 !:
          goto L16940
16940 L16940: fnend 
16950 def library fncnvdait$(dait)
16952   let fncnvdait$=date$(days(dait)) conv L16954
16954 L16954: fnend 
16956 def library fncnvamt$(amt)
16958   let fncnvamt$=cnvrt$("PIC(-$$$,$$$.##)",amt) conv L16960 !:
        goto L16962
16960 L16960: let fncnvamt$=cnvrt$("PIC(-$$$$$$$.##)",amt) conv L16962
16962 L16962: fnend 
16964 def fncnv_$(pc$*80,amt)
16966   let fncnv_$=cnvrt$(pc$,amt) conv ignore
16968 fnend 
16970 IGNORE: continue 
16980 def library fncnv$(pc$*80,amt)
16985   let fncnv$=cnvrt$(pc$,amt) conv L16990 !:
        goto L17000
16990 L16990: let pc$=srep$(pc$,"$","-") !:
        let pc$=srep$(pc$,",","-")
16995   let fncnv$=cnvrt$(pc$,amt) conv L17000
17000 L17000: fnend 
17010 def library fncnv_cur$(amt)
17012   let fncnv_cur$=cnvrt$("PIC(--,---,---.##)",amt) conv L17014 !:
        goto L17016
17014 L17014: let fncnv_cur$=cnvrt$("PIC(----------.##)",amt) conv L17016
17016 L17016: fnend 
17020 def library fnstrip$(strip$*40)
17022   let fnstrip$=strip$(4:pos(strip$," File")-1)
17024 fnend 
17026 def library fnval(pc$*80)
17028   let fnval=fnval_(pc$)
17030 fnend 
17040 def fnval_(pc$*80)
17042   let fnval_=val(pc$) conv CONV_FNVAL !:
        goto XIT_FNVAL
17044 CONV_FNVAL: ! 
17046   let fnval_=val(srep$(trim$(pc$),"$","")) conv ignore
17048   goto XIT_FNVAL
17050 XIT_FNVAL: ! 
17052 fnend 
17060 def library fndval(pc$*80)
17062   let fndval=val(srep$(pc$,"$","")) conv L17064
17064 L17064: fnend 
17066 def library fnmax_80(max_amt;max_add)
17068   if max_amt+max_add>=80 then let max_amt=80-max_add
17070   let fnmax_80=max_amt
17072 fnend 
17074 def library fnis$(amt)
17076   if amt then let fnis$="*": else let fnis$=" "
17078 fnend 
17080 def library fnisamt$(amt,low,high)
17082   let fnisamt$=fnis_amt$(amt,low,high)
17084 fnend 
17086 def fnis_amt$(amt,low,high)
17088   if amt>=low and amt<=high then let fnis_amt$="*": else let fnis_amt$=" "
17090 fnend 
17100 def library fninp_val(amount$*20)
17102   let amount$=srep$(amount$,"$","") !:
        let amount$=srep$(amount$,",","") !:
        let npos=pos(amount$,".") !:
        if npos<=0 then !:
          let amount$=fncnv_$("N 16.2",fnval_(amount$)/100)
17104   let fninp_val=fnval_(amount$)
17106 fnend 
17110 def library fnreread(phandle,pcode$,ptype$,mat ta_line1,mat ta_line2,&bpj$,&merchandice,&tax_rebate,&tref,&int,&cbal,&coll_hold,&co_fees,&datee,&actual_check,&daily11,&bill$,&sf_out,&comm_out,&sf_c_out,&comm_c_out,&actual_check,mat ta_filerec,&stat_due,&cost_due,&amt_6,&frec_14,&inv$,&invdate$,&invpay,&invver$,&recd,&disb)
17115   if rln(phandle)<150 then !:
          gosub REREAD_FINAN !:
          let fnreread=reread_results !:
          goto L17245 !:
          ! ** After going to reread_finan, simply skip to end of function
17120   mat ta_line1=(0) !:
        mat ta_line2=(0) !:
        mat ta_filerec=(0) !:
        let bpj$=bill$=inv$=invdate$=invver$="" !:
        let merchandice=tax_rebate=tref=int=cbal=coll_hold=co_fees=datee=invpay=0 !:
        let actual_check=daily11=sf_out=comm_out=sf_c_out=comm_c_out=0 !:
        let actual_check=stat_due=cost_due=amt_6=frec_14=recd=disb=invpay=0
17125   if trim$(ptype$)="" then goto L17240
17130   if trim$(pcode$(1:5))="SCAN:" or trim$(ptype$)="L" or trim$(ptype$)="R" then goto L17240 !:
          ! Scans - Ignored for now !:
          ! Document Billing - Ignored for now !:
          ! Call Recordings - Ignored for now
17135   if trim$(ptype$)="A" then goto L17170
17140   if trim$(ptype$)="B" then goto L17175
17145   if trim$(ptype$)="C" then goto L17180
17150   if trim$(ptype$)="S" then goto L17185
17155   if trim$(ptype$)="I" then goto L17190
17160   if trim$(ptype$)="D" or trim$(ptype$)="M" then goto L17240 !:
          ! ** Don't worry about re-reading Demographic Changes
17165   print "Paperless Type:";ptype$;" Is Unkown" !:
        pause 
17170 L17170: reread #phandle,using FA,release: ta_line1(6),bpj$,mat ta_line2(6:7),mat ta_line2(1:2),ta_line2(8),ta_line2(5),ta_line1(3),merchandice,ta_line1(2),tax_rebate,tref,ta_line1(5),int,cbal conv L17195: goto L17195
17175 L17175: reread #phandle,using FB,release: ta_line1(6),bpj$,mat ta_line1(2:3),mat ta_line2(1:2),ta_line2(4),mat ta_line2(7:8),coll_hold,ta_line1(4),co_fees,tref,ta_line1(5),int,cbal,datee,actual_check conv L17195 !:
        let datee=date(datee,"CYMD"): let datee$=date$(datee,"CY/M/D") !:
        goto L17195
17180 L17180: reread #phandle,using FC,release: ta_line2(5),bpj$,daily11,bill$,mat ta_line2(7:8),ta_line1(3),tref,ta_line1(5),int,cbal,sf_out,comm_out,sf_c_out,comm_c_out,actual_check conv L17195: goto L17195
17185 L17185: reread #phandle,using FS,release: int,ta_line1(5),ta_filerec(8),ta_filerec(9),ta_filerec(18),ta_filerec(19),ta_filerec(20),cbal,ta_filerec(16),ta_filerec(17),stat_due,cost_due,ta_filerec(1),ta_filerec(2),ta_filerec(3),ta_filerec(4),amt_6,frec_14 conv L17195: goto L17195
17190 L17190: reread #phandle,using FI,release: ta_line2(1),inv$,invdate$,invpay,invver$,tref,ta_line1(5),int,cbal conv L17195 !:
        goto L17195
17195 L17195: let fnreread=rec(phandle)
17200   let fnfixpd(mat ta_line1) !:
        let fnfixpd(mat ta_line2)
17205   if sf_out<=-2020202 or sf_out>=2020202 then let sf_out=0
17210   if comm_out<=-2020202 or comm_out>=2020202 then let comm_out=0
17215   if sf_c_out<=-2020202 or sf_c_out>=2020202 then let sf_c_out=0
17220   if comm_c_out<=-2020202 or comm_c_out>=2020202 then let comm_c_out=0
17225   let recd=ta_line1(6)
17230   let disb=ta_line1(4)+ta_line2(4)+ta_line2(5)+sf_out+comm_out+sf_c_out+comm_c_out+invpay
17235   if trim$(pcode$)="2" then let disb+=sum(mat ta_line2(1:2))+ta_line2(4)
17240 L17240: if int<=-20202020 then let int=0
17245 L17245: fnend 
17250 def library fnygc_claim(fileno$,fofile$*20,fref$*10,cofileno$*15) !:
        !  "MY_FILE=CCON0027&FORW_FILE=FF%23-0008&CLIENT_REF=OZ4-0008&COCO_FILE=XYZ-NA"
17252   let ygcfile:=fngethandle_ !:
        open #ygcfile: "name="&env$("TEMP")&"\CM-"&session$&".htm,replace,recl=500",display,output 
17254   print #ygcfile: "<html>" !:
        print #ygcfile: "<head>" !:
        print #ygcfile: '<meta http-equiv="Content-Type" content="text/htm; charset=windows-1252">'
17256   let map1$='<META HTTP-EQUIV="refresh" CONTENT="0;URL=https://www.YouveGotClaims.com/datalink/get_claim.asp?'
17258   let map2$='MY_FILE='&fnhtml_$(fileno$)
17260   if trim$(fofile$)<>"" then !:
          let map2$(999:0)='&FORW_FILE='&fnhtml_$(fofile$)
17262   if trim$(client_ref$)<>"" then !:
          let map2$(999:0)='&CLIENT_REF='&fnhtml_$(fref$)
17264   if trim$(coco_file$)<>"" then !:
          let map2$(999:0)='&COCO_FILE='&fnhtml_$(cofileno$)
17266   let map2$(999:0)='">'
17268   let map2$=srep$(map2$," ","+")
17270   print #ygcfile: map1$&map2$
17272   print #ygcfile: "</head><body></body></html>"
17274   close #ygcfile: 
17276   let scr_thaw !:
        let fn_exe('-c -w','VB32\VBSHELL',env$("TEMP")&"\CM-"&session$&".htm ")
17278 fnend 
17280 def library fnis_wp$*80(c0de$)
17282   if ~cls_setup then let fnclssetup
17284   let c0de$=trim$(uprc$(c0de$))
17286   if trim$(c0de$)="" then goto L17352
17288   let nval=val(c0de$) conv L17290 !:
        goto L17352
17290 L17290: let ncheck=0 : let is_wp_form_doc$=""
17300   let _is_wp=srch(mat is_wp_cache_code$,c0de$)
17302   if _is_wp>0 then !:
          let fnis_wp$=is_wp_cache_form_doc$(_is_wp) !:
          goto L17352
17310   let _is_not_wp=srch(mat is_not_wp_cache_code$,c0de$)
17312   if _is_not_wp>0 then !:
          let fnis_wp$="" !:
          goto L17352
17320   do while (ncheck+=1)<=udim_doc_ext
17322     let form_doc$=trim$(form_dir$)&"\"&trim$(c0de$)&"."&trim$(doc_ext$(ncheck))
17324     if exists(form_doc$) then !:
            let fnis_wp$=is_wp_form_doc$=form_doc$ !:
            exit do 
17326   loop 
17330   if exists(c0de$&".HTM/E-MAIL") then !:
          let fnis_wp$=is_wp_form_doc$=c0de$&".HTM/E-MAIL"
17332   if trim$(is_wp_form_doc$)<>"" then 
17334     let _is_wp_cache_code+=1 !:
          mat is_wp_cache_code$(_is_wp_cache_code) !:
          mat is_wp_cache_form_doc$(_is_wp_cache_code)
17336     let is_wp_cache_code$(_is_wp_cache_code)=c0de$ !:
          let is_wp_cache_form_doc$(_is_wp_cache_code)=is_wp_form_doc$
17340   else 
17342     let _is_not_wp_cache_code+=1 !:
          mat is_not_wp_cache_code$(_is_not_wp_cache_code)
17344     let is_not_wp_cache_code$(_is_not_wp_cache_code)=c0de$
17350   end if 
17352 L17352: fnend 
17360 dim mrg_codes$(3)*8,mrg_type$(1)*20,mrg_desc$(1)*70,is_wp_cache_code$(1)*8,is_wp_cache_form_doc$(1)*128,is_not_wp_cache_code$(1)*8
17362 def fninit_custom_mrg
17364   let init_custom_mrg=1
17366   open #(mrg_handle:=fngethandle_): "NAME=CUSTOM.MRG/REPORTS,SHR",display,input ioerr L17385
17368 L17368: linput #mrg_handle: buff$ eof L17380
17370   let mrg_c0de+=1: mat mrg_codes$(mrg_c0de) !:
        mat mrg_type$(mrg_c0de) !:
        mat mrg_desc$(mrg_c0de) !:
        let mrg_codes$(mrg_c0de)=buff$(1:3) !:
        let mrg_type$(mrg_c0de)=buff$(9:27) !:
        let mrg_desc$(mrg_c0de)=buff$(29:99)
17375   goto L17368
17380 L17380: close #mrg_handle: !:
        goto L17390
17385 L17385: if err=4152 then let pk$="INITIAL-": chain "CUSTWP/PROG1",pk$ else print "ERROR:";err;" IN LINE:";line: !:
          pause : stop 
17390 L17390: fnend 
17400 def library fngetdoc_info(mat doc_info$,llcode$*8)
17405   if ~init_custom_mrg then let fninit_custom_mrg
17410   mat doc_info$(3)=("") !:
        let llcode$=uprc$(llcode$)
17415   if llcode$(1:1)<"M" then let doc_info$(1)="MASTERWP" else let doc_info$(1)="PLEADING"
17420   if llcode$(1:3)="FAX" then let doc_info$(1)="MASTERWP.FAX"
17425   if llcode$(1:2)="E-" then let doc_info$(1)="E-MAIL"
17430   let cust=srch(mrg_codes$,llcode$(1:3)): if cust>0 then goto L17455
17435   let cust=srch(codes$,rpad$(uprc$(llcode$(1:2)),3)) !:
        if cust>0 then goto L17455
17440   if llcode$(1:2)="E-" then goto L17450
17445   let cust=srch(mrg_codes$,rpad$(llcode$(1:1),3)): if cust>0 then goto L17455
17450 L17450: goto L17470 ! srch failed skip followinf assingments
17455 L17455: let doc_info$(3)=trim$(mrg_desc$(cust))
17460   let doc_info$(1)=trim$(mrg_type$(cust))
17465   let doc_info$(2)=trim$(mrg_codes$(cust))
17470 L17470: fnend 
17480 def library fnspin$(spin_pos$; time_pos$,start_time$,spin_handle,spin_time_handle)
17482 ! SPIN_POS$ Screen Position for Spinner for example "1,1,C 1" !:
        ! TIME_POS - Screen Position for Time (Including Attributes) "1,10,C 8,[W]" !:
        ! START_TIME$ Optional, if provided, clock will count elapsed rather than display current time !:
        ! spin_handle - io handle for spiner pos !:
        ! spin_time_handle - io handle for time pos
17484   if last_spin$<>time$ then 
17486     if ~clssetup then let fnclssetup
17488     let last_spin$=time$
17490     if env$("GUIMODE")="ON" then 
17492       let gui_spin+=1 !:
            if gui_spin>len(gui_spin$) then let gui_spin=1
17494       print #spin_handle,fields spin_pos$&","&gui_spinner_attribute$: gui_spin$(gui_spin:gui_spin)
17496     else 
17498       let spin+=1 !:
            if spin>len(spin$) then let spin=1
17500       print #spin_handle,fields spin_pos$&","&spinner_attribute$: spin$(spin:spin)
17502     end if  ! GUIMODE=ON
17504     if trim$(time_pos$)<>"" then 
17506       if trim$(start_time$)="" then !:
              print #spin_time_handle,fields time_pos$: time$ else !:
              print #spin_time_handle,fields time_pos$: fnstime_$(fnstime_(time$)-fnstime_(start_time$))
17508     end if  ! TIME_POS$<>""
17510   end if  ! LAST_SPIN$<>TIME$
17512 fnend 
17520 def library fnget_docket$*30(fileno$*8,internal_backbone_handle;docket_no$*30) ! this function is library ready
17522 ! PASS OPTIONAL VARIABLE DOCKET_NO$ TO AVOID PROBLEMS WITH DOCKET # REWRITE TO MASTER !:
        ! This avoids damaged backbone file problems
17524   read #internal_backbone_handle,using "FORM POS 27,C 30",key=fileno$&cnvrt$("N 3",0)&cnvrt$("N 2",2)&"MAIN      ",release: docket_no$ nokey XIT_FNGET_DOCKET
17526 XIT_FNGET_DOCKET: let fnget_docket$=docket_no$(1:30)
17528 fnend 
17530 def library fnshowdemograph$(zip_code$*60)
17535   dim qlocal$*80
17540   let qlocal$=trim$(zip_code$)
17545   let demograph_file=fngethandle_
17550   dim demograph1$*400,demograph2$*400
17555   open #demograph_file: "name="&env$("TEMP")&"\CM-"&session$&".htm,replace,recl=500",display,output 
17560   print #demograph_file: "<html>" !:
        print #demograph_file: "<head>" !:
        print #demograph_file: '<meta http-equiv="Content-Type" content="text/htm; charset=windows-1252">'
17565   let demograph1$='<META HTTP-EQUIV="refresh" CONTENT="0;URL=http://www.melissadata.com/Lookups/ZipCityPhone.asp?'
17570   let demograph2$='Local='&qlocal$&'">'
17575 DEMOGRAPHICS2: let demograph2$=srep$(demograph2$," ","+")
17580   print #demograph_file: demograph1$&demograph2$
17585   print #demograph_file: "</head><body></body></html>"
17590   close #demograph_file: 
17595   let scr_thaw !:
        let fn_exe('-c -w','VB32\VBSHELL',env$("TEMP")&"\CM-"&session$&".htm ")
17599 fnend 
17600 def library fnlist$*5000(list_file_name$*256)
17605 ! this function returns a comma seperated list of the data specified in List_File_Name$, The default will be to look in the Custom directory.
17610 ! List_File_Name$ should identify a file which contains only comma-delimited, tab-delimited or CRLF-delimited data.
17615 ! library 'CLSUtil/Library': FNPARSE_CSV, FNASCI
17620   dim list_file_name_cache$*256,list_line$(1)*512,list_field$(1)*512, set_fnlist$*5000
17625   if list_file_name$<>list_file_name_cache$ then 
17630     let set_fnlist$=''
17635     if exists('Custom\'&list_file_name$) then !:
            let fnasci_('Custom\'&list_file_name$,mat list_line$) else !:
            let fnasci_(list_file_name$,mat list_line$)
17640     mat list_value(0)
17645     for _list_line=1 to udim(mat list_line$)
17650       if pos(list_line$(_list_line),chr$(9))>0 then let list_csv_delimiter$=chr$(9) else let list_csv_delimiter$=''
17655       let fnparse_csv_(list_line$(_list_line),mat list_field$,list_csv_delimiter$)
17660       for _list_field=1 to udim(mat list_field$)
17665         let set_fnlist$=set_fnlist$&','&trim$(list_field$(_list_field))
17670       next _list_field
17675     next _list_line
17680     let list_file_name_cache$=list_file_name$
17685     let set_fnlist$=trim$(set_fnlist$,',')
17690   end if  ! List_File_Name$<>List_File_Name_Cache$
17695   let fnlist$=set_fnlist$
17699 fnend  ! fnList$
17700 def library fnfinan_trans_get(&ftg_finan_handle,ftg_fileno$,ftg_trans_date,ftg_code$,&ftg_int,&ftg_contract,&ftg_stat_due,&ftg_cost_due,mat ftg_filerec,mat ftg_frec)
17702   if ~cls_setup then let fnclssetup
17704   let fnfinan_trans_get=fn_finan_trans_get(ftg_finan_handle,ftg_fileno$,ftg_trans_date,ftg_code$,ftg_int,ftg_contract,ftg_stat_due,ftg_cost_due,mat ftg_filerec,mat ftg_frec)
17706 fnend  ! fnFinan_Trans_Get
17710 def fn_finan_trans_get(&ftg_finan_handle,ftg_fileno$,ftg_trans_date,ftg_code$,&ftg_int,&ftg_contract,&ftg_stat_due,&ftg_cost_due,mat ftg_filerec,mat ftg_frec)
17715 ! FTG_Finan_Handle - File Handle of  Name=I:Finan.Int,KFName=I:Finan.Idx  if already open, if not it'll be opened for input and returned
17720 ! FTG_Fileno$, FTG_TRANS_DATE, FTG_Code$  - FileNo, Trans_Date, and Code are used to find the (last) matching record.
17725 ! FTG_Int, FTG_Contract, FTG_Stat_Due, FTG_Cost_Due, mat FTG_Filerec, mat FTG_Frec - The correct record (if found) will returned in these legacy variables
17730 ! if a matching record is found the function will return the record number otherwise the function will return 0
17735 ! todo: if there is an error in this function it should return a negative error number
17740   if ~setup_sql then gosub SETUP_SQL
17745   let ftg_int=ftg_stat_due=ftg_cost_due=ftg_contract=0
17750   mat ftg_filerec(20)=(0)
17755   mat ftg_frec(80)=(0)
17760   if ftg_finan_handle<=0 or file(ftg_finan_handle)<=-1 then 
17765     let ftg_finan_handle=fnindex_handle("Name=I:Finan.Int,KFName=I:Finan.Idx")
17770   end if  ! FTG_Finan_Handle<=0 Or File(FTG_Finan_Handle)<=-1
17775   let ftg_fileno$=rpad$(ftg_fileno$,8)
17780   let ftg_code$=trim$(ftg_code$)
17785   let ftg_fileno_after$=ftg_fileno$(1:7)&chr$(ord(ftg_fileno$(8:8))+1)
17790   read #ftg_finan_handle,using FORM_POS_1_C8,search>=ftg_fileno_after$,release: ftg_fileno_temp$ nokey FTG_FINAN_RESTORE
17795   goto FTG_FINAN_READ
17800 FORM_POS_1_C8: form pos 1,c 8
17805 FTG_FINAN_RESTORE: ! 
17810   restore #ftg_finan_handle,last: 
17815 FTG_FINAN_READ: ! 
17820   mat finan_data$=("")
17825   mat finan_data=(0)
17830   read #ftg_finan_handle,using finan_formall$,prior,release: mat finan_data$,mat finan_data eof FTG_NO_MATCH
17835 ! pr 'debug_read_count=';(debug_read_count+=1);' date=';Finan_Data(Finan_Trans_Date)
17840   if trim$(finan_data$(finan_fileno))<>trim$(ftg_fileno$) then goto FTG_NO_MATCH
17845   if finan_data(finan_trans_date)<=ftg_trans_date then goto FOUND_ON_OR_B4
17850   if ftg_code$<>"" and trim$(finan_data$(finan_code))<>ftg_code$ then goto FTG_FINAN_READ !:
          ! todo: code no presently used. this must be modified to work
17855   if ftg_trans_date<>0 and finan_data(finan_trans_date)<>ftg_trans_date then goto FTG_FINAN_READ
17860 FOUND_ON_OR_B4: !:
        let ftg_filerec(1)=finan_data(finan_claim_orig_bal)
17865   let ftg_filerec(2)=finan_data(finan_claim_suit_amt)
17870   let ftg_filerec(3)=finan_data(finan_claim_stat_fee)
17875   let ftg_filerec(4)=finan_data(finan_claim_jdg_amt)
17880   let ftg_filerec(5)=finan_data(finan_balance)
17885   let ftg_filerec(6)=finan_data(finan_cost_balance)
17890   let ftg_filerec(8)=finan_data(finan_tot_principal)
17895   let ftg_filerec(9)=finan_data(finan_tot_interest)
17900   let ftg_filerec(16)=finan_data(finan_tot_rec_exp)
17905   let ftg_filerec(17)=finan_data(finan_tot_costs)
17910   let ftg_filerec(18)=finan_data(finan_tot_commission)
17915   let ftg_filerec(19)=finan_data(finan_tot_suit_fee)
17920   let ftg_filerec(20)=finan_data(finan_tot_stat_fee)
17925   let ftg_frec(14)=finan_data(finan_claim_pre_j_int) !:
        let ftg_frec(22)=finan_data(finan_compr_amt)
17930   let ftg_int=finan_data(finan_int)
17935   let ftg_stat_due=finan_data(finan_stat_due)
17940   let ftg_cost_due=finan_data(finan_costs_due)
17945   let ftg_contract=finan_data(finan_claim_contract)
17950   let set_ftg=rec(ftg_finan_handle)
17955   goto FTG_XIT
17960 FTG_NO_MATCH: ! 
17965   let set_ftg=0
17970   goto FTG_XIT
17975 FTG_XIT: ! 
17980   let fn_finan_trans_get=set_ftg
17985 fnend  ! fn_Finan_Trans_Get
17990 def library fnis_dot_net_20
17992   let fnis_dot_net_20=fn_is_dot_net_20
17994 fnend 
18000 def fn_is_dot_net_20
18002   dim vwindir$*128
18004   if trim$(env$("windir"))<>"" then let vwindir$ = env$("windir")
18006   if trim$(env$("cs_windir"))<>"" then let vwindir$ = "@::"&env$("cs_windir")
18008   let dotnetresult=exists(vwindir$&"\Microsoft.Net\Framework\v2.0.50727\mscorlib.dll")
18010   let fn_is_dot_net_20=dotnetresult
18012 fnend 
18020 def library fnshowmap$(street$*30,csz$*60)
18025   dim qcusa1$*30,qcusci$*20,qcusst$*3,qcuszi$*10,qcsz$(3)*40
18030 ! QCUSA1$= Street Address !:
        ! QCUSCI$= City Name !:
        ! QCUSST$= State !:
        ! QCUSZI$= Zip Code "
18035   let fnparse_csz_$(csz$,mat qcsz$)
18040   let qcusa1$= street$ !:
        let qcusci$= qcsz$(1) !:
        let qcusst$= qcsz$(2) !:
        let qcuszi$= qcsz$(3)(1:5)
18045   let next_file_handle=200
18050 L18050: let next_file_handle-=1 !:
        if trim$(file$(next_file_handle))<>"" then goto L18050
18055   let mapfile=next_file_handle
18060   dim map1$*400,map2$*400
18065   open #mapfile: "name="&env$("TEMP")&"\CM-"&session$&".htm,replace,recl=500",display,output 
18070   print #mapfile: "<html>" !:
        print #mapfile: "<head>" !:
        print #mapfile: '<meta http-equiv="Content-Type" content="text/htm; charset=windows-1252">'
18075   let map1$='<META HTTP-EQUIV="refresh" CONTENT="0;URL=http://www.google.com/lochp?hl=en&tab=wl&q='
18080   let map2$=fnhtml_$(qcusa1$)&'%20'&fnhtml_$(qcusci$)&'%20'&fnhtml_$(qcusst$)&'%20'&fnhtml_$(qcuszi$)&'">'
18085 SHOWMAP2: let map2$=srep$(map2$," ","+")
18090   print #mapfile: map1$&map2$
18095   print #mapfile: "</head><body></body></html>"
18100   close #mapfile: 
18105   let scr_thaw !:
        let fn_exe('-c -w','VB32\VBSHELL',env$("TEMP")&"\CM-"&session$&".htm ")
18109 fnend 
18110 def library fnreverse_phone$(phone$*20)
18115   let next_file_handle=200
18120 L18120: let next_file_handle-=1 !:
        if trim$(file$(next_file_handle))<>"" then goto L18120
18125   let phonefile=next_file_handle
18130   dim reverse_phone1$*400,reverse_phone2$*400
18135   open #phonefile: "name="&env$("TEMP")&"\CM-"&session$&".htm,replace,recl=500",display,output 
18140   print #phonefile: "<html>" !:
        print #phonefile: "<head>" !:
        print #phonefile: '<meta http-equiv="Content-Type" content="text/htm; charset=windows-1252">'
18145   let reverse_phone1$='<META HTTP-EQUIV="refresh" CONTENT="0;URL=http://anywhoyp.yellowpages.com/findaperson/phone?'
18150   let xslash=pos(phone$,"/") !:
        if xslash<=0 then let npa$="" !:
          let telephone$=phone$ else !:
          let npa$=trim$(phone$(1:xslash-1)) !:
          let telephone$=trim$(phone$(xslash+1:999))
18155   let reverse_phone2$='fap_terms%5Bphone%5D=('&fnhtml_$(npa$)&')'&fnhtml_$(telephone$)&'">'
18160 REVERSE_PHONE2A: let reverse_phone2$=srep$(reverse_phone2$," ","+")
18165   print #phonefile: reverse_phone1$&reverse_phone2$
18170   print #phonefile: "</head><body></body></html>"
18175   close #phonefile: 
18180   let scr_thaw !:
        let fn_exe('-c -w','VB32\VBSHELL',env$("TEMP")&"\CM-"&session$&".htm ")
18185 fnend 
18190 def library fnshow_near$(street$*30,csz$*60)
18195   dim qcussa$*30,qcussano$*30
18200 ! QCUSA1$= Street Address !:
        ! QCUSCI$= City Name !:
        ! QCUSST$= State !:
        ! QCUSZI$= Zip Code " !:
        ! QCUSSANO$= Street # !:
        ! QCUSSA$= Street Name
18205   let fnparse_csz_$(csz$,mat qcsz$)
18210   let qcusa1$= street$ !:
        let qcusci$= qcsz$(1) !:
        let qcusst$= qcsz$(2) !:
        let qcuszi$= qcsz$(3)(1:5)
18215   let qcussano$="" !:
        let qcussa$=qcusa1$
18220   dim street_results$(1)*80
18225   let fnparsestreet$(qcussa$,mat street_results$)
18230   let qcussano$=trim$(street_results$(1)) !:
        let qcussa$=trim$(street_results$(2))&" "&trim$(street_results$(3))
18235   let next_file_handle=200
18240 L18240: let next_file_handle-=1 !:
        if trim$(file$(next_file_handle))<>"" then goto L18240
18245   let neighborfile=next_file_handle
18250   dim neighbor1$*400,neighbor2$*400
18255   open #neighborfile: "name="&env$("TEMP")&"\CM-"&session$&".htm,replace,recl=500",display,output 
18260   print #neighborfile: "<html>" !:
        print #neighborfile: "<head>" !:
        print #neighborfile: '<meta http-equiv="Content-Type" content="text/htm; charset=windows-1252">'
18265   let neighbor1$='<META HTTP-EQUIV="refresh" CONTENT="0;URL=http://www.whitepages.com/10866/search/ReverseAddress?'
18270 ! http://www.whitepages.com/10866/search/ReverseAddress?housenumber=\STREET.NUMBER\&street=\STREET.NAME\&where=\CSZ\
18275   let neighbor2$='housenumber='&fnhtml_$(qcussano$)&'&street='&fnhtml_$(qcussa$)&'&where='&fnhtml_$(csz$)&'">' !:
        ! 'E='&FNHTML_$(STREET$)&'&L='&FNHTML_$(CSZ$)&'&PS=45&search=Find+It'&'">' !:
        ! 'QHN='&FNHTML_$(QCUSSANO$)&'&QST='&FNHTML_$(QCUSSA$)&'&QS='&FNHTML_$(QCUSST$)&'&QC='&FNHTML_$(QCUSCI$)&'">'
18280 SHOW_NEAR2: let neighbor2$=srep$(neighbor2$," ","+")
18285   print #neighborfile: neighbor1$&neighbor2$
18290   print #neighborfile: "</head><body></body></html>"
18295   close #neighborfile: 
18300   let scr_thaw !:
        let fn_exe('-c -w','VB32\VBSHELL',env$("TEMP")&"\CM-"&session$&".htm ")
18305 fnend 
18310 def library fnnj_xlate$*4096(asci$*4096)
18312   if ~xlate_setup then let fnxlate_setup
18314   let asci$ = xlate$(asci$, nj_xlate$)
18316   let fnnj_xlate$=asci$
18318 fnend 
18320 def library fndata_xlate$*4096(asci$*4096)
18322   if ~xlate_setup then let fnxlate_setup
18324   let asci$ = xlate$(asci$, data_xlate$)
18326   let fndata_xlate$=asci$
18328 fnend 
18330 def library fnsymbol_xlate$*4096(asci$*4096)
18332   if ~xlate_setup then let fnxlate_setup
18334 ! let asci$ = xlate$(asci$, symbols_xlate$)
18336   let fnsymbol_xlate$ = xlate$(asci$, symbols_xlate$) ! =asci$
18338 fnend 
18340 def library fnshow_person$(name$*60,street$*30,csz$*60)
18345   dim person_results$(1)*80,qfirst$*40,qlast$*40,business_results$(1)*80
18350 ! QCUSA1$= Street Address !:
        ! QCUSCI$= City Name !:
        ! QCUSST$= State !:
        ! QCUSZI$= Zip Code " !:
        ! QFIRST$=FIRST NAME !:
        ! QLAST$=LAST NAME
18355   let fnparse_csz_$(csz$,mat qcsz$)
18360   let qcusa1$= street$ !:
        let qcusci$= qcsz$(1) !:
        let qcusst$= qcsz$(2) !:
        let qcuszi$= qcsz$(3)(1:5)
18365   let slash_pos=pos(name$,"/") !:
        if slash_pos>0 then !:
          let person_type=1 else let person_type=2
18370   let fnparse_name_$(name$,person_type,mat person_results$) !:
        let qfirst$=person_results$(2) !:
        let qlast$=person_results$(4)
18375   let qcussa$=qcusa1$ !:
        let fnparsestreet$(qcussa$,mat street_results$) !:
        let qcussano$=trim$(street_results$(1)) !:
        let qcussa$=trim$(trim$(street_results$(2))&" "&trim$(street_results$(3)))
18380   let next_file_handle=200
18385 L18385: let next_file_handle-=1 !:
        if trim$(file$(next_file_handle))<>"" then goto L18385
18390   let personfile=next_file_handle
18395   dim person1$*400,person2$*400
18400   open #personfile: "name="&env$("TEMP")&"\CM-"&session$&".htm,replace,recl=500",display,output 
18405   print #personfile: "<html>" !:
        print #personfile: "<head>" !:
        print #personfile: '<meta http-equiv="Content-Type" content="text/htm; charset=windows-1252">'
18410   let person1$='<META HTTP-EQUIV="refresh" CONTENT="0;URL=http://www.whitepages.com/10866/search/FindPerson?firstname_begins_with=1&'
18415   let person2$='firstname='&qfirst$&'&name='&qlast$&'&where='&csz$&'">'
18420 FINDPEOPLE2: let person2$=srep$(person2$," ","+")
18425   print #personfile: person1$&person2$
18430   print #personfile: "</head><body></body></html>"
18435   close #personfile: 
18440   let scr_thaw !:
        let fn_exe('-c -w','VB32\VBSHELL',env$("TEMP")&"\CM-"&session$&".htm ")
18445 fnend 
18450 def library fnnumber_xlate$*4096(asci$*4096) !  Numbers_Xlate$ = Rpt$(" ", 46)&". 0123456789"&Rpt$(" ", 195)
18452   if ~xlate_setup then let fnxlate_setup
18454   let asci$ = xlate$(asci$, numbers_xlate$)
18456   let fnnumber_xlate$=asci$
18458 fnend 
18460 def library fnshow_business$(name$*60,street$*30,csz$*60)
18465 ! QCUSA1$= Street Address !:
        ! QCUSCI$= City Name !:
        ! QCUSST$= State !:
        ! QCUSZI$= Zip Code " !:
        ! QFIRST$=FIRST NAME !:
        ! QLAST$=LAST NAME
18470   let fnparse_csz_$(csz$,mat qcsz$)
18475   let qcusa1$= street$ !:
        let qcusci$= qcsz$(1) !:
        let qcusst$= qcsz$(2) !:
        let qcuszi$= qcsz$(3)(1:5)
18480   let slash_pos=pos(name$,"/") !:
        if slash_pos>0 then !:
          let business_type=1 else let business_type=2
18485   let fnparse_name_$(name$,business_type,mat business_results$) !:
        let qfirst$=business_results$(2) !:
        let qlast$=business_results$(4)
18490   let qcussa$=qcusa1$ !:
        let fnparsestreet$(qcussa$,mat street_results$) !:
        let qcussano$=trim$(street_results$(1)) !:
        let qcussa$=trim$(trim$(street_results$(2))&" "&trim$(street_results$(3)))
18495   let next_file_handle=200
18500 L18500: let next_file_handle-=1 !:
        if trim$(file$(next_file_handle))<>"" then goto L18500
18505   let businessfile=next_file_handle
18510   dim business1$*400,business2$*400
18515   open #businessfile: "name="&env$("TEMP")&"\CM-"&session$&".htm,replace,recl=500",display,output 
18520   print #businessfile: "<html>" !:
        print #businessfile: "<head>" !:
        print #businessfile: '<meta http-equiv="Content-Type" content="text/htm; charset=windows-1252">'
18525   let business1$='<META HTTP-EQUIV="refresh" CONTENT="0;URL=http://yellowpages.superpages.com/listings.jsp?CS=L&MCBP=true&STYPE=&CB=&C=&'
18530   let business2$='N='&name$&'&E='&qcusa1$&'&L='&csz$&'&A=&X=&P=&AXP=&PS=45&search=Find+It'&'">'
18535 FINDBUSINESS2: let business2$=srep$(business2$," ","+")
18540   print #businessfile: business1$&business2$
18545   print #businessfile: "</head><body></body></html>"
18550   close #businessfile: 
18555   let scr_thaw !:
        let fn_exe('-c -w','VB32\VBSHELL',env$("TEMP")&"\CM-"&session$&".htm ")
18560 fnend 
18570 ! ----------------FNHTML-----------------------------------------
18572 def library fnhtml$*4096(asci$*4096)
18574   let fnhtml$=fnhtml_$(asci$)
18576 fnend 
18578 def library fnedi_xlate$*4096(asci$*4096)
18580   if ~xlate_setup then let fnxlate_setup
18582   let asci$ = xlate$(asci$, edi_xlate$)
18584   let fnedi_xlate$=asci$
18586 fnend 
18590 def fnhtml_$*4096(asci$*4096)
18592 ! converts from SystemPC to HTML
18594   if ~xlate_setup then let fnxlate_setup
18596   let asci$=srep$(asci$,"&","&amp;") !:
        let asci$=srep$(asci$,chr$(34),"&quot;") !:
        let asci$=srep$(asci$,"<","&lt;") !:
        let asci$=srep$(asci$,">","&gt;") !:
        let asci$=srep$(asci$,"","|") !:
        let asci$=srep$(asci$,"","-")
18598   let asci$=srep$(asci$,"#","&#35;") !:
        let asci$=srep$(asci$,"'","&#39;") !:
        let asci$=srep$(asci$,chr$(254),"^")
18600 ! ASCII codes 128-131 !:
        let asci$=srep$(asci$,chr$(128),"&#199;") ! &Ccedil; !:
        let asci$=srep$(asci$,chr$(129),"&#252;") ! &uuml; !:
        let asci$=srep$(asci$,chr$(130),"&#233;") ! &eacute; !:
        let asci$=srep$(asci$,chr$(131),"&#226;") ! $acirc;
18602 ! ASCII codes 132-135 !:
        let asci$=srep$(asci$,chr$(132),"&#228;") ! &auml; !:
        let asci$=srep$(asci$,chr$(133),"&#224;") ! &agrave; !:
        let asci$=srep$(asci$,chr$(134),"&#229;") ! &aring; !:
        let asci$=srep$(asci$,chr$(135),"&#231;") ! &ccedil;
18604 ! ASCII codes 136-139 !:
        let asci$=srep$(asci$,chr$(136),"&#234;") ! &ecirc; !:
        let asci$=srep$(asci$,chr$(137),"&#235;") ! &euml; !:
        let asci$=srep$(asci$,chr$(138),"&#232;") ! &egrave; !:
        let asci$=srep$(asci$,chr$(139),"&#239;") ! &iuml;
18606 ! ASCII codes 140-143 !:
        let asci$=srep$(asci$,chr$(140),"&#238;") ! &icirc; !:
        let asci$=srep$(asci$,chr$(141),"&#236;") ! &igrave; !:
        let asci$=srep$(asci$,chr$(142),"&#196;") ! &Auml; !:
        let asci$=srep$(asci$,chr$(143),"&#197;") ! &Aring;
18608 ! ASCII codes 144-147 !:
        let asci$=srep$(asci$,chr$(144),"&#201;") ! &Eacute; !:
        let asci$=srep$(asci$,chr$(145),"&#230;") ! &aelig; !:
        let asci$=srep$(asci$,chr$(146),"&#196;") ! &AElig; !:
        let asci$=srep$(asci$,chr$(147),"&#212;") ! &ocirc;
18610 ! ASCII codes 148-151 !:
        let asci$=srep$(asci$,chr$(148),"&#246;") ! &ouml; !:
        let asci$=srep$(asci$,chr$(149),"&#242;") ! &ograve; !:
        let asci$=srep$(asci$,chr$(150),"&#251;") ! &ucirc; !:
        let asci$=srep$(asci$,chr$(151),"&#249;") ! &ugrave;
18612 ! ASCII codes 152-155 !:
        let asci$=srep$(asci$,chr$(152),"&#255;") ! &yuml; !:
        let asci$=srep$(asci$,chr$(153),"&#214;") ! &Ouml; !:
        let asci$=srep$(asci$,chr$(154),"&#220;") ! &Uuml; !:
        let asci$=srep$(asci$,chr$(155),"&#162;") ! &cent;
18614 ! ASCII codes 156-159 !:
        let asci$=srep$(asci$,chr$(156),"&#163;") ! &pound; !:
        let asci$=srep$(asci$,chr$(157),"&#165;") ! &yen; !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(158),"*") Pt symbol !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(159),"*") elongated 'f'
18616 ! ASCII codes 160-163 !:
        let asci$=srep$(asci$,chr$(160),"&#225;") ! &aacute; !:
        let asci$=srep$(asci$,chr$(161),"&#237;") ! &iacute; !:
        let asci$=srep$(asci$,chr$(162),"&#243;") ! &oacute; !:
        let asci$=srep$(asci$,chr$(163),"&#250;") ! &uacute;
18618 ! ASCII codes 164-167 !:
        let asci$=srep$(asci$,chr$(164),"&#241;") ! &ntilde; !:
        let asci$=srep$(asci$,chr$(165),"&#209;") ! &Ntilde; !:
        let asci$=srep$(asci$,chr$(166),"&#170;") ! &ordf; !:
        let asci$=srep$(asci$,chr$(167),"&#186;") ! &ordm;
18620 ! ASCII codes 168-171 !:
        let asci$=srep$(asci$,chr$(168),"&#191;") ! &iquest; !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(169),"*") reversed not sign? !:
        let asci$=srep$(asci$,chr$(170),"&#172;") ! &not; !:
        let asci$=srep$(asci$,chr$(171),"&#189;") ! &frac12;
18622 ! ASCII codes 172-175 !:
        let asci$=srep$(asci$,chr$(172),"&#188;") ! &frac14; !:
        let asci$=srep$(asci$,chr$(173),"&#161;") ! &iexcl; !:
        let asci$=srep$(asci$,chr$(174),"&#171;") ! &laquo; !:
        let asci$=srep$(asci$,chr$(175),"&#187;") ! &raquo;
18624 ! ASCII codes 176-223 (Line drawing)
18626 ! ASCII codes 224-239 (Greek symbols)
18628 ! ASCII codes 240-243 !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(240),"*") three horizontal bars !:
        let asci$=srep$(asci$,chr$(241),"&#177;") ! &plusmn; !:
        let asci$=srep$(asci$,chr$(242),"&gt;=") !:
        let asci$=srep$(asci$,chr$(243),"&lt;=")
18630 ! ASCII codes 244-247 !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(244),"*") hook !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(245),"*") inverted hook !:
        let asci$=srep$(asci$,chr$(246),"&#247;") ! &divide; !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(247),"*") equivalent
18632 ! ASCII codes 248-251 !:
        let asci$=srep$(asci$,chr$(248),"&#176;") ! &deg; !:
        let asci$=srep$(asci$,chr$(249),"&#183;") ! &middot; !:
        let asci$=srep$(asci$,chr$(250),"&#183;") ! &middot; !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(251),"*") radical
18634 ! ASCII codes 252-255 !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(252),"*") superscript n !:
        let asci$=srep$(asci$,chr$(253),"&#178;") ! &sup2; !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(254),"*") unknown !:
        ! LET ASCI$=SREP$(ASCI$,CHR$(255),"*") unknown
18636   let asci$ = xlate$(asci$, html_xlate$)
18638   let fnhtml_$=rtrm$(asci$) ! trim$ removed - perhaps rtrm$ should be removed too.
18640 fnend 
18650 def library fnrecheck_schedule(fileno$,diary_handle,p_dc0de$,p_amort,&past_due,&next_date$,&next_amt)
18655   if ~cls_setup then let fnclssetup
18660   dim sched$(1)*8,sched(1),sched_amt(1),sched_days(1),com$*80
18665   let past_due=0 !:
        if diary_handle<=0 then let diary_handle=fngethandle_
18670   let diary_open=0 !:
        if lrec(diary_handle)<0 then !:
          open #diary_handle: "NAME=DIARY.INT//6,KFNAME=DIARY.FIL//6,SHR",internal,outin,keyed ioerr L18745 !:
          let diary_open=1
18675   mat sched$(1)=("") !:
        mat sched(1)=(0) !:
        mat sched_amt(1)=(0) !:
        mat sched_days(1)=(0) !:
        let sched=0 !:
        read #diary_handle,using L15180,search>=fileno$,release: dfile$,dc0de,dc0de$,ddate$,com$ nokey L18730
18680 L18680: if dfile$<>fileno$ then goto L18730
18685   let is_payment=0 !:
        if trim$(dc0de$)=trim$(p_dc0de$) and p_amort<>0 then let is_payment=1 !:
          goto L18695
18690   if srch(mat vlp$,trim$(dc0de$))>0 then let is_payment=1 else !:
          if srch(mat psc$,trim$(dc0de$))>0 then let is_payment=1 else !:
            if srch(mat rop$,trim$(dc0de$))>0 then let is_payment=1 else !:
              if pd$(8)=trim$(dc0de$) then let is_payment=1
18695 L18695: if is_payment then let sched+=1 !:
          mat sched$(sched) !:
          mat sched(sched) !:
          mat sched_amt(sched) !:
          mat sched_days(sched) !:
          let sched_days(sched)=fnval_(srep$(ddate$,"/","")) !:
          let sched_days(sched)=days(sched_days(sched)) else !:
          goto L18720
18700   let sched$(sched)=trim$(dc0de$) !:
        let sched(sched)=rec(diary_handle) !:
        let x=pos(com$,":") !:
        if x>0 then let com$=trim$(com$(x+1:99))
18705   let x=pos(com$,"$") !:
        if x>0 then let com$=trim$(com$(x+1:99))
18710   let sched_amt(sched)=fnval_(com$) !:
        ! ! FNPAYVAL WAS HERE BEFORE!!!
18715   if sched_days(sched)<=days(date) then let past_due+=sched_amt(sched)
18720 L18720: read #diary_handle,using L15180,release: dfile$,dc0de,dc0de$,ddate$,com$ eof L18730
18725   goto L18680
18730 L18730: let fnrecheck_schedule=sum(sched_amt)
18735   let next_date$=date$(sched_days(1)) !:
        let next_amt=sched_amt(1)
18740   if diary_open=1 then close #diary_handle: 
18745 L18745: fnend 
18750 def library fnschedule_details(mat schedule$,mat schedule,mat schedule_amount,mat schedule_days)
18752   mat schedule$(udim(sched_amt))=sched$ !:
        mat schedule(udim(sched_amt))=sched !:
        mat schedule_amount(udim(sched_amt))=sched_amt !:
        mat schedule_days(udim(sched_amt))=sched_days
18754 fnend 
18760 def library fnfileno_fow$*8(ff_forwarder_number) ! Ff_
18762   let fnfileno_fow$=fn_fileno_fow$(ff_forwarder_number)
18764 fnend  ! FnFileno_Fow$*8
18770 def fn_fileno_fow$*8(ff_forwarder_number) ! Ff_
18775   let ff_return$='FOW.0000'
18780   let ff_forwarder_number=abs(ff_forwarder_number)
18785   if ff_forwarder_number<=9999 then 
18790     let ff_return$='FOW.'&cnvrt$('Pic(####)',ff_forwarder_number)
18795   else if ff_forwarder_number<=99999 then 
18800     let ff_return$='FOW'&cnvrt$('Pic(#####)',ff_forwarder_number)
18805   else 
18810     if uprc$(env$("Debug"))='YES' then print 'Fn_Fileno_Fow$ was passed a forwarder number ('&str$(ff_forwarder_number)&') which was too long to be processed.'
18815   end if  ! Ff_Forwarder_Number
18820   let fn_fileno_fow$=ff_return$
18825 fnend  ! Fn_Fileno_Fow$
18830 def library fnsoflow_state$*6 ! ss_
18832   let fnsoflow_state$=fn_soflow_state$
18834 fnend  ! fnsoflow_state$
18840 def fn_soflow_state$*6 ! ss_
18842 ! this function MUST be local, do not expose it as a library, if you need it it must be copied into the program which is using it.  Libraries and their calling programs do not share soflow states
18844   dim ss_one$*1
18846   let ss_return$=''
18848   let ss_one$="too large" soflow SS_SOFLOW_SYSTEM
18850   let ss_return$='Ignore'
18852   goto SS_XIT
18854 SS_SOFLOW_SYSTEM: ! 
18856   let ss_return$='System'
18858   goto SS_XIT
18860 SS_XIT: ! 
18862   let fn_soflow_state$=ss_return$
18864 fnend  ! fn_soflow_state$
18870 def library fngmt$
18872   let fngmt$=fn_gmt$
18874 fnend 
18880 def fn_gmt$
18882   if ~setup_gmt then 
18884     dim zip_result$(1)*512
18886     let setup_gmt=1 !:
          if ~cls_setup then let fnclssetup
18888     let fnzip_$(tz_zip$,0,mat zip_result$)
18890     let gmt$="GMT-"&trim$(zip_result$(10)) !:
          let gmt=fnval_(zip_result$(10))
18892   end if 
18894   let fn_gmt$=gmt$
18896 fnend 
18900 def library fngmt_date_time$*30(gmt_code$*10,gmt_date$*10,gmt_time$*10)
18902   let fngmt_date_time$=fn_gmt_date_time$(gmt_code$,gmt_date$,gmt_time$)
18904 fnend 
18910 def fn_gmt_date_time$*30(gmt_code$*10,gmt_date$*10,gmt_time$*10)
18912   if ~setup_gmt_date_time then 
18914     if ~cls_setup then let fnclssetup
18916     let gmt=val(fn_gmt$(4:6))
18918     let setup_gmt_date_time=1
18920   end if 
18922   if gmt_code$ (1:4) <> "GMT-" and gmt_code$ (1:4) <> "GMT+" then goto XIT_FNGMT_DATE_TIME
18924   let gmt2=val(gmt_code$(4:6)) conv XIT_FNGMT_DATE_TIME
18926   let gmt_date$=fndate10_$(gmt_date$) !:
        ! LET Gmt_Time$=Time$ !:
        ! TODO: Why set Date & Time to now?
18928   if gmt<>0 and gmt2<>0 and gmt<>gmt2 then 
18930     let vhr=val(gmt_time$(1:2)) conv XIT_FNGMT_DATE_TIME !:
          let vday=val(gmt_date$(9:10)) conv XIT_FNGMT_DATE_TIME
18932     if gmt < gmt2 then let vhr = vhr + (gmt2-gmt)
18934     if gmt > gmt2 then let vhr = vhr + (gmt-gmt2)
18936     let gmt_diff=gmt-gmt2 !  (# of Hours Between Time Zones)
18938     if vhr >= 24 then let vday=vday+1 : let vhr = (vhr-24)
18940     let gmt_date$=gmt_date$(1:8)&lpad$(str$(vday),2,"0")
18942     let gmt_time$=lpad$(str$(vhr),2,"0")&gmt_time$(3:8)
18944   end if 
18946 XIT_FNGMT_DATE_TIME: ! 
18948   let fn_gmt_date_time$=fndate10_$(fnddate_$(gmt_date$))&" "&gmt_time$
18950 fnend 
18960 def library fnzip$*30(zip$,autozip,mat results$)
18962   let fnzip$=fnzip_$(zip$,autozip,mat results$)
18964 fnend 
18970 def fnzip_$*30(zip$,autozip,mat results$)
18972   mat results$(10)=("") !:
        ! 1 = Zip Code !:
        ! 2 = City Name !:
        ! 3 = Abbreviated Name ! 4 = Addressable Name !:
        ! 5 = State ! 6 = County !:
        ! 7 = Area Code !:
        ! 8 = LATITUDE !:
        ! 9 = LONGITUDE  ! 10 = Time Zone
18974   if autozip=0 then 
18976     if master_autozip_handle=0 then !:
            let master_autozip_handle=fngethandle_
18978     let autozip=master_autozip_handle
18980   end if  ! if AUTOZIP=0 THEN
18982   if file(autozip)<0 then open #autozip: "Name=ZipCodes.Int/ZipCodes,KFName=ZipCodes.Zip/ZipCodes,Shr",internal,input,keyed 
18984   read #autozip,using L18986,key=rpad$(zip$(1:5),5),release: mat results$(1:7),lat,long,results$(10) ioerr L18990 !:
        let fnzip_$=trim$(trim$(results$(4))&" "&trim$(results$(5))) !:
        let results$(8)=str$(lat) !:
        let results$(9)=str$(long)
18986 L18986: form pos 1,c 5,c 28,c 17,c 28,pos 80,c 3,pos 83,c 25,c 3,pos 114,n 7.4,n 8.4,pos 111,c 3
18988   goto L18996
18990 L18990: if err=58 then !:
          let fnmessagebox_("Warning: Error:"&str$(err)&" in Line:"&str$(line)&chr$(10)&"Please Make sure you Dim your results$"&chr$(10)&"When calling FNZIP",16,"Error! Please Dim Results") !:
          goto L18996
18992   if err=4272 then !:
          ! LET FNMESSAGEBOX_("Warning: Error:"&STR$(ERR)&" in Line:"&STR$(LINE)&CHR$(10)&"Zip Code:"&ZIP$&" Could not be found"&CHR$(10)&"When calling FNZIP") !:
          goto L18996
18994   let fnmessagebox_("Warning: Error:"&str$(err)&" in Line:"&str$(line)&chr$(10)&"Please Resolve Problem with FNZIP!",16,"Problem with FNZIP") !:
        goto L18996
18996 L18996: fnend 
19000 def library fndistance(zip1$,zip2$,autozip)
19002   let fndistance=fndistance_(zip1$,zip2$,autozip)
19004 fnend 
19010 def fndistance_(zip1$,zip2$,autozip)
19012 ! Calculates Distance between 2 Zip Codes !:
        ! Zip 1 = From !:
        ! Zip 2 = To !:
        ! AutoZip = File Handle for Zip Code table
19014   let dist=-1 !:
        ! Distance of -1 is Unknown
19016   if file(autozip)<0 then open #autozip: "NAME=ZIPCODES.INT/ZIPCODES,KFNAME=ZIPCODES.ZIP/ZIPCODES,SHR",internal,input,keyed 
19018   read #autozip,using L19022,key=rpad$(zip1$(1:5),5),release: lat1,long1 ioerr L19032
19020   read #autozip,using L19022,key=rpad$(zip2$(1:5),5),release: lat2,long2 ioerr L19032
19022 L19022: form pos 114,n 7.4,n 8.4
19024   let cnv1=180/pi
19026   let a=sin(lat1/cnv1)*sin(lat2/cnv1)+cos(lat1/cnv1)*cos(lat2/cnv1)*cos(long2/cnv1-long1/cnv1)
19028   let dist=3959*atn(sqr(round((1-a**2),10))/a)
19030   if (lat1=0 and long1=0) or (lat2=0 and long2=0) then !:
          let dist=-999
19032 L19032: let fndistance_=dist
19034 fnend 
19040 def library fnzip_city$*30(zip_city$*30,autozip,mat results$)
19042   let fnzip_city$=fnzipcity$(zip_city$,autozip,mat results$)
19044 fnend 
19050 def fnzipcity$*30(zip_city$*30,autozip,mat results$)
19052   mat results$(10)=("") !:
        ! 1 = Zip Code !:
        ! 2 = City Name !:
        ! 3 = Abbreviated Name !:
        ! 4 = Addressable Name !:
        ! 5 = State !:
        ! 6 = County !:
        ! 7 = Area Code !:
        ! 8 = LATITUDE !:
        ! 9 = LONGITUDE ! 10 = TZ
19054 ! ** NOTE: BOTH AUTOZIP & AUTOZIP+1 USED FOR FILE HANDLES!
19060   dim zip_city$(3)*40,tresults$(10)*40
19062   if file(autozip)<0 then open #autozip: "NAME=ZIPCODES.INT/ZIPCODES,KFNAME=ZIPCODES.CT1/ZIPCODES,SHR",internal,input,keyed 
19064   if file(autozip+1)<0 then open #autozip+1: "NAME=ZIPCODES.INT/ZIPCODES,KFNAME=ZIPCODES.CT2/ZIPCODES,SHR",internal,input,keyed 
19066   mat zip_city$(3)=("") !:
        let fnparse_csz_$(zip_city$,mat zip_city$) !:
        if trim$(zip_city$(2))="" then goto L19090
19070   read #autozip,using L19086,key=uprc$(rpad$(zip_city$(2),3)(1:3)&rpad$(zip_city$(1),28)),release: mat results$(1:7),lat,long,results$(10) ioerr L19080 !:
        read #autozip,using L19086,release: mat tresults$(1:7),tlat,tlong ioerr L19074
19072   if results$(2)=tresults$(2) then !:
          let results$(1)(1:0)="*"
19074 L19074: let fnzipcity$=results$(1) !:
        let results$(8)=str$(lat) !:
        let results$(9)=str$(long) !:
        goto L19090
19080 L19080: read #autozip+1,using L19086,key=uprc$(rpad$(zip_city$(2),3)(1:3)&rpad$(zip_city$(1),17)),release: mat results$(1:7),lat,long ioerr L19090 !:
        read #autozip+1,using L19086,release: mat tresults$(1:7),tlat,tlong ioerr L19084
19082   if results$(2)=tresults$(2) then !:
          let results$(1)(1:0)="*"
19084 L19084: let fnzipcity$=results$(1) !:
        let results$(8)=str$(lat) !:
        let results$(9)=str$(long) !:
        goto L19090
19086 L19086: form pos 1,c 5,c 28,c 17,c 28,pos 80,c 3,pos 83,c 25,c 3,pos 114,n 7.4,n 8.4,pos 111,c 3
19090 L19090: goto L19098
19092   if err=58 then !:
          let fnmessagebox_("Warning: Error:"&str$(err)&" in Line:"&str$(line)&chr$(10)&"Please Make sure you Dim your results$"&chr$(10)&"When calling FNZIP_CITY",16,"Error! Please Dim Results") !:
          goto L19098
19094   if err=4272 then !:
          ! LET FNMESSAGEBOX_("Warning: Error:"&STR$(ERR)&" in Line:"&STR$(LINE)&CHR$(10)&"Zip Code:"&ZIP$&" Could not be found"&CHR$(10)&"When calling FNZIP_CITY") !:
          goto L19098
19096   let fnmessagebox_("Warning: Error:"&str$(err)&" in Line:"&str$(line)&chr$(10)&"Please Resolve Problem with FNZIP_CITY!",16,"Error! Check FNZIP_CITY") !:
        goto L19098
19098 L19098: fnend 
19100 def library fncountry$(state$)
19102   if ~setup_fncountry then 
19104     let setup_fncountry=1 !:
          if setup_states=0 then let fnsetup_states
19106   end if  ! ~Setup_Fncountry THEN
19108   if srch(mat st$,uprc$(rtrm$(state$)))>=states_al then !:
          let fncountry$=("USA") !:
        else if len(rtrm$(st$))=3 then let fncountry$=st$
19109 fnend 
19110 def library fnis_fileno_fow(iff_fileno$) ! Iff_
19112   let fnis_fileno_fow=fn_is_fileno_fow(iff_fileno$)
19114 fnend  ! FnIs_Fileno_Fow
19120 def fn_is_fileno_fow(iff_fileno$) ! Iff_
19122   let fn_is_fileno_fow=fn_is_fileno_type(iff_fileno$,'FOW')
19124 fnend  ! Fn_Is_Fileno_Fow
19130 def library fnis_fileno_cst(ifc_fileno$) ! Ifc_
19132   let fnis_fileno_cst=fn_is_fileno_cst(ifc_fileno$)
19134 fnend  ! FnIs_Fileno_Cst
19140 def fn_is_fileno_cst(ifc_fileno$) ! Ifc_
19142   let fn_is_fileno_cst=fn_is_fileno_type(ifc_fileno$,'CST')
19144 fnend  ! Fn_Is_Fileno_Cst
19150 def fn_is_fileno_type(ift_fileno$*8,ift_type$*3) ! Ift_
19155 ! This function will return the type's number parsed from the filenumber, if it is a type's fileno else this function will return 0
19160 ! Ift_Type$=RPad$(Uprc$(Ift_Type$),3) ! this function (for speed purposes) requires that you pass it a 3 character all uppercase Ift_Type$
19165   let ift_return=0
19170   if ift_fileno$(1:3)=ift_type$ and len(trim$(ift_fileno$))=8 then 
19175     if ift_fileno$(4:4)='.' then 
19180       let ift_return=val(ift_fileno$(5:8)) conv ignore
19185       if ift_return<0 then let ift_return=0
19190     else 
19195       let ift_return=val(ift_fileno$(4:8)) conv ignore
19200       if ift_return<=9999 then let ift_return=0
19205     end if  ! Ift_FileNo$(4:4)='.'   /   else 
19210   end if  ! Ift_FileNo$(1:3)='FOW' and len(trim$(Ift_FileNo$))=8
19215   let fn_is_fileno_type=ift_return
19219 fnend  ! Fn_Is_Fileno_Type
19220 def library fnput_formula(doc_code$,mat doc_formula$)
19222   dim formula_code$,formula$*200,formula_key$*12
19224   if ~setup_formula then !:
          gosub SETUP_FORMULA
19226   let _doc_formula=udim(doc_formula$)
19228   let doc_code$=uprc$(rpad$(doc_code$,8))(1:8)
19230   restore #formula_handle,search>=doc_code$: nokey XIT_CLEAR_FORMULA
19232   do 
19234     read #formula_handle,using FORMULA_FORM: formula_code$,formula_no,formula$ eof XIT_CLEAR_FORMULA
19236 FORMULA_FORM: form pos 1,c 8,bh 4,v 200
19238     if doc_code$=formula_code$ then 
19240       if formula_no>_doc_formula or trim$(doc_formula$(formula_no))="" then 
19242         delete #formula_handle: 
19244       end if  ! Delete Unused Formula
19246     end if 
19248   loop while formula_code$=doc_code$
19250 XIT_CLEAR_FORMULA: ! Old Unused Formulas have been removed
19252   for _formula=1 to udim(doc_formula$)
19254     if trim$(doc_formula$(_formula))<>"" then 
19256       let formula_key$=doc_code$&cnvrt$('BH 4',_formula)
19258       print fields "1,70,n 10": tot_formula+=1
19260       rewrite #formula_handle,using FORMULA_FORM,key=formula_key$: doc_code$,_formula,doc_formula$(_formula) nokey ADD_FORMULA !:
            goto FORMULA_UPDATED
19262 ADD_FORMULA: write #formula_handle,using FORMULA_FORM: doc_code$,_formula,doc_formula$(_formula)
19264 FORMULA_UPDATED: ! FORMULA HAS BEEN UPDATED
19266     end if 
19268   next _formula
19270 fnend  ! FNPUT_FORMULA
19280 def library fnget_formula(doc_code$,mat doc_formula$)
19282   if ~setup_formula then !:
          gosub SETUP_FORMULA
19284   mat doc_formula$(0)=("")
19286   let doc_code$=uprc$(rpad$(doc_code$,8))(1:8)
19288   restore #formula_handle,search>=doc_code$: nokey XIT_GET_FORMULA
19290   do 
19292     read #formula_handle,using FORMULA_FORM,release: formula_code$,formula_no,formula$ eof XIT_GET_FORMULA
19294     if doc_code$=formula_code$ then 
19296       if formula_no> udim(doc_formula$) then !:
              mat doc_formula$(formula_no)
19298       let formula$=srep$(formula$,hex$("93"),'"') !:
            let formula$=srep$(formula$,hex$("94"),'"') !:
            let doc_formula$(formula_no)=formula$
19300     end if  ! ~ DOC_CODE$=FORMULA_CODE$ THEN
19302   loop while formula_code$=doc_code$
19304 XIT_GET_FORMULA: ! Old Unused Formulas have been removed
19306   let fnget_formula=udim(doc_formula$)
19308 fnend 
19310 SETUP_FORMULA: ! r: Setup Formula Information
19312 if ~setup_formala then 
19314   open #formula_handle:=fngethandle_: "NAME=FORMULA.INT//9,KFNAME=FORMULA.IDX//9,USE,RECL=212,KPS=1/9,KLN=8/4,SHR",internal,outin,keyed 
19316   let setup_formula=1
19318 end if  ! ~SETUP_FORMALA THEN
19320 return ! /r
19330 def library fndebt_flip$*60(flip$*60;case$*1)
19332   let fndebt_flip$=fndebt_flip_$(flip$,case$)
19334 fnend 
19340 def fndebt_flip_$*60(flip$*60;case$*1)
19342 ! This library will take a standard Last Name/First Debtor & swap it to plain English 1st/Last
19344   let x=pos(flip$,"/",1): let y=len(flip$)
19346   if x>0 then let flip$=rtrm$(flip$(x+1:y))&" "&flip$(1:x-1)
19348   if case$="U" then let flip$=uprc$(flip$)
19350   let fndebt_flip_$=rpad$(flip$,y)
19352 fnend 
19360 !_____
19362 def library fnis_nwp(ix_prn$*80)
19364   let fnis_nwp=fnisnwp(ix_prn$)
19366 fnend 
19370 def fnisnwp(ix_prn$*80)
19372 ! This function returns a 1 if the Prnter is NWP, else 0
19374   let set_fnix=0
19376   let ix_prn$=trim$(uprc$(ix_prn$))
19378   if ix_prn$(1:4)="NWP-" or ix_prn$(1:4)="WIN-" then let set_fnix=1
19380   let fnisnwp=set_fnix
19382 fnend 
19390 def library fnis_pcl(ix_prn$*80)
19392   let fnis_pcl=fnispcl(ix_prn$)
19394 fnend 
19400 def fnispcl(ix_prn$*80)
19402 ! This function returns a 1 if the Prnter is PCL, else 0
19404   let set_fnix=0
19406   let ix_prn$=trim$(uprc$(ix_prn$))
19408   if ix_prn$(1:2)="HP" then let set_fnix=1
19410   let fnispcl=set_fnix
19412 fnend 
19420 def library fnis_html(ix_prn$*80)
19422   let fnis_html=fnishtml(ix_prn$)
19424 fnend 
19430 def fnishtml(ix_prn$*80)
19432 ! This function returns a 1 if the Prnter is HTML, else 0
19434   let set_fnix=0
19436   let ix_prn$=trim$(uprc$(ix_prn$))
19438   if ix_prn$(1:4)="HTML" then let set_fnix=1
19440   let fnishtml=set_fnix
19442 fnend 
19450 def library fnask_date_range(cap$*80,pk$*80,prompt$*40,mat adr_date; adr_no_close)
19452   if ~cls_setup then let fnclssetup
19454   let fnask_date_range=fn_ask_date_range(cap$,pk$,prompt$,mat adr_date, adr_no_close)
19456 fnend  ! FnAsk_Date_Range
19460 def fn_ask_date_range(cap$*80,pk$*80,prompt$*40,mat adr_date; adr_no_close)
19462 ! This function returns FKey=93, FKey=99, or mat Adr_Date$ (1)=Starting Date, (2)=Ending Date   (in CCYYMMDD format)
19464 ! ADR_No_Close =1 tells the window not to close.  The window will remain open, but disabled after the function exits, however any buttons will still be removed
19466   dim adr_field_pos$*128,adr_inp_date$(2)*10
19468   let fndisplaytop(cap$,pk$)
19470   gosub ERASE_BUTTONS
19472   mat adr_date(2) : mat adr_date$(2)
19474   open #adr_win:=fngethandle_: fnwindow_this_size$(adr_win_height=4,adr_win_width=28,"Center")&",Border=S,Tab="&prompt$,display,output 
19476   print #adr_win: newpage
19478   print #adr_win,fields "2,2,Cr 14,[W];3,2,Cr 14,[W]": "Starting Date:","Ending Date:"
19480   let adr_field_pos$="2,17,C 10,[D]STe;3,17,C 10,[D]Se"
19482   let adr_date$(1)=fndate10_$(str$(adr_date(1)))
19484   let adr_date$(2)=fndate10_$(str$(adr_date(2)))
19486   let fngenerate_buttons_("0,99","OK,Cancel",2,0,1) ! let Fngenerate_Buttons("0,5,99","OK,Calendar,Cancel",2,0,1)
19488 ADR_ASK: ! 
19490   let adr_inp_date$(1)=fndate_inpdis10_$(adr_date$(1))
19492   let adr_inp_date$(2)=fndate_inpdis10_$(adr_date$(2))
19494   rinput #adr_win,fields adr_field_pos$,attr "[A]": mat adr_inp_date$
19496 ! 
19498   if fkey<>93 and fkey<>99 then 
19500     let adr_date$(1)=fndate_inp10_$(adr_inp_date$(1))
19502     let adr_date$(2)=fndate_inp10_$(adr_inp_date$(2))
19504   end if  ! fkey<>93 and fkey<>99
19506 ! 
19508   print #adr_win,fields fnfield_disable$(adr_field_pos$): fndate_dis10_$(adr_date$(1)),fndate_dis10_$(adr_date$(2))
19510   if trim$(adr_inp_date$(1)&adr_inp_date$(2))='' then let fkey(99)
19512   if fkey=93 or fkey=99 then 
19514     mat adr_date$(0)
19516   else 
19518     if adr_date$(1)='' or pos(adr_inp_date$(1),'*')>0 or pos(adr_inp_date$(1),'?')>0 then let curfld(1) : goto ADR_ASK
19520     if adr_date$(2)='' or pos(adr_inp_date$(2),'*')>0 or pos(adr_inp_date$(2),'?')>0 then let curfld(2) : goto ADR_ASK
19522     if fkey>99 and fkey<120 then let curfld(curfld,fkey) : goto ADR_ASK
19524     if fkey<>0 then goto ADR_ASK
19526     let adr_date(1)=fndate10_(adr_date$(1))
19528     let adr_date(2)=fndate10_(adr_date$(2))
19530   end if  ! Fkey=93 Or Fkey=99
19532   gosub ERASE_BUTTONS
19534   if ~adr_no_close then close #adr_win: 
19536 fnend  ! Fn_Ask_Date_Range
19540 def library fndate_month_prior_end
19542   let fndate_month_prior_end=fn_date_month_prior_end
19544 fnend  ! FnDate_Month_Prior_End
19550 def fn_date_month_prior_end ! DMPE_
19552   let dmpe_month=date('mm')
19554   let dmpe_year=date('ccyy')
19556   if dmpe_month=1 then let dmpe_month=12 : let dmpe_year-=1 : else let dmpe_month-=1
19558   let fn_date_month_prior_end=val(str$(dmpe_year)&cnvrt$("Pic(##)",dmpe_month)&cnvrt$("Pic(##)",fn_days_in_month(dmpe_month,dmpe_year)))
19560 fnend  ! fn_Date_Month_Prior_End
19570 def fn_days_in_month(dim_month,dim_ccyy) ! DIM_
19572   if dim_month=12 then let dim_month=1 : let dim_ccyy+1 else let dim_month+=1
19574   let dim_month$=cnvrt$('Pic(##)',dim_month)
19576   let dim_ccyy$=str$(dim_ccyy)
19578   let set_dim=val(date$(days(dim_ccyy$&dim_month$&'01','ccyymmdd')-1,'ccyymmdd')(7:8))
19580   let fn_days_in_month=set_dim
19582 fnend  ! fn_Days_In_Month(DIM_Month,DIM_CCYY)
19590 def library fndate_month_prior_start
19592   let fndate_month_prior_start=fn_date_month_prior_start
19594 fnend  ! FnDate_Month_Prior_Start
19600 def fn_date_month_prior_start ! DMPS_
19602   let dmps_tmp$=str$(fn_date_month_prior_end)
19604   let fn_date_month_prior_start=val(dmps_tmp$(1:6)&'01')
19606 fnend  ! fn_Date_Month_Prior_Start
19610 def library fnask_amount1(&aa1_response,aa1_cap$*80; aa1_response_len,aa1_prompt$*80,aa1_fhelp$*1024,aa1_response_min,aa1_response_max,aa1_noclose,aa1_nocancel)
19612   let fnask_amount1=fn_ask_amount1(aa1_response,aa1_cap$, aa1_response_len,aa1_prompt$,aa1_fhelp$,aa1_response_min,aa1_response_max,aa1_noclose,aa1_nocancel)
19614 fnend  ! FnAsk_Amount1
19620 def library fnask_amount_range(aar_return,aa1_response_min,aa1_response_max,aa1_cap$*80,aar_prompt$*80; aar_response_len) ! Aar_
19622   let fn_ask_amount1(aar_return,aa1_cap$, aar_response_len,aar_prompt$,'',aa1_response_min,aa1_response_max,0,1)
19624   let fnask_amount_range=aar_return
19626 fnend  ! Fnask_Amount_Range
19630 def fn_ask_amount1(&aa1_response,aa1_cap$*80; aa1_response_len,aa1_prompt$*80,aa1_fhelp$*1024,aa1_response_min,aa1_response_max,aa1_noclose,aa1_nocancel) ! Aa1_
19635 ! ADR_No_Close =1 tells the window not to close.  The window will remain open, but disabled after the function exits, however any buttons will still be removed
19640 ! Aa1_NoCancel =1 no cancel option - user may only go forward
19645   let aa1_original_default=aa1_response
19650   if aa1_response_len=0 then let aa1_response_len=14.2
19655   let aa1_prompt$=trim$(aa1_prompt$) : let prompt_len=len(aa1_prompt$)
19660   if aa1_prompt$(prompt_len:prompt_len)<>":" then let aa1_prompt$=aa1_prompt$&':' : let prompt_len+=1
19665   let fnsessionsize_setup(screen_height,screen_width)
19670   let aa1_win_cols=1+prompt_len+1+int(aa1_response_len)
19675   let aa1_win_scol=int((screen_width-aa1_win_cols)/2)
19680   let response_pos=1+prompt_len+1
19685   let button_ok_pos=aa1_win_cols-20
19690   let button_cancel_pos=aa1_win_cols-10
19695   let aa1_win_rows=4
19700   let aa1_win_srow=int((screen_height-aa1_win_rows)/2)
19705   open #aa1_win:=fngethandle_: "SRow="&str$(aa1_win_srow)&",SCol="&str$(aa1_win_scol)&",Cols="&str$(aa1_win_cols)&",Rows="&str$(aa1_win_rows)&",Border=S,Tab="&aa1_cap$,display,output 
19710   print #aa1_win: newpage
19715   gosub ERASE_BUTTONS
19720   if aa1_nocancel then !:
          let fngenerate_buttons_("0","OK",2,0,1) ! let Fngenerate_Buttons("0,5,99","OK,Calendar,Cancel",2,0,1) !:
        else !:
          let fngenerate_buttons_("0,99","OK,Cancel",2,0,1) ! let Fngenerate_Buttons("0,5,99","OK,Calendar,Cancel",2,0,1)
19725   print #aa1_win,fields "2,2,Cr "&str$(prompt_len)&",[W]": aa1_prompt$
19730   if aa1_nocancel then !:
          print #aa1_win,fields str$(aa1_win_rows)&","&str$(button_cancel_pos)&",Cc 8,[P]S,B0": "OK" !:
        else !:
          print #aa1_win,fields str$(aa1_win_rows)&","&str$(button_ok_pos)&",Cc 8,[P]S,B0": "OK" !:
          print #aa1_win,fields str$(aa1_win_rows)&","&str$(button_cancel_pos)&",Cc 8,[P]S,B99": "Cancel"
19735 AA1_ASK: ! 
19740   rinput #aa1_win,fields "2,"&str$(response_pos)&",Nz "&str$(aa1_response_len)&",[D]STAE",attr "[A]",help aa1_fhelp$: aa1_response conv AA1_ASK
19745   print #aa1_win,fields "2,"&str$(response_pos)&",N "&str$(aa1_response_len)&",[P]SP": aa1_response
19750   if (aa1_response_min<>0 and aa1_response<aa1_response_min) or (aa1_response_max<>0 and aa1_response>aa1_response_max) then !:
          let fnmessagebox_('The amount you entered ('&trim$(cnvrt$('Nz '&str$(aa1_response_len),aa1_response))&') is invalid.\nPlease select an amount between '&trim$(cnvrt$('N '&str$(aa1_response_len),aa1_response_min))&' and '&trim$(cnvrt$('Nz '&str$(aa1_response_len),aa1_response_max))&'.',mb_exclamation+mb_okonly,aa1_cap$) !:
          let aa1_response=aa1_original_default !:
          goto AA1_ASK
19755   if aa1_nocancel and (fkey=93 or fkey=99) then !:
          print bell; !:
          goto AA1_ASK
19760   gosub ERASE_BUTTONS
19765   if aa1_noclose then close #aa1_win,free: else close #aa1_win: 
19770   if ~aa1_nocancel and (fkey=93 or fkey=99) then let aa1_return=-1 else let aa1_return=1
19775   let fn_ask_amount1=aa1_return
19780 fnend  ! Fn_Ask_Amount1
19790 def library fnddate$(dait$)
19792   let fnddate$=fnddate_$(dait$)
19794 fnend 
19800 def fnddate_$(dait$)
19802   if ~cls_setup then let fnclssetup
19804   let old_date=pos(dait$,"/")
19806   let dait$=trim$(srep$(dait$,"/","")) !:
        if trim$(dait$)="" then goto L19820
19808   if old_date>0 and len(dait$)=6 then !:
          let tdait=fndate8_(dait$) !:
          let dait$=date$(days(tdait),"CYMD"): goto L19818 else !:
          if len(dait$)=8 then goto L19818
19810   if dait$(1:2)="19" or dait$(1:2)="20" or (len(dait$)=1 and (dait$="1" or dait$="2")) then let fnddate_$=dait$ !:
          goto L19820
19812   if dait$(1:2)=base_year$(3:4) or (len(dait$)=1 and (dait$=base_year$(1:1))) then let fnddate_$=dait$ !:
          goto L19820
19814   if len(dait$)>10 then let dait$=""
19816   let tdait$=rpad$(dait$(1:2),2,"0")&"/12/31" !:
        let tcentury$=fndate10_$(tdait$)(1:2) !:
        let dait$=tcentury$&dait$
19818 L19818: let fnddate_$=dait$
19820 L19820: fnend 
19830 def library fnpdate$(dait$)
19832   let dait$=rpad$(fndate8_$(dait$),8)
19834   let fnpdate$=dait$
19836 fnend 
19838 def library fndtime$
19840   let fndtime$="@@:@@"
19842 fnend 
19844 def library fnfix_pd(mat fixpd) ! CM 7.3 changed this function to check only for FIXPD(Z)= -202020202.02 !:
        ! We may have to add a few more specifics!
19846   let fnfix_pd=fnfixpd(mat fixpd)
19848 fnend  ! fnFix_PD
19850 def fnfixpd(mat fixpd)
19852   for z=1 to udim(fixpd) : if fixpd(z)=-202020202.02 then let fixpd(z)=0
19854   next z
19856 fnend 
19858 def library fnfix_bh(mat fixbh)
19860   let fnfix_bh=fnfixbh(mat fixbh)
19862 fnend 
19864 def fnfixbh(mat fixbh)
19866   for z=1 to udim(fixbh)
19868     if fixbh(z)= 5389762.88 or fixbh(z)= 538976288 or fixbh(z)= -202020202.02 or fixbh(z)=202020202.02 then !:
            let fixbh(z)=0
19870   next z
19872 fnend 
19874 def library fnfix_bh2(mat fixbh2)
19876   let fnfix_bh2=fnfixbh2(mat fixbh2)
19878 fnend 
19880 def fnfixbh2(mat fixbh2)
19882   for z=1 to udim(fixbh2)
19884     if fixbh2(z)= 8224 then !:
            let fixbh2(z)=0
19886   next z
19888 fnend 
19890 def fnfix3pd(&mat fixpd)
19892   for z=1 to udim(fixpd) : if fixpd(z)<=0 then let fixpd(z)=0 else !:
            if fixpd(z)>999999 then let fixpd(z)=0
19894   next z
19896 fnend 
19898 def library fnfix_bh3(mat fixbh3)
19900   let fnfix_bh3=fnfixbh3(mat fixbh3)
19902 fnend 
19904 def fnfixbh3(mat fixbh3)
19906   for z=1 to udim(fixbh3)
19908     if fixbh3(z)= 2105376 then !:
            let fixbh3(z)=0
19910   next z
19912 fnend 
19920 def library fnhtml_to_string(&hts_html_source$)
19922   let fnhtml_to_string=fn_html_to_string(hts_html_source$)
19924 fnend  ! FnHtml_To_String
19930 def fn_html_to_string(&hts_html_source$) ! Hts_
19935   dim hts_return$*32000
19940   let hts_return$=hts_html_source$
19945   let hts_pos_amp=pos(hts_return$,'&')
19950   do 
19955     let hts_pos_semi=pos(hts_return$,';')
19960     if hts_pos_amp>0 and hts_pos_semi<=0 and env$("GUIMODE")="ON" then !:
            let hts_return$(hts_pos_amp:hts_pos_amp)="&amp;" !:
            ! & should have been &amp; - Replace for Compatibility
19965     if hts_pos_amp>0 then 
19970       if hts_return$(hts_pos_amp+2:hts_pos_amp+2)='x' then ! use hexidecimal translation
19975         for hts_chr=1 to 256
19980           let hts_return$(hts_pos_amp:hts_pos_semi)=uprc$(hts_return$(hts_pos_amp:hts_pos_semi)) ! convert things like '&#x3a3;' to '&#x3A3;'
19985           let hts_return$=srep$(hts_return$,'&#'&fndec2hex_$(hts_chr)&';',chr$(hts_chr))
19990         next hts_chr
19995       else ! use decimal translation
20000         for hts_chr=1 to 256
20005           do  ! convert things like '&#0931;' to '&#931;'
20010             let hts_return$=srep$(hts_return$,'&#0','&#')
20015           loop until pos(hts_return$,'&#0')<=0
20020           let hts_return$=srep$(hts_return$,'&#'&str$(hts_chr)&';',chr$(hts_chr))
20025         next hts_chr
20030       end if  ! Hts_Return$(Hts_Pos_Amp+2:Hts_Pos_Amp+2)='x'   /   else 
20035     end if  ! Hts_Pos_Amp>0
20040     let hts_return$=srep$(hts_return$,'&quot;','"') ! quotation mark
20045     let hts_return$=srep$(hts_return$,'&apos;',"'") ! apostrophe
20050     let hts_return$=srep$(hts_return$,'&lt;','<') ! less than
20055     let hts_return$=srep$(hts_return$,'&gt;','>') ! greater than
20060     let hts_pos_amp=fn_pos_not_followed_by(hts_return$,'&','amp;')
20065   loop while hts_pos_amp>0
20070   let fn_unicode_to_ansi(hts_return$)
20075   let hts_return$=srep$(hts_return$,'&amp;','&') ! ampersand
20080   let hts_return$=srep$(hts_return$,hex$("92"),"'") ! " (Fancy Open)!:
        let hts_return$=srep$(hts_return$,hex$("93"),'"') ! " (Fancy Open)!:
        let hts_return$=srep$(hts_return$,hex$("94"),'"') ! " (Fancy Close)
20085   let hts_html_source$=hts_return$ !:
        ! Function simply returns 0
20089 fnend  ! Fn_Html_To_String
20090 def fn_pos_not_followed_by(pnfb_string$*4096,pnfb_find$*128,pnfb_not_followed_by$*256) ! Pnfb_
20092 ! This function returns the position of the first instance of Pnfb_Find$ which is not followed by Pnfb_Not_Followed_By$.  if no such cases are found this function returns -1.
20094   let pnfb_string_len=len(pnfb_string$)
20096   let pnfb_not_followed_by_len=len(pnfb_not_followed_by$)
20098   let pnfb_search_pos=0
20100   do 
20102     let pnfb_pos=pos(pnfb_string$,pnfb_find$,pnfb_search_pos)
20104     if pnfb_pos=0 then 
20106       let pnfb_pos=-1
20108     else if pnfb_pos>0 then 
20110       if pnfb_string$(pnfb_pos:pnfb_pos+pnfb_not_followed_by_len-1)=pnfb_not_followed_by$ then 
20112         let pnfb_search_pos=pnfb_pos+1
20114         let pnfb_pos=-1
20116       end if 
20118     end if  ! Pnfb_Pos=0   /   >0
20120   loop until pnfb_search_pos>=pnfb_string_len or pnfb_pos<>0
20122   let fn_pos_not_followed_by=pnfb_search_pos
20124 fnend  ! Fn_Pos_Not_Followed_By
20130 def library fnrename$(file_name$*80)
20135   let dir$="" : let x=pos(file_name$,"/") !:
        if x<=0 then goto L20145
20140   let dir$=trim$(file_name$(x:99))
20145 L20145: let ext=pos(file_name$,".") !:
        if ext<=0 then goto L20160
20150   let ext$=file_name$(ext:80)
20155   let file_name$=file_name$(1:ext-1)
20160 L20160: let month$=date$("m")
20165   if month$(1:1)="0" then let month$=month$(2:2)
20170   if date("m")=10 then let month$="O" ! October
20175   if date("m")=11 then let month$="N" ! November
20180   if date("m")=12 then let month$="D" ! December
20185   let suffix$="."&month$&date$("d")
20190   if exists(file_name$&suffix$) then !:
          execute "copy "&file_name$&suffix$&" "&file_name$&".old" !:
          execute "free "&file_name$&suffix$
20195   execute "rename "&file_name$&ext$&" "&srep$(file_name$,dir$,"")&suffix$&dir$
20200 fnend 
20210 ! ---------LIBRARY----------FNXLATE_TABLE()-----------------------------
20212 def library fnxlate_table(template$*80,mat xlt_from$,mat xlt_to$;no_trim_option)
20214   let fnxlate_table=fnxlatetable(template$,mat xlt_from$,mat xlt_to$,no_trim_option)
20216 fnend 
20220 def fnxlatetable(template$*80,mat xlt_from$,mat xlt_to$;no_trim_option)
20225   dim temp_from$*80,temp_to$*80,temp_buff$*256
20230   mat xlt_from$(0)=("") !:
        mat xlt_to$(0)=("") !:
        let xlt_count=0
20235   let is_available=fngetdisplay_(trim$(template$&".XLT/custom"))
20240   if is_available=0 then !:
          let is_available=fngetdisplay_(trim$(template$&".XLT/REPORTS/5"))
20245   if is_available=0 then goto DONE_IS_AVAILABLE
20250 ! 
20255 NEXT_IS_AVAILABLE: ! !:
        linput #is_available: temp_buff$ ioerr DONE_IS_AVAILABLE
20260   let xpos=pos(temp_buff$,chr$(9)) !:
        if xpos<=0 then let xpos=len(temp_buff$)+1
20265   if no_trim_option then !:
          let temp_from$=temp_buff$(1:xpos-1) !:
          let temp_to$=temp_buff$(xpos+1:999) else !:
          let temp_from$=trim$(temp_buff$(1:xpos-1)) !:
          let temp_to$=trim$(temp_buff$(xpos+1:999))
20270   let xlt_count+=1 !:
        mat xlt_from$(xlt_count) : mat xlt_to$(xlt_count) !:
        let xlt_from$(xlt_count)=temp_from$: let xlt_to$(xlt_count)=temp_to$
20275   goto NEXT_IS_AVAILABLE
20280 ! 
20285 DONE_IS_AVAILABLE: if file(is_available)>0 then close #is_available: 
20290   let is_ava2=fngetdisplay_(trim$(template$&".XLT/CustRpt/5"))
20295   if is_ava2=0 then goto DONE_IS_AVA2
20300 ! 
20305 NEXT_IS_AVA2: ! !:
        linput #is_ava2: temp_buff$ ioerr DONE_IS_AVA2
20310   let xpos=pos(temp_buff$,chr$(9)) !:
        if xpos<=0 then let xpos=len(temp_buff$)+1
20315   if no_trim_option then !:
          let temp_from$=temp_buff$(1:xpos-1) !:
          let temp_to$=temp_buff$(xpos+1:999) else !:
          let temp_from$=trim$(temp_buff$(1:xpos-1)) !:
          let temp_to$=trim$(temp_buff$(xpos+1:999))
20320   let alreadythere=srch(xlt_from$,temp_from$)
20325   if alreadythere>0 then 
20330     let xlt_from$(alreadythere)=temp_from$ : let xlt_to$(alreadythere)=temp_to$
20335   else 
20340     mat xlt_from$(xlt_count+=1) : mat xlt_to$(xlt_count) !:
          let xlt_from$(xlt_count)=temp_from$ : let xlt_to$(xlt_count)=temp_to$
20345   end if 
20350   goto NEXT_IS_AVA2
20355 ! 
20360 DONE_IS_AVA2: ! 
20365   let fnxlatetable=xlt_count
20370 fnend 
20380 def library fnrange_to_array(rta_source$*4096,mat rta_output) ! Rta_
20382   gosub SETUP_LIBRARY
20384   let fnrange_to_array=fn_range_to_array(rta_source$,mat rta_output)
20386 fnend  ! fnRange_To_Array
20390 def fn_range_to_array(&rta_source$,mat rta_output) ! Rta_
20395 ! this routine does not allow or account for negative numbers, decimals, this routine will not
20400   if ~xlate_setup then let fnxlate_setup
20405 ! let Rta_Source$=Xlate$(Rta_Source$,Csv_Whole_Number_Xlate$)
20410   let fnparse_csv_(rta_source$,mat rta_field$)
20415   mat rta_output(0)
20420   for rta_field_item=1 to udim(mat rta_field$)
20425     let rta_dash_pos=pos(rta_field$(rta_field_item),'-')
20430     if rta_dash_pos>0 then ! it's a range
20435       let rta_num_low=fnval_(rta_field$(rta_field_item)(1:rta_dash_pos-1))
20440       let rta_num_high=fnval_(rta_field$(rta_field_item)(rta_dash_pos+1:len(rta_field$(rta_field_item))))
20445       for rta_num=rta_num_low to rta_num_high
20450         let fn_add_one(mat rta_output,rta_num,1,1)
20455       next rta_num
20460     else ! it's just a number
20465       let fn_add_one(mat rta_output,fnval_(rta_field$(rta_field_item)),1,1)
20470     end if  ! Rta_Dash_Pos>0   /   else 
20475   next rta_field_item
20480   let fnarray_sort(mat rta_output)
20485 fnend  ! fnRange_To_Array
20490 def library fnarray_to_range$*256(mat atr_array)
20492   gosub SETUP_LIBRARY
20494   let fnarray_to_range$=fn_array_to_range$(mat atr_array)
20496 fnend  ! FnArray_To_Range$
20500 def fn_array_to_range$*256(mat atr_array)
20505   dim atr_return$*256,atr_tmp$(1)
20510   let atr_return$=''
20515   let fnarray_sort(mat atr_array)
20520   let atr_return$=''
20525   if udim(mat atr_array)>0 then 
20530     mat atr_tmp$(atr_tmp_count=1)
20535     let atr_tmp$(atr_tmp_count)=str$(atr_array(1))
20540     for atr_array_item=2 to udim(mat atr_array)
20545       if atr_array(atr_array_item)-1=atr_array(atr_array_item-1) then 
20550         if atr_tmp$(atr_tmp_count)='' then 
20555           let atr_tmp$(atr_tmp_count)
20560         else 
20565           let atr_tmp_pos_dash=pos(atr_tmp$(atr_tmp_count),'-')
20570           if atr_tmp_pos_dash>0 then 
20575             let atr_tmp$(atr_tmp_count)=atr_tmp$(atr_tmp_count)(1:atr_tmp_pos_dash-1)
20580           end if  ! Atr_Tmp_Pos_Dash>0
20585           let atr_tmp$(atr_tmp_count)=atr_tmp$(atr_tmp_count)&'-'&str$(atr_array(atr_array_item))
20590         end if  ! Atr_Tmp$(Atr_Tmp_Count)=''   /   else 
20595 !   add or update last Atr_Tmp$(Atr_Tmp_Count)
20600       else 
20605         mat atr_tmp$(atr_tmp_count+=1)
20610         let atr_tmp$(atr_tmp_count)=str$(atr_array(atr_array_item))
20615       end if  ! Atr_Array(Atr_Array_Item)-1=Atr_Array(Atr_Array_Item-1)   /   else 
20620     next atr_array_item
20625     for atr_tmp_item=1 to atr_tmp_count
20630       let atr_return$=atr_return$&','&atr_tmp$(atr_tmp_item)
20635     next atr_tmp_item
20640     let atr_return$=trim$(atr_return$,',')
20645   end if  ! udim(Mat Atr_Array)>0
20650   let fn_array_to_range$=atr_return$
20655 fnend  ! Fn_Array_To_Range$
20660 ! ---------LIBRARY----------FNXLATE$()----------------------------------
20662 def library fnxlate$*2048(source$*2048,mat temp_from$,mat temp_to$)
20664   let fnxlate$=fnxlate_$(source$,mat temp_from$,mat temp_to$)
20666 fnend 
20670 def fnxlate_$*2048(source$*2048,mat temp_from$,mat temp_to$)
20672   for z_xlt=1 to udim(temp_from$) !:
          let source$=srep$(source$,temp_from$(z_xlt),temp_to$(z_xlt)) !:
        next z_xlt
20674   let fnxlate_$=source$
20676 fnend 
20680 ! ---------LIBRARY----------FNSQL_INT()---------------------------------
20690 def library fnsql_int(mat master_data$,mat master_data,mat master_fieldsc$,mat master_fieldsn$;thrudat$,&si_numdays_,&si_int_base,&si_stored_int,&si_intrate,&si_collord$,&si_bpj$,&si_state$,&si_fileno$)
20700 ! This Function will calculatea and interest using "SQL" Data information !:
        ! Optionally, Thrudat$,&Si_Numdays_,&Si_Int_Base,&Si_Stored_Int,&Si_Intrate,&Si_Collord$,&Si_Bpj$,&Si_State$,&Si_Fileno$ will be calculated & returned
20710   if ~master_common then let fnmaster_common
20720   let fnsql2_master !:
        ! ** POPULATE THE ARRAY VARIABLES FROM "SQL"
20730   let _fnsql_int=fn_recalc_int(master_data$(master_suit_date),master_data$(master_jmt_date),forw,venue,master_data$(master_d1_cs),master_data$(master_collord),idate$,stored_int,mat rates,amt6,mat filerec,mat frec,thrudat$,si_numdays_,si_intrate,si_int_base,si_collord$,si_bpj$,si_state$,fileno$)
20740   let master_data(master_per_diem_date)=frec(41) !:
        let master_data(master_per_diem_amt)=frec(42) !:
        let master_data(master_per_diem_rate)=frec(43) !:
        let master_data(master_per_diem_base)=frec(44) !:
        let master_data(master_per_diem_int)=frec(45)
20741   let si_stored_int=stored_int !:
        let si_fileno$=fileno$
20750   let fnsql_int=round(_fnsql_int,2) ! Always Report Interest Rounded to the nearest Penny (Use Master_Data(Master_Per_Diem_Int) or FREC(45) if you really wanted many decimal accuracy)
20790 fnend 
20800 def library fnexe_cache(ec_exe$*256,ec_parameter$*256)
20802   let fnexe_cache=fn_exe_cache(ec_exe$,ec_parameter$)
20804 fnend  ! fnexe_cache
20810 def fn_exe_cache(ec_exe$*256,ec_parameter$*256) ! ec_
20815   dim ec_env_name$*256 ! environment variable name
20820   dim ec_env_value$*256 ! environment variable value
20825   dim ec_exe_alt$*256 ! *new* alternate envoronment variable value - the local one that will be used if possible
20830   dim ec_exe_path$*256, ec_exe_name_base$*64, ec_exe_ext$*18 ! for fnfilepath_parse
20835 ! 
20840   let ec_env_name$="CLS_Exe_"&ec_exe$
20845   let ec_env_name$=srep$(ec_env_name$,'\','_')
20850   let ec_env_name$=srep$(ec_env_name$,'.','_')
20855 ! let ec_env_name$=srep$(ec_env_name$,':','_') ! todo: consider rejecting full paths
20860 ! let ec_env_name$=srep$(ec_env_name$,'/','_') ! todo: consider turning these around or rejecting them all together.
20865 ! 
20870   let fn_filepath_parse(ec_exe$, ec_exe_path$, ec_exe_name_base$, ec_exe_ext$)
20875   let ec_env_value$=env$(ec_env_name$)
20880   if ec_env_value$='' or ~exists(ec_env_value$) or (uprc$(ec_exe_name_base$)='VBNOTE' and (~exists(env$("Client_Temp")&"\CLS\Exe\VB32\Grid.exe") or ~exists(env$("Client_Temp")&"\CLS\Exe\VB32\vbCal.exe"))) then 
20885     let ec_exe_alt$=env$("Client_Temp")&"\CLS\Exe\"&ec_exe_path$
20890     let fn_make_dir(ec_exe_alt$)
20895 !   pr 'ec_exe_alt$=';ec_exe_alt$ : pause
20900     let ec_exe_alt$(32767:0)='\'&ec_exe_name_base$&'.'&ec_exe_ext$
20905     execute 'Copy '&ec_exe$&' '&ec_exe_alt$&' -n' ioerr EC_COPY_FAILURE
20910     let ec_env_value$=ec_exe_alt$
20915     if uprc$(ec_exe_name_base$)="VBNOTE" then 
20920       execute 'Copy vb32\grid.exe '&env$("Client_Temp")&"\CLS\Exe\VB32\Grid.exe -n" ioerr EC_GRID_COPY_FAILURE
20925       let setenv("CLS_EXE_VB32_GRID_EXE",env$("Client_Temp")&"\CLS\Exe\VB32\Grid.exe")
20930       execute 'Copy vb32\vbCal.exe '&env$("Client_Temp")&"\CLS\Exe\VB32\vbCal.exe -n" ioerr EC_GRID_COPY_FAILURE
20935       let setenv("CLS_EXE_VB32_VBCAL_EXE",env$("Client_Temp")&"\CLS\Exe\VB32\vbCal.exe")
20940       goto EC_GRID_COPY_SUCCESS
20945 EC_GRID_COPY_FAILURE: ! 
20950 !     print 'we have a problem.  copied vbnote.exe but failed on grid.exe'
20955       let setenv("CLS_EXE_VB32_GRID_EXE","VB32\Grid.exe")
20960       let setenv("CLS_EXE_VB32_VBCAL_EXE","VB32\vbCal.exe")
20965       goto EC_COPY_FAILURE
20970 EC_GRID_COPY_SUCCESS: ! 
20975     end if  ! uprc$(ec_exe_name_base$)="VBNOTE"
20980     goto EC_COPY_SUCCESS
20985 EC_COPY_FAILURE: ! 
20990     let ec_env_value$=ec_exe$
20995 EC_COPY_SUCCESS: ! 
21000     let setenv(ec_env_name$,ec_env_value$)
21005   end if  ! env$("CLS_Exe")=''
21010   let fn_exe('-w QUOTE=NONE',ec_env_value$,ec_parameter$)
21015 fnend  ! fn_exe_cache
21020 ! ---------LIBRARY----------FNINT()-------------------------------------
21030 def library fnint(jdate$,stored_int,numdays_,intrate,mat accard;mat accard_frec)
21031   print "Warning, FNINT is a Legacy Function, please enhance the calling program!" : pause 
21040   let _fnint_base=fnint_base_(jdate$,mat accard) !:
        let _fnint_per_diem=fnplus_(intrate*(_fnint_base))/100 !:
        let _fnint=stored_int+numdays_* _fnint_per_diem
21050   let accard_frec(41)=date("CCYYMMDD") error L21060 !:
        let accard_frec(42)=_fnint_per_diem !:
        let accard_frec(43)=round(intrate*365,2) !:
        let accard_frec(44)=round(_fnint_base,2) !:
        let accard_frec(45)=_fnint ! Per_DIEM_Int should never be rounded.
21060 L21060: let fnint=_fnint
21070 fnend 
21080 ! --------------------------FNPLUS_()-----------------------------------
21082 def fnplus_(amount)
21083   let fnplus_=max(amount,0)
21084 fnend 
21086 ! ---------LIBRARY----------FNPLUS()------------------------------------
21088 def library fnplus(amount)
21090   let fnplus=max(amount,0)
21092 fnend 
21100 ! --------------------------FNINT_BASE_()-------------------------------
21110 def fnint_base_(jdate$,mat accard)
21120   if ~cls_setup then let fnclssetup
21130   if rtrm$(jdate$)="" then !:
          let fnint_base_=fnplus_(accard(5)-fnplus_(accard(3)*oi_stat-accard(20)*oi_stat)-fnplus_(accard(16)*oi_costs-accard(17)*oi_costs)) else !:
          let fnint_base_=fnplus_(accard(5)-fnplus_(accard(3)*oij_stat-accard(20)*oij_stat)-fnplus_(accard(16)*oij_costs-accard(17)*oij_costs))
21140 fnend  ! ---------------------------------------------------------------
21150 def library fnint_base(jdate$,mat accard)
21151   print "Warning, FNINT_BASE is a Legacy Function, please enhance the calling program!" : pause 
21152   let fnint_base=fnint_base_(jdate$,mat accard)
21154 fnend 
21160 def library fnint_base_sql(mat master_data$,mat master_data)
21161   print "Warning, FNINT_BASE_SQL is a Legacy Function, please enhance the calling program!" : pause 
21162   if ~master_common then let fnmaster_common
21164   let fnsql2_master
21166   let int_base=fnint_base_(jdate$,mat filerec)
21168   let fnint_base_sql=int_base
21170 fnend  ! fnInt_Base_SQL
21180 ! fdx (fn doc xml [used])
21182 def library fnfinan_trans_get_sql(&ftgs_finan_handle,ftgs_fileno$,ftgs_trans_date,ftgs_code,ftgs_refno,mat finan_data$,mat finan_data) ! ftgs_
21184   gosub SETUP_LIBRARY
21186   gosub SETUP_CONSTANTS
21188   if ~setup_sql then gosub SETUP_SQL
21190   let fnfinan_trans_get_sql=fn_finan_trans_get_sql(ftgs_finan_handle,ftgs_fileno$,ftgs_trans_date,ftgs_code,ftgs_refno,mat finan_data$,mat finan_data)
21192 fnend  ! fnfinan_trans_get_sql
21200 def fn_finan_trans_get_sql(&ftgs_finan_handle,ftgs_fileno$,ftgs_trans_date,ftgs_code,ftgs_refno,mat finan_data$,mat finan_data) ! ftgs_
21205 ! todo: if there is an error in this function it should return a negative error number
21210   mat finan_data$=('')
21215   mat finan_data=(0)
21220   if ftgs_finan_handle<=0 or file(ftgs_finan_handle)<=-1 then 
21225     let ftgs_finan_handle=fnindex_handle("Name=I:Finan.Int,KFName=I:Finan.Idx")
21230   end if  ! ftgs_Finan_Handle<=0 Or File(ftgs_Finan_Handle)<=-1
21235   let ftgs_fileno$=rpad$(ftgs_fileno$,8)
21240   let ftgs_fileno_after$=ftgs_fileno$(1:7)&chr$(ord(ftgs_fileno$(8:8))+1)
21245   read #ftgs_finan_handle,using FORM_POS_1_C8,search>=ftgs_fileno_after$,release: ftgs_fileno_temp$ nokey FTGS_FINAN_RESTORE
21250   goto FTGS_FINAN_READ
21255 FTGS_FINAN_RESTORE: ! 
21260   restore #ftgs_finan_handle,last: 
21265 FTGS_FINAN_READ: ! 
21270   mat finan_data$=("")
21275   mat finan_data=(0)
21280   read #ftgs_finan_handle,using finan_formall$,prior,release: mat finan_data$,mat finan_data eof FTGS_NO_MATCH
21285 ! pr  'debug_read_count=';(debug_read_count+=1);' date=';Finan_Data(Finan_Trans_Date)
21290   if trim$(finan_data$(finan_fileno))<>trim$(ftgs_fileno$) then goto FTGS_NO_MATCH
21295   if ftgs_trans_date<>0 and finan_data(finan_trans_date)<=ftgs_trans_date then goto FTGS_FINAN_READ
21300   if ftgs_code<>0 and trim$(finan_data$(finan_code))<>str$(ftgs_code) then goto FTGS_FINAN_READ
21305   if ftgs_trans_date<>0 and finan_data(finan_trans_date)<>ftgs_trans_date then goto FTGS_FINAN_READ
21310   if ftgs_refno<>0 and finan_data(finan_refno)<>ftgs_refno then goto FTGS_FINAN_READ
21315   if finan_data$(finan_trans_type)='C' then 
21320     let set_ftgs=finan_data(finan_refno)
21325   else 
21330     let set_ftgs=finan_data(finan_checkno)
21335   end if  ! finan.trans_type='C'   /   else 
21340   goto FTGS_XIT
21345 FTGS_NO_MATCH: ! 
21350   let set_ftgs=0
21355   goto FTGS_XIT
21360 FTGS_XIT: ! 
21365   let fn_finan_trans_get_sql=set_ftgs
21370 fnend  ! fn_finan_trans_get_sql
21400 SQL_PRINT_METHOD: ! r: used by FNSQL_PRINT, requires:  SQL_Print_Method$ and SQL_Field$
21410 if sql_print_method$="TRIM" then 
21420   let sql_field$=trim$(sql_field$)
21430 else if sql_print_method$="RTRM" then 
21440   let sql_field$=rtrm$(sql_field$)
21450 else if sql_print_method$="LTRM" then 
21460   let sql_field$=ltrm$(sql_field$)
21470 end if  ! SQL_PRINT_METHOD$=...
21480 return  ! /r
21500 ! ---------------------- FNSQL_PRINT ---------------------------------
21510 ! Fields_NAME$="\FIELD\" --> Report Field Value - Will be replaced with new value !:
      ! UFORM$= --> Default Form for Variable (Or Empty) !:
      ! sql_FILNUM = FILE # for I/O !:
      ! FILENO$ = CLAIM FILE # !:
      ! LAST_FILENO$ = FOR CACHE PURPOSE, LAST VALUE PASSED TO FUNCTION !:
      ! mat sql_DATA$, mat sql_DATA -- Will be populated with Claim Data !:
      ! sql_FORMC$, sql_FORMN$ -- Form Statements for READ (I/O)
21520 ! mat sql_FC$(X,3) Array with detailed info about Character Fields !:
      ! (x,1)=POS !:
      ! (X,2)=POS !:
      ! FILENAME$=SQL FILE (EXAMPLE MASTER)
21530 ! Variables Modified/Returned !:
      ! SQL_FIELD$ --> RETURNED WITH NEW VALUE !:
      ! mat SQL_DATA$,MAT SQL_DATA  ! populated with data !:
      ! LAST_FILENO$ -- Changed with fileno Sent (Cache purposes) !:
      ! LOC -- Location of Variable
21540 ! Necessary Parameters !:
      ! FILENO !:
      ! LAST_FILENO !:
      ! mat sql_DATA$ !:
      ! mat sql_DATA !:
      ! sql_FORMC$ !:
      ! sql_FORMN$ !:
      ! FIELD_NAME !:
      ! sql_FC$(x,3) !:
      ! sql_FN$(x,3)
21550 ! sql_FILNUM !:
      ! BUFF1$  -- Field to be modified
21560 ! Function Modifies BUFF1$ (Report Value) !:
      ! Function Returns Report Type
21570 ! ***************** Reserved for FNSQL_PRINT *****************
21580 ! ***************** Reserved for FNSQL_PRINT *****************
21590 ! ***************** Reserved for FNSQL_PRINT *****************
21592 def library fnsql_print$(&sql_field$,uform$*28,sql_filenum,fileno$*31,&last_fileno$, mat sql_data$, mat sql_data,mat sql_fieldsc$,mat sql_fieldsn$,&sql_formc$,&sql_formn$,mat sql_fc$,mat sql_fn$;filename$,&sql_loc,notrim,sql_print_zone_filter_enable)
21594   let fnsql_print$=fn_sql_print$(sql_field$,uform$,sql_filenum,fileno$,last_fileno$, mat sql_data$, mat sql_data,mat sql_fieldsc$,mat sql_fieldsn$,sql_formc$,sql_formn$,mat sql_fc$,mat sql_fn$,filename$,sql_loc,notrim,sql_print_zone_filter_enable)
21596 fnend 
21600 def fn_sql_print$(&sql_field$,uform$*28,sql_filenum,fileno$*31,&last_fileno$, mat sql_data$, mat sql_data,mat sql_fieldsc$,mat sql_fieldsn$,&sql_formc$,&sql_formn$,mat sql_fc$,mat sql_fn$;filename$,&sql_loc,notrim,sql_print_zone_filter_enable)
21610   if ~cls_setup then let fnclssetup
21620   if sql_print_zone_filter_enable and ~setup_zone_security then gosub SETUP_ZONE_SECURITY
21630   if uform$(1:4)="PIC(" then let uform$(1:4)="" !:
          let tlen=len(uform$) !:
          let uform$(tlen:tlen)=srep$(uform$(tlen:tlen),")","") else !:
          if uform$(1:2)="C " or uform$(1:2)="N " then let uform$(1:2)=""
21640   dim sql_buff1$*60
21650   gosub SQL_READ !:
        goto SQL_PRINT_MAIN
21660 SQL_READ: if fileno$=last_fileno$ then goto L21750
21670 ! Read Report Info for SQL Report
21680   mat sql_data$=("") !:
        mat sql_data=(0)
21690   if kln(sql_filenum)>0 then !:
          let sql_sql=fngetkey(sql_filenum,fileno$,mat sql_data$,mat sql_data,sql_formc$,sql_formn$): !:
          goto L21740
21700 ! if file is relative_record, then kln(sql_filenum)=-1 !:
        ! Read REC= The use FNGETRECORD (SAME)
21710   let sql_recno=val(fileno$) conv L21740 ! !:
        ! For relative record links (IE INTERNAL DATAFILES), !:
        ! FILENO will be a numeric val containing record #
21720   read #sql_filenum,using sql_formc$,rec=sql_recno,release: mat sql_data$ ioerr L21740
21730   reread #sql_filenum,using sql_formn$,release: mat sql_data ioerr L21740
21731   if pos(uprc$(file$(sql_filenum)),"DEBTOR.INT")>0 then !:
          let fndphone2_debtor(fnopen_closed$(sql_filenum),mat sql_data$,mat sql_data)
21740 L21740: let last_fileno$=fileno$
21750 L21750: return  ! Data Has been read, process for report
21760 SQL_PRINT_MAIN: ! Data Has been Read, Process for Report
21770   let sql_print_pos_dot_2=pos(sql_field$,'.',pos(sql_field$,'.')+1) !:
        if sql_print_pos_dot_2>0 then !:
          let sql_print_method$=sql_field$(sql_print_pos_dot_2+1:len(trim$(sql_field$))-1) !:
          let sql_field$(sql_print_pos_dot_2:len(trim$(sql_field$))-1)='' !:
        else !:
          let sql_print_method$=''
21780   if notrim then let sql_buff1$=sql_field$ else let sql_buff1$=trim$(sql_field$)
21790 ! LET SQL_BUFF1$=TRIM$(SQL_FIELD$) !:
        let sql_buff1=len(sql_buff1$) !:
        let sql_buff1$=sql_buff1$(2:sql_buff1-1)
21800   let sql_type$=fn_sql_type$(sql_buff1$,mat sql_fieldsc$,mat sql_fieldsn$,filename$,sql_loc)
21810   if trim$(sql_type$)="" then goto END_OF_SQL_PRINT !:
          ! if not a Valid Type, then Continue & Do not Modify Value
21820   if trim$(sql_type$(1:1))="C" then gosub SQL_REPORT_C else !:
          if trim$(sql_type$)="N" then gosub SQL_REPORT_N else !:
            if trim$(sql_type$)="ND" then gosub SQL_REPORT_ND else !:
              if trim$(sql_type$)="D" then gosub SQL_REPORT_D else !:
                gosub SQL_REPORT_UNKNOWN
21830   goto END_OF_SQL_PRINT !:
        ! ** After Performing SQL Format, Proceed
21840 SQL_REPORT_UNKNOWN: let fnmessagebox_("Unknown information for:"&sql_buff1$&chr$(10)&" Sql Type:"&sql_type$,16,"Unknown Information") !:
        return 
21850 SQL_REPORT_C: ! Format Character Type Data
21860   let char_len=val(sql_fc$(sql_loc,3)) ! let char_len=      max(len(sql_data$(sql_loc)),       val(sql_fc$(sql_loc,3))      )
21870   let sql_field$=fnchar$(trim$(sql_data$(sql_loc)),char_len,uform$)
21880   let sql_flip$=rtrm$(sql_fieldsc$(sql_loc)) !:
        if pos(sql_field$,"/")>0 and (sql_flip$="NAME" or sql_flip$="ALIAS" or pos(sql_flip$,"_NAME")>0) then goto L21890 else !:
          goto L21900
21890 L21890: let sql_field$=fndebt_flip_$(sql_field$)
21900 L21900: return 
21910 SQL_REPORT_N: ! Format Numeric Type Data
21920   let num_len=-2020202 !:
        let num_len=val(sql_fn$(sql_loc,3)) conv L21930
21921   if sql_fn$(sql_loc,2)="L" then !:
          let num_len=16.6
21930 L21930: let num_ip=ip(num_len) !:
        let num_dec=num_len-num_ip
21940   let num_type$=sql_fn$(sql_loc,2)
21950   if num_type$="PD" then let num_ip=num_ip*2-1 else !:
          if num_type$(1:1)="B" then let num_ip= 3+(num_ip-1)*2
21960   let num_len=num_ip+num_dec
21970   let sql_field$=fnnum$("N "&str$(num_len),sql_data(sql_loc),uform$) !:
        return 
21980 SQL_REPORT_D: ! Format Date Type
21990   let inp_date$=trim$(sql_data$(sql_loc)) !:
        if trim$(inp_date$)="" or trim$(inp_date$)="0" then !:
          let sql_field$=rpt$(" ",10) !:
          goto L22030
22000   let inp_date=fndate10_(sql_data$(sql_loc))
22010 L22010: if trim$(uform$)<>"" then !:
          let sql_field$=date$(days(inp_date,"CYMD"),uform$) !:
          goto L22030
22020   if days(inp_date,"CYMD") then !:
          let sql_field$=date$(days(inp_date,"CYMD"),date_10$(3)) else !:
          let sql_field$="**/**/****"
22030 L22030: return 
22040 SQL_REPORT_ND: ! FORMAT NUMBERIC DATE TYPE
22050   let inp_date=date(days(sql_data(sql_loc)),'CYMD') !:
        let nuform=val(uform$) conv L22060 !:
        let uform$=date_10$(3) !:
        if nuform=8 then let uform$=date_8$(3) !:
          ! ** Note: UFORM must be Dates not Length!
22060 L22060: if inp_date=0 then let sql_field$=rpt$(" ",10) !:
          goto L22030
22070   goto L22010
22080 END_OF_SQL_PRINT: ! 
22090 !   todo:  enable this section, perhaps via fn call flag to enable masking of fields.  (table name (filename$) is also required)
22100   if sql_print_zone_filter_enable and filename$<>'' then 
22110     dim sql_print_field$*20
22120     let sql_print_field$=filename$&'.'&sql_buff1$(1:20) ! pause
22130     let fn_zone_mask$(sql_field$,sql_print_field$)
22140   end if  ! filename$<>''
22150 ! 
22160   let fn_sql_print$=trim$(sql_type$)
22170   if sql_print_method$<>'' then gosub SQL_PRINT_METHOD
22180 fnend  ! fnsql_print$
22190 def library fnsql_type$(&rep_var$,mat _fc$,mat _fn$; filename$,&loc)
22200   let fnsql_type$=fn_sql_type$(rep_var$,mat _fc$,mat _fn$, filename$,loc)
22210 fnend  ! FNSQL_TYPE$
22220 def fn_sql_type$(&rep_var$,mat _fc$,mat _fn$;filename$,&loc)
22230 ! Returns Variable Type & Location of Variable !:
        ! Variable is not actually changed
22240   let rep_var$=srep$(srep$(uprc$(rep_var$),filename$&".",""),"\","")
22250   if (lib_search:=srch(mat _fc$,rep_var$))>0 then !:
          let fn_sql_type$="C" !:
          goto L22260 else !:
          goto L22280
22260 L22260: if pos(trim$(_fc$(lib_search)),"DATE")>0 then !:
          let fn_sql_type$="D"
22270   goto L22320
22280 L22280: if (lib_search:=srch(mat _fn$,rep_var$))>0 then !:
          let fn_sql_type$="N" else !:
          goto L22310
22290   if pos(trim$(_fn$(lib_search)),"DATE")>0 then !:
          let fn_sql_type$="ND"
22300   goto L22320
22310 L22310: let fn_sql_type$=""
22320 L22320: let loc=lib_search
22330 fnend 
22335 def fnopen_closed$(oc_handle)
22336   if uprc$(file$(oc_handle))(1:2)="H:" then !:
          let fnopen_closed$="CLOSED" else !:
          let fnopen_closed$="OPEN"
22337 fnend 
22340 def library fnfind_court_des$*60(tvenue)
22342   if ~first_venue then gosub FIRST_VENUE
22344   let tvenue=srch(mat venue_county,tvenue) !:
        if tvenue>=1 then let fnfind_court_des$=venue_designation$(tvenue)
22346 fnend 
22350 def library fnassign_venue(&venue,mat block2$)
22352   gosub FIND_VENUE
22354 fnend 
22360 FIND_VENUE: ! r: Find Venue Matches
22362 dim _menu$(1)*80
22364 if first_venue=0 then gosub FIRST_VENUE
22366 let vzip$=vcs$="" !:
      mat _menu$(4)=("") !:
      let _menu$(1)="1. Select Venue by Debtor Zip Code   -"&block2$(4)(1:5)&" - "&fncounty$(block2$(4)) !:
      let _menu$(2)="2. Select Venue by Creditor Zip Code -"&block2$(9)(1:5)&" - "&fncounty$(block2$(9)) !:
      let _menu$(3)="3. Enter City,State Zip Code To Select" !:
      let _menu$(4)="0. Do not Select Venue"
22368 let vchoice=fnmenu_("How would you like to select Venue?",mat _menu$,tpk$="","","",nnp=1) !:
      if vchoice=udim(_menu$) or (cmdkey=99 or cmdkey=93) then let vchoice=0
22370 on vchoice goto L22372,L22374,L22376 none FIND_VENUE_XIT
22372 L22372: let vzip$=block2$(4) !:
      goto L22382 !:
      ! Select Venue by Debtor Zip
22374 L22374: let vzip$=block2$(9) !:
      goto L22382 !:
      ! Select Venue by Creditor Zip
22376 L22376: open #103: "SCol=12,SRow=9,ECol=68,ERow=14,BORDER=SN,CAPTION=Enter Zip Code",display,outin  !:
      print #103: newpage !:
      print #103,fields "2,2,c ;4,2,cr 15;5,2,cr 15" : "Please Enter City/St or Zip Code","City, State:","Zip Code:" !:
      let curfld(2) !:
      rinput #103, fields "4,18,C 40,[D]STA;5,18,C 10,[D]STA",attr '[A]': vcs$,vzip$ !:
      close #103: !:
      if (cmdkey=99 or cmdkey=93) or trim$(vcs$&vzip$)="" then goto L22426
22378 if trim$(vzip$)<>"" then let vzip$=trim$(srep$(vzip$,"*","")) !:
        goto L22382
22380 let vzip$=fnzipcity$(vcs$,58,mat zip_results$) !:
      goto L22376 ! 
22382 L22382: dim venue_results$(1)*76,vcs$*40,vzip$*10
22384 let venue_results=0 !:
      mat venue_results$(1)=("")
22386 print fields "24,1,C 80,[w]": ""
22388 let fnzip_$(vzip$,57,mat zip_results$) !:
      let vcounty$=rpad$(zip_results$(5),3)(1:3)&uprc$(trim$(zip_results$(6)))
22390 let _vcounty=pos(vcounty$,"/") !:
      if _vcounty then !:
        let fnmessagebox_(vzip$&" is in more than 1 county.\nPossible Matches:"&zip_results$(6)&"\nThe most likely county for this zip code is "&vcounty$(1:_vcounty-1),64,"Multiple Counties Encountered") !:
        let vcounty$(_vcounty:999)="" !:
        ! ** if multi county found, use the first
22392 if trim$(vcounty$)="" or last_venue<1 then !:
        let fnmessagebox_("Sorry, could not find a County for:"&vzip$&"\nPlease Try Again",16,"Could Not Find County") !:
        goto L22426
22394 ! Scan Through list of Venues looking for matches !:
      ! Check with & Without spaces for matches
22396 for xfind=1 to last_venue
22398 ! VCOUNTY$ - State & County selected !:
        ! mat VENUE_COUNTY$ Counties from Venue File !:
        ! SREP$(XLATE$(VCOUNTY$,SYMBOLS_XLATE$)," ","")= Remove all Symbols and spaces when comparing !:
        ! For Example St. John will match STJOHN
22400   if srep$(xlate$(vcounty$,symbols_xlate$)," ","")=srep$(xlate$(venue_county$(xfind),symbols_xlate$)," ","") then !:
          let venue_results+=1 !:
          mat venue_results$(venue_results) !:
          let venue_results$(venue_results)=cnvrt$('PIC(----)',venue_county(xfind))&""&fnis_amt$(filerec(5),venue_low(xfind),venue_high(xfind))&""&cnvrt$('PIC(---#)',fndistance_(vzip$,venue_zip$(xfind)(1:5),57))&""&rpad$(venue_city$(xfind),10)(1:18)&""&venue_name$(xfind)(1:28)&""&venue_designation$(xfind)(1:12)&""&venue_type$(xfind)(1:12)
22402 next xfind
22404 let new_venue=1
22406 L22406: if venue_results>1 then !:
        let new_venue=fnwinscroll_(mat venue_results$,new_venue,"TITLE=Select Desired Venue for:"&vcounty$&" County "&vzip$&" HEADING=No.;*;Distance;City;Name;Designation;Type")
22408 let rn=fnval_(venue_results$(new_venue)(1:4)) !:
      if cmdkey=5 and rn>0 then !:
        let mchoice=2: open #123: "SCol=1,SRow=1,ECol=80,ERow=24",display,outin  !:
        let nnp=1: let tmchoice=mchoice !:
        let mchoice=tmchoice: close #123: : goto L22406
22410 if venue_results<=0 then !:
        let fnmessagebox_("Sorry, could not find a Venue for:"&vzip$&"-"&vcounty$&"\nPlease Try Again",16,"Could Not Find Venue") !:
        goto L22426
22412 if (cmdkey=99 or cmdkey=93) then goto L22426 ! Escape should quit
22414 let new_venue=fnval_(venue_results$(new_venue)(1:4))
22416 if venue=0 or new_venue=venue then goto L22422
22418 let keep=fnmessagebox_("Are you Sure you want to change the Venue From:"&str$(venue)&" To:"&str$(new_venue),292,"Venue Changed")
22420 if keep=7 or keep=2 then goto L22426 !:
        ! !Cancel
22422 L22422: let venue=new_venue
22424 FIND_VENUE_XIT: ! 
22426 L22426: return ! /r
22430 def library fnfind_court_type$*20(tvenue)
22432   if ~first_venue then gosub FIRST_VENUE
22434   let tvenue=srch(mat venue_county,tvenue) !:
        if tvenue>=1 then let fnfind_court_type$=venue_type$(tvenue)
22436 fnend 
22438 def library fnfind_venue$*60(tvenue)
22440   if ~first_venue then gosub FIRST_VENUE
22442   let tvenue=srch(mat venue_county,tvenue)
22444   if tvenue>=1 then let fnfind_venue$=venue_county$(tvenue)
22446 fnend 
22448 def library fnfind_sher$*60(tsher)
22450   if ~first_sher then gosub FIRST_SHER
22452   let tsher=srch(mat sher_county,tsher)
22454   if tsher>=1 then let fnfind_sher$=trim$(sher_county$(tsher))&" "&sher_name$(tsher)
22456 fnend 
22460 FIRST_VENUE: ! r:
22461 let first_venue=1 ! Import Court File into Array
22465 dim venue_county(1),venue_name$(1)*40,venue_county$(1)*23,vname$*40,vcounty$*20,csz_results$(3)*40,venue_designation$(1)*30,venue_type$(1)*15,venue_low(1),venue_high(1),venue_rates(10),vdesignation$*30,vtype$*15,venue_city$(1)*30,venue_zip$(1)*10,fees$(1)*60,zip_result$(1)*60
22470 print fields "24,1,CC 80,[S]": "Please Wait, Creating Court County List"
22475 let fnsetup_fee_(mat low,mat high,mat fees$,mat rates$,mat sher_rates$)
22480 if ~xlate_setup then let fnxlate_setup
22485 open #54: "NAME=CLERKF//9,SHR",internal,input,relative 
22490 let max_venue=lrec(54)
22495 let last_venue=0 !:
      mat venue_county(max_venue)=(0) !:
      mat venue_county$(max_venue)=("") !:
      mat venue_city$(max_venue)=("") : mat venue_zip$(max_venue)=("") !:
      mat venue_name$(max_venue)=("") !:
      mat venue_designation$(max_venue)=("") !:
      mat venue_type$(max_venue)=("") !:
      mat venue_low(max_venue)=(inf) !:
      mat venue_high(max_venue)=(0) !:
      mat venue_rates=(0)
22500 L22500: mat venue_rates=(0) !:
      read #54,using L22505: vnum,vname$,vcounty$,vcs$,vdesignation$,vtype$,mat venue_rates conv L22505 eof L22550
22505 L22505: form pos 1,bh 2,c 40,c 20,pos 93,c 30,pos 412,c 30,pos 442,c 15,pos 123,7*pd 6.2,pos 827,3*pd 6.2
22510 if trim$(vcounty$)="" then goto L22500
22515 let fnparse_csz_$(vcs$,mat csz_results$) !:
      if trim$(csz_results$(2))="" then goto L22500 !:
        ! csz_results contains !:
        ! 1 = City !:
        ! 2 = State!:
        ! 3 = ZIP
22520 let last_venue+=1
22525 let venue_county(last_venue)=rec(54) !:
      let venue_county$(last_venue)=rpad$(csz_results$(2),3)(1:3)&trim$(uprc$(vcounty$)) !:
      let venue_city$(last_venue)=csz_results$(1) !:
      let venue_zip$(last_venue)=csz_results$(3) !:
      let venue_name$(last_venue)=vname$ !:
      let venue_designation$(last_venue)=vdesignation$ !:
      let venue_type$(last_venue)=vtype$ !:
      let venue_low(last_venue)=inf !:
      let venue_high=0
22530 for zf=1 to 10
22535   if venue_rates(zf)>0 then !:
          let venue_low(last_venue)=min(venue_low(last_venue),low(zf)) !:
          let venue_high(last_venue)=max(venue_low(last_venue),high(zf))
22540 next zf
22545 goto L22500
22550 L22550: close #54: !:
      print fields "24,1,CC 80,[W]": ""
22555 mat venue_county(last_venue) !:
      mat venue_county$(last_venue) !:
      mat venue_city$(last_venue): mat venue_zip$(last_venue) !:
      mat venue_name$(last_venue) !:
      mat venue_designation$(last_venue) !:
      mat venue_type$(last_venue) !:
      mat venue_low(last_venue) !:
      mat venue_high(last_venue) !:
      ! Re-Dim Arrays to Match the actual # of matches.
22560 return ! /r
22565 FIRST_SHER: ! r:
22566 let first_sher=1 ! Import Court File into Array
22570 dim sher_county(1),sher_name$(1)*40,sher_county$(1)*23,sher_city$(1)*30,sher_zip$(1)*10
22575 let last_sher=0 !:
      mat sher_county(1)=(0) !:
      mat sher_county$(1)=("") !:
      mat sher_city$(1)=("") : mat sher_zip$(1)=("") !:
      mat sher_name$(1)=("") !:
      mat sher_designation$(1)=("") !:
      mat sher_type$(1)=("") !:
      mat sher_low(1)=(inf) !:
      mat sher_high(1)=(0) !:
      mat sher_rates=(0)
22580 print fields "24,1,CC 80,[S]": "Please Wait, Creating Sheriff County List"
22585 open #54: "NAME=COPF//9,SHR",internal,input,relative 
22590 L22590: mat sher_rates=(0) !:
      read #54,using L22595: vnum,vname$,vcounty$,vcs$ eof L22625
22595 L22595: form pos 1,bh 2,pos 3,c 30,pos 333,c 15,pos 93,c 30
22600 if trim$(vcounty$)="" then goto L22590
22605 let fnparse_csz_$(vcs$,mat csz_results$) !:
      if trim$(csz_results$(2))="" then goto L22590 !:
        ! csz_results contains !:
        ! 1 = City !:
        ! 2 = State!:
        ! 3 = ZIP
22610 let last_sher+=1 !:
      mat sher_county(last_sher) !:
      mat sher_county$(last_sher) !:
      mat sher_city$(last_sher): mat sher_zip$(last_sher) !:
      mat sher_name$(last_sher)
22615 let sher_county(last_sher)=rec(54) !:
      let sher_county$(last_sher)=rpad$(csz_results$(2),3)(1:3)&trim$(uprc$(vcounty$)) !:
      let sher_city$(last_sher)=csz_results$(1) !:
      let sher_zip$(last_sher)=csz_results$(3) !:
      let sher_name$(last_sher)=vname$ !:
      let sher_high=0
22620 goto L22590
22625 L22625: close #54: !:
      print fields "24,1,CC 80,[W]": ""
22630 return ! /r
22640 def fncounty$*40(zipcode$;autozip_handle)
22642   dim county_results$(1)*80
22644   if autozip_handle=0 then let autozip_handle=57
22646   let fnzip_$(zipcode$,autozip_handle,mat county_results$) !:
        let fncounty$=rpad$(county_results$(5),3)(1:3)&uprc$(trim$(county_results$(6)))
22648 fnend 
22650 def library fnget_county$(csz$*80;autozip_handle)
22652   if autozip_handle=0 then let autozip_handle=57
22654   let fnparse_csz_$(csz$,mat csz_results$)
22656   let fnzip_$(csz_results$(3)(1:5),autozip_handle,mat county_results$) !:
        let fnget_county$=trim$(county_results$(6))
22658 fnend 
22660 def library fnfind_court$*40(tvenue)
22662   if ~first_venue then gosub FIRST_VENUE
22664   let tvenue=srch(mat venue_county,tvenue)
22666   if tvenue>=1 then !:
          let fnfind_court$=trim$(trim$(venue_county$(tvenue))&" "&venue_name$(tvenue))(1:40)
22668 fnend 
22670 def fnarray_to_list$*1024(mat att_array$; atl_rtrm,atl_delimiter$)
22672   gosub SETUP_LIBRARY
22674   gosub SETUP_CONSTANTS
22676   let fnarray_to_list$=fn_array_to_list$(mat att_array$, atl_rtrm,atl_delimiter$)
22678 fnend  ! fnarray_to_list$
22680 def fn_array_to_list$*1024(mat atl_array$; atl_rtrm,atl_delimiter$) ! atl_
22682 ! atl_rtrm = if 1 than rtrm each item when adding it to the list
22684 ! atl_delimiter$ = delimiter to use for the list.  if omitted than tab is used.
22686   dim atl_return$*1024
22688   if atl_delimiter$='' then let atl_delimiter$=tab$
22690   let atl_return$=''
22692   for atl_array_item=1 to udim(mat atl_array$)
22694     if atl_rtrm=1 then let atl_array$(atl_array_item)=rtrm$(atl_array$(atl_array_item))
22696     let atl_return$=atl_return$&atl_array$(atl_array_item)&tab$
22698   next atl_array_item
22700   let atl_return$=trim$(atl_return$,tab$)
22702   let fn_array_to_list$=atl_return$
22704 fnend  ! fn_array_to_list$
22710 ! ---------LIBRARY----------FNERASE_BUTTONS()---------------------------
22712 def library fnerase_buttons
22714   gosub ERASE_BUTTONS
22716 fnend 
22718 ERASE_BUTTONS: ! r: ERASE BUTTON BAR
22720 display buttons "1,1,C 80": "" ! Delete button row
22722 display buttons "2,1,C 80": "" ! Delete button row
22724 return ! /r
22730 def library fntrack(value,&track)
22732   let setenv("TRACK_STAMP",date$("MM/DD/CCYY")&" "&time$)
22734   if value>track then goto L22752 else if value=track then let value=0 : goto L22752
22736 if rem(track,2)<>0 then let one=1 else let one=0
22738 if value=1 and one=1 then let value=0: goto L22754
22740 let svalue=2048 : let strack=track-one
22742 L22742: if svalue<1 then goto L22752
22744 if svalue>strack then goto L22750
22746 if value=strack or value=svalue then let value=0 : goto L22752
22748 let strack-=svalue
22750 L22750: let svalue/=2 : goto L22742
22752 L22752: if value>=32768 then !:
        let value-=32768 !:
        execute "Status Stacks" !:
        print "Warning - Value Exceeds 32768, please contact support" !:
        pause 
22753 let fntrack=value
22754 L22754: fnend 
22760 def fn_lg_setup
22762   if ~lg_setup then 
22764     let lga_setup=1
22766     let lg_security_mastdiarylog_note=max(0,fnsecurity_("MAST:DIARYLOG NOTES",'',0,fnuserinit$,1))
22768     if ~setup_constants then gosub SETUP_CONSTANTS
22770   end if  ! ~log_add_setup
22772   goto LG_XIT
22774 LG_OPEN_ACTIVE: ! open Activ if necessary
22776   open #31: "NAME=ACTIVE.INT//6,KFNAME=ACTIVE.IDX//6,SHR",internal,outin,keyed ioerr ignore
22778   open #32: "NAME=ACTIVE.INT//6,KFNAME=ACTIVE.DTE//6,shr",internal,outin,keyed ioerr ignore
22780   return  ! LG_OPEN_ACTIVE
22782 LG_XIT: ! 
22784   let fn_lg_setup=lg_setup
22786 fnend  ! fn_lg_setup
22790 def library fnlog_add(fileno$,logadd$,can_dcode,logcanned$,dcode,dia_cmt$*20,&dia$,user; lga_diary_date$*10) ! lga_
22792   if ~lg_setup then let lg_setup=fn_lg_setup
22794 ! if jbowman and trim$(lga_diary_date$)='' then print ' blank date passed ' : pause
22796   if can_dcode and logcanned$<>"Y" then goto LGA_XIT ! canned code /w canned log set to 'N'
22798   if logadd$="Y" then 
22800     gosub LG_OPEN_ACTIVE
22802     let c0de$="*ADD-"&str$(dcode)
22804     let extra$=dia$
22806     let cmt$=""
22808     if ~lg_security_mastdiarylog_note and lga_diary_date$<>'' then 
22810       let cmt$=lpad$(fndate_dis10_$(lga_diary_date$),10)&':'&dia_cmt$
22812     else 
22814       if trim$(dia_cmt$)<>"" then let cmt$=':'&dia_cmt$
22816     end if  ! ~lg_security_mastdiarylog_note and lga_diary_date$<>''
22818     write #31,using L24250,release: fileno$,date("CYMD"),fnstime_(time$),cmt$,extra$,c0de$,user
22820     let fnlog_add=1
22822   end if  ! logadd$="Y"
22824 LGA_XIT: ! 
22826 fnend  ! fnlog_add
22830 def library fnlog_del(fileno$,logdel$,lgd_buff$*132,user) ! lgd_
22832   if ~lg_setup then let lg_setup=fn_lg_setup
22834   dim lgd_dia_cmt$*132,lgd_diary_date$*10
22836   if logdel$="Y" then 
22838     gosub LG_OPEN_ACTIVE
22840 !   NPOS0 (1) to NPOS9 (10) Fields Are as follows
22842 !   Code (1) Date (2) Time (3)  Pri (4)   Description (5)  Comment (6)   Queue (7)
22844     let npos1=pos(lgd_buff$,"")
22846     let npos2=pos(lgd_buff$,"",npos1+1)
22848     let npos3=pos(lgd_buff$,"",npos2+1)
22850     let npos4=pos(lgd_buff$,"",npos3+1)
22852     let npos5=pos(lgd_buff$,"",npos4+1)
22854     let npos6=pos(lgd_buff$,"",npos5+1)
22856     let c0de$="*DEL-"&lgd_buff$(1:npos1-1)
22858     let extra$=lgd_buff$(npos4+1:npos5-1)
22860     let cmt$=""
22862     let lgd_dia_cmt$=lgd_buff$(npos5+1:npos6-1)
22864     let lgd_diary_date$=trim$(lgd_buff$(npos1+1:npos2-1))
22866     if trim$(lgd_dia_cmt$)="" then 
22868       let cmt$=lpad$(lgd_diary_date$,10)&':'
22870     else 
22872       if ~lg_security_mastdiarylog_note and lgd_diary_date$<>'' then 
22874         let cmt$=lpad$(lgd_diary_date$,10)&':'&lgd_dia_cmt$
22876       else 
22878         let cmt$=':'&lgd_dia_cmt$
22880       end if  ! ~lg_security_mastdiarylog_note
22882     end if  ! trim$(lgd_dia_cmt$)=""   /   else 
22884     write #31,using L24250,release: fileno$,date("CYMD"),fnstime_(time$),cmt$,extra$,c0de$,user
22886   end if  ! logdel$="Y"
22888 fnend  ! fnlog_del
22890 def fnxlate_setup
22892   dim html_xlate$*257,numbers_xlate$*257,blank_xlate$*257,symbols_xlate$*257,edi_xlate$*257,edi_xlate$*257,spec_char_xlate$*257,csv_whole_number_xlate$*257,nj_xlate$*257,data_xlate$*257
22894 ! These XLATE tables will turn various types of strings into the desired translations !:
        ! HTML_XLATE$ = This will return either "*" or the desired HTML compatible characters !:
        ! NUMBERS_XLATE$ This will return either digits or a "." !:
        ! BLANK_XLATE$ This is used by FNNOPAPER to strip nonsense out, of paperless files notes - if there is no content in the message, simply strip it out, for example $0.00 or 00/00/00
22896   let html_xlate$ = rpt$("*", 32)&" !"&chr$(34)&"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~*"&rpt$("*", 128)
22898   let numbers_xlate$ = rpt$(" ", 46)&". 0123456789"&rpt$(" ", 195)
22900   let symbols_xlate$ = rpt$(" ", 48)&"0123456789       ABCDEFGHIJKLMNOPQRSTUVWXYZ      abcdefghijklmnopqrstuvwxyz"&rpt$(" ", 133)
22902   let edi_xlate$ = rpt$(" ", 32)&" !"&chr$(34)&"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~*"&rpt$(" ", 128)
22904   let nj_xlate$= rpt$(" ", 32)&"  "&chr$(34)&"#$           0123456789       ABCDEFGHIJKLMNOPQRSTUVWXYZ      abcdefghijklmnopqrstuvwxyz     "&rpt$(" ", 128)
22906   let data_xlate$ = rpt$("^", 32)&" !"&chr$(34)&"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~*"&rpt$("^", 128)
22908   for _ok=2 to 7 : let data_xlate$(_ok:_ok)=chr$(_ok-1) : next _ok !:
        for _ok=15 to 27 : let data_xlate$(_ok:_ok)=chr$(_ok-1) : next _ok !:
        for _ok=29 to 32 : let data_xlate$(_ok:_ok)=chr$(_ok-1) : next _ok
22910   for _ok=127 to 176 : let data_xlate$(_ok:_ok)=chr$(_ok-1) : next _ok !:
        for _ok=241 to 253 : let data_xlate$(_ok:_ok)=chr$(_ok-1) : next _ok
22912   let blank_xlate$ = rpt$(" ", 32)&"                 123456789       ABCDEFGHIJKLMNOPQRSTUVWXYZ      abcdefghijklmnopqrstuvwxyz     "&rpt$(" ", 128)
22914   let spec_char_xlate$=rpt$(" ",175)&rpt$("*",50)&rpt$(" ",32) !:
        ! Special Line Draw Characters are from 176 TO 225 !:
        ! An "*" will indicate a line draw character!
22916   let csv_whole_number_xlate$ = rpt$(",", 43)&",,-,,0123456789"&rpt$(",", 195)
22920   let xlate_setup=1
22930 fnend 
22940 def library fnopen_sql(sql_handle,sql$*4096,dsn$*256,&sql_formc$,&sql_formn$,&sql_formall$,mat sql_fieldsc$,mat sql_fieldsn$,mat sql_data$,mat sql_data;prompt_user,user_name$*256,password$*256)
22942 ! if there is an error opening this file the function will return -4205 (We can refine the errors later)!:
        ! if SQL$ or DSN$ are "Missing" then return error -1000
22944   let sql_formc$=sql_formn$=sql_formall$="FORM POS 1" !:
        mat sql_fieldsc$(0)=("") !:
        mat sql_fieldsn$(0)=("") !:
        mat sql_data$(0)=("") !:
        mat sql_data(0)=(0)
22946   dim sqlisam_dta$*256,sqlisam_int$*256,sqlisam_user$*256,sql_buff$*999
22948   if trim$(sql$)="" or trim$(dsn$)="" then !:
          let fnopen_sql=-1000 !:
          goto OPEN_SQL_XIT
22950   let msg$("Connecting to "&dsn$) !:
        if file(sql_handle)>0 then close #sql_handle: 
22952   let sqlisam_dta$=env$("TEMP")&"\SQLI"&session$&".DTA" !:
        let sqlisam_int$=env$("TEMP")&"\SQLI"&session$&".INT" !:
        open #(sqlisam_dta_handle:=fngethandle_): "NAME="&sqlisam_dta$&",Replace,Recl=32000,NoSHR",display,output ioerr OPEN_SQL_OPEN_ERR
22954   if exists(sqlisam_int$) then !:
          execute "*FREE "&sqlisam_int$
22956   print #sqlisam_dta_handle: "[setup]"
22958   print #sqlisam_dta_handle: "SQL=";sql$
22960   if uprc$(dsn$(1:5))="FILE=" then !:
          print #sqlisam_dta_handle: "DSNDatafile=";dsn$(6:999) !:
        else print #sqlisam_dta_handle: "DSN=";dsn$
22962   print #sqlisam_dta_handle: "Prompt=";prompt_user !:
        print #sqlisam_dta_handle: "BRFile=";sqlisam_int$
22964   print #sqlisam_dta_handle: "[data]"
22966   close #sqlisam_dta_handle: 
22968   let sqlisam_user$="" !:
        if trim$(user_name$)<>"" then let sqlisam_user$=" /user:"&user_name$
22970   if trim$(password$)<>"" then let sqlisam_user$(999:0)=" /pass:"&password$
22972   let msg$("Sending SQL to "&dsn$) !:
        let fn_exe('-w','VB32\SQLIsam.exe',sqlisam_dta$,sqlisam_user$) !:
        let msg$("SQL Proceesed by"&dsn$)
22974   open #sql_handle: "NAME="&trim$(sqlisam_int$)&",noshr",internal,input,relative ioerr OPEN_SQL_OPEN_ERR
22976   open #(sqlisam_dta_handle:=fngethandle_): "NAME="&sqlisam_dta$&",NoSHR",display,input ioerr OPEN_SQL_OPEN_ERR
22978 READ_SQL_DTA: linput #sqlisam_dta_handle: sql_buff$ eof XIT_READ_SQL_DATA !:
        let sql_buff$=uprc$(sql_buff$)
22980   if sql_buff$(1:6)="CFORM=" then !:
          let sql_formc$=trim$(sql_buff$(7:999))
22982   if sql_buff$(1:6)="XFORM=" then !:
          let sql_formn$=trim$(sql_buff$(7:999))
22984   if sql_buff$(1:8)="CFIELDS=" then !:
          let fnparse_csv_(sql_buff$(9:9999),mat sql_fieldsc$)
22986   if sql_buff$(1:8)="XFIELDS=" then !:
          let fnparse_csv_(sql_buff$(9:9999),mat sql_fieldsn$)
22988   if sql_fieldsn$(1:8)<>"FORM POS" then !:
          let sql_fieldsn$(1:6)="FORM POS 1,"
22990   goto READ_SQL_DTA
22992 XIT_READ_SQL_DATA: ! Get the Fields, Forms & Other Cool stuff!
22994   close #sqlisam_dta_handle: 
22996 OPEN_SQL_FINIS: ! 
22998   let fnopen_sql=udim(sql_fieldsc$)+udim(sql_fieldsn$) !:
        mat sql_data$(udim(sql_fieldsc$))=("") !:
        mat sql_data(udim(sql_fieldscn))=(0) !:
        let sql_formall$=sql_formc$&","&sql_formn$(5:999)
23000   if trim$(sql_formc$)="FORM" then let sql_formc$="FORM POS 1,X"
23002   if trim$(sql_formn$)="FORM" then let sql_formn$="FORM POS 1,X"
23004   let sql_formc$=cform$(sql_formc$) !:
        let sql_formn$=cform$(sql_formn$)
23006   goto OPEN_SQL_XIT
23008 OPEN_SQL_OPEN_ERR: ! 
23010   let fnopen_sql=-err
23012 OPEN_SQL_XIT: ! 
23014 fnend 
23020 def library fnclient_env$*2048(envparam$*128)
23022   let fnclient_env$=fn_client_env$(envparam$)
23024 fnend 
23030 def fn_client_env$*2048(envparam$*128)
23032   if uprc$(env$("Client_Server"))="YES" then 
23034     let envparam$ = "CS_"&envparam$
23036     let fn_client_env$=env$(envparam$)
23038   else 
23040     let fn_client_env$=env$(envparam$)
23042   end if 
23044 fnend 
23050 def library fnclient_os_path$*256(cs_os_path$*256)
23052   let fnclient_os_path$=fn_client_os_path$(cs_os_path$)
23054 fnend 
23060 def fn_client_os_path$*265(cs_os_path$*256)
23065   if cs_os_path$(1:3)="@::" then 
23070     let fn_client_os_path$=cs_os_path$
23075   else if trim$(env$("CLIENT_OS_PATH")&env$("SERVER_OS_PATH")&env$("CLIENT_DRIVE_N_PATH")&env$("SERVER_DRIVE_N_PATH"))<>"" then 
23080     let cs_os_path$=uprc$(os_filename$(cs_os_path$)) error ignore
23085     if trim$(env$("CLIENT_DRIVE_N_PATH"))<>"" and trim$(env$("SERVER_DRIVE_N_PATH"))<>"" then !:
            let cs_os_path$=srep$(cs_os_path$,uprc$(env$("SERVER_DRIVE_N_PATH")),env$("CLIENT_DRIVE_N_PATH"))
23090     if trim$(env$("CLIENT_OS_PATH"))<>"" and trim$(env$("SERVER_OS_PATH"))<>"" then !:
            let cs_os_path$=srep$(cs_os_path$,uprc$(env$("SERVER_OS_PATH")),env$("CLIENT_OS_PATH"))
23095     let fn_client_os_path$=cs_os_path$
23100   else 
23105     let fn_client_os_path$=os_filename$(cs_os_path$)
23110   end if 
23115 fnend 
23120 def library fnexe(exe_parameters$*32,exe_name$*256;exe_filename$*256,exe_add_parameters$*2048)
23122   let fnexe=fn_exe(exe_parameters$,exe_name$,exe_filename$,exe_add_parameters$)
23124 fnend 
23130 def fn_exe(exe_parameters$*32,exe_name$*256;exe_filename$*256,exe_add_parameters$*2048)
23135   let exe_name$=srep$(exe_name$,"[PKZIP]",env$("Client_Zip_Program")) !:
        let exe_name$=srep$(exe_name$,"[PKUNZIP]",env$("Client_UnZip_Program"))
23140   let exe_quote$='"' !:
        if pos(exe_parameters$,"QUOTE=NONE")>0 or uprc$(trim$(exe_name$))(1:5)="START" then !:
          let exe_quote$='' !:
          let exe_parameters$=srep$(exe_parameters$,"QUOTE=NONE","") !:
          let exe_parameters$=trim$(exe_parameters$)
23145   if uprc$(trim$(exe_name$))(1:5)<>"START" then !:
          let exe_name$=fn_client_os_path$(exe_name$)
23150   if trim$(exe_filename$)<>"" then !:
          let exe_filename$=fn_client_os_path$(exe_filename$)
23155   let exe_filename$=srep$(exe_filename$,"@::","") !:
        let exe_name$=srep$(exe_name$,"@::","")
23160   if trim$(exe_filename$)<>"" and exe_filename$(1:1)<>exe_quote$ and exe_quote$<>"" then !:
          let exe_filename$=exe_quote$&trim$(exe_filename$)&exe_quote$
23165   if pos(exe_name$," ")>0 then !:
          execute "SYS "&exe_parameters$&' "'&trim$(trim$(exe_name$)&'" '&trim$(exe_filename$))&" "&trim$(exe_add_parameters$) !:
        else !:
          execute "SYS "&exe_parameters$&' '&trim$(trim$(exe_name$)&' '&trim$(exe_filename$))&" "&trim$(exe_add_parameters$)
23170 fnend 
23180 def library fnpkzip(zip_parameters$*80,zip_name$*256,zip_files$*256)
23182   let fnpkzip=fn_pkzip(zip_parameters$,zip_name$,zip_files$)
23184 fnend 
23190 def fn_pkzip(zip_parameters$*80,zip_name$*256,zip_files$*256)
23192   dim pkzip_exe$*256
23194   let pkzip_exe$=env$("Client_Zip_Program") !:
        let pkzip_exe$=fn_client_os_path$(pkzip_exe$)
23196   let zip_name$=fn_client_os_path$(br_filename$(os_filename$(zip_name$))) !:
        let zip_files$=fn_client_os_path$(br_filename$(os_filename$(zip_files$)))
23198   execute "SYS -M "&trim$(pkzip_exe$&' '&zip_parameters$)&' "'&zip_name$&'" "'&zip_files$&'"'
23199 fnend 
23200 def library fnopen_dbf(dbf_handle,dbf$*80,&rcln,&fform$,mat fields$,mat f_type$,mat f_size,mat data$)
23205 ! if DBF_HANDLE=0 THEN LET DBF_HANDLE=FNGETHANDLE_
23210   if lrec(dbf_handle)>=0 then close #dbf_handle: 
23215   dim header$*80,tform$*1024
23220   let start_2=0 !:
        let fform$=tform$=""
23225   open #dbf_handle: "NAME="&dbf$&",RECL=31,SHR",external,input,relative 
23230   read #dbf_handle,using L23235,pos=1: header$,type,ldait,numrecs,firstrec,rlen
23235 L23235: form pos 1,c 31,pos 1,bl 1,bl 3,bl 4,bl 2,bl 2
23240   for z=32 to firstrec-4 step 32
23245     read #dbf_handle,using L23255,pos=z: header$,name$,data_type$,disp,flen,fdec !:
          let first_space=pos(name$&chr$(0),chr$(0)) !:
          let name$=rpad$(trim$(name$(1:first_space)),10) !:
          if name$(1:1)=hex$("0D") then goto L23285 !:
            ! ** Only read to last actual field
23250     if flen<=0 then let flen=256+flen
23255 L23255: form pos 1,c 31,pos 2,c 11,c 1,bl 4,bl 1,bl 1
23260 ! PRINT #101: NAME$;"-";DATA_TYPE$;"-";FLEN;" ";FDEC
23265     let field+=1 !:
          let tform$=fform$
23270     mat fields$(field) !:
          mat f_type$(field) !:
          mat f_size(field) !:
          let fields$(field)=trim$(trim$(name$),chr$(0)) !:
          let f_type$(field)=data_type$ !:
          let f_size(field)=val(str$(flen)&"."&str$(fdec)) !:
          mat data$(field)
23275     let fform$=tform$&",C "&str$(flen) !:
          let start_2+=flen
23280   next z
23285 L23285: let fform$=fnpackform$("FORM POS 1,C 1"&fform$,0)
23290   close #dbf_handle: 
23295   let rcln=rlen !:
        let fnopen_dbf=field !:
        mat data$(field)
23300   open #dbf_handle: "name="&rtrm$(dbf$)&",recL="&str$(rcln),external,outin,relative 
23305   restore #dbf_handle,pos=firstrec+1: !:
        ! ** Position DBF File for Next READ
23310 fnend 
23320 def fncheckcsv(&cfile$)
23322   dim temp_cfile$*256
23324   let cfile$=trim$(cfile$) !:
        let cfile$=rtrm$(cfile$,"\") !:
        if pos(lwrc$(cfile$),".xlsx")>0 then !:
          let temp_cfile$=env$("CLIENT_TEMP")&"\XLSX-"&session$&".xlsx" !:
        else !:
          let temp_cfile$=env$("CLIENT_TEMP")&"\XLS-"&session$&".xls"
23325   execute '*COPY "'&cfile$&'" '&temp_cfile$ error L23334 !:
        let cfile$=temp_cfile$ !:
        let msg$("Processing XLS-"&session$&".xls") !:
        let fn_exe('-M QUOTE=NONE','vb.NET\XLS2CSV.exe',cfile$) error L23334
23326   if exists(cfile$&"\xls2csv.csv") then !:
          let cfile$=cfile$&"\xls2csv.csv" !:
        else !:
          let npos=pos(cfile$, ".", -1) !:
          if exists(cfile$(1:npos)&"csv") then !:
            let cfile$=cfile$(1:npos)&"csv" !:
          else let cfile$=""
23328   let type$="T" !:
        let separator$=tab$ !:
        ! LET RETRIEVE_CSV_FIELDS=1
23330 L23330: if trim$(cfile$)="" then !:
          let fnmessagebox_("There was a problem processing the data files, you may neet to contact support!",64,"XLS IMPORT FAILED!")
23332   goto L23336
23334 L23334: let cfile$="" !:
        goto L23330
23336 L23336: fnend 
23340 def library fnopen_csv(csv_handle,csv$*132,&csv_delimiter$,mat csv_fields$,mat csv_data$)
23342   if ~setup_constants then gosub SETUP_CONSTANTS
23344   let fnopen_csv=fnopen_csv_(csv_handle,csv$,csv_delimiter$,mat csv_fields$,mat csv_data$)
23346 fnend 
23350 def fnopen_csv_(csv_handle,csv$*132,&csv_delimiter$,mat csv_fields$,mat csv_data$)
23355 ! if there is an error opening this file the function will return the error number as a negative (and also 0 fields)
23360   let open_csv_return=0
23365   let open_csv_unicode_did_ignore=0
23370   if file(csv_handle)>0 then !:
          close #csv_handle: !:
        else if csv_handle=0 then !:
          let csv_handle=open_csv_return=-706 : goto OPEN_CSV_XIT
23375 if pos(uprc$(csv$), ".XLS")>0 or pos(uprc$(csv$),".HTM")>0 or pos(uprc$(csv$),".XML")>0 then !:
        let msg$("Please Wait") !:
        let fncheckcsv(csv$) !:
        let msg$("")
23380 OPEN_CSV_OPEN: ! 
23385 open #csv_handle: "NAME="&trim$(csv$),display,input ioerr OPEN_CSV_OPEN_ERR
23390 let buff$=''
23395 do while trim$(buff$)="" !:
        linput #csv_handle: buff$ eof OPEN_CSV_OPEN_ERR !:
      loop 
23400 if ~open_csv_unicode_did_ignore and fn_is_unicode(buff$) then 
23405   close #csv_handle: 
23410   let csv_unicode_mb_response=fnmessagebox_('The file:\n'&csv$&'\nappears to be a unicode format.\nPlease open the file in notepad and save it changing the encoding setting to ANSI.',mb_abortretryignore,'Problem with '&file$(csv_handle))
23415   if csv_unicode_mb_response=mb_abort then 
23420     let fields=open_csv_return=-10001
23425     let field=0
23430     goto OPEN_CSV_XIT
23435   else if csv_unicode_mb_response=mb_retry then 
23440     goto OPEN_CSV_OPEN
23445   else if csv_unicode_mb_response=mb_ignore then 
23450     let open_csv_unicode_did_ignore=1
23455     goto OPEN_CSV_OPEN
23460   end if 
23465 end if  ! ~open_csv_unicode_did_ignore and fn_is_unicode
23470 if pos(buff$,tab$)>0 then 
23475   let csv_delimiter$=tab$
23480 else 
23485   let csv_delimiter$=","
23490 end if 
23495 let fields=str2mat(buff$,mat csv_fields$,csv_delimiter$)
23500 for nfix=1 to udim(csv_fields$)
23505   let csv_fields$(nfix)=uprc$(srep$(csv_fields$(nfix),"'",""))
23510   let csv_fields$(nfix)=trim$(srep$(csv_fields$(nfix),'"',""))
23515 next nfix
23520 OPEN_CSV_FINIS: ! 
23525 let open_csv_return=fields
23530 mat csv_data$(0)=("") !:
      if fields>0 then !:
        mat csv_data$(fields)=("")
23535 goto OPEN_CSV_XIT
23540 OPEN_CSV_OPEN_ERR: ! 
23545 let fields=-err
23550 let field=0
23555 goto OPEN_CSV_FINIS
23560 OPEN_CSV_XIT: ! 
23565 let fnopen_csv_=open_csv_return
23570 fnend 
23580 def fn_is_unicode(&isuni_first_line_of_file$) ! isuni_
23585   let isuni_return=0
23590   if unhex$(isuni_first_line_of_file$(1:2))='FEFF' then 
23595     let isuni_return=1
23600   else if unhex$(isuni_first_line_of_file$(1:2))='FFFE' then 
23605     let isuni_return=1
23610   else if unhex$(isuni_first_line_of_file$(1:4))='0000FEFF' then 
23615     let isuni_return=1
23620   else if unhex$(isuni_first_line_of_file$(1:3))='EFBBBF' then 
23625     let isuni_return=1
23630   end if 
23635   let fn_is_unicode=isuni_return
23640 fnend  ! fn_is_unicode
23650 def library fndel_rec(dr_file_handle,dr_record_number)
23652   let fndel_rec=fndelrec(dr_file_handle,dr_record_number)
23654 fnend 
23660 def fndelrec(dr_file_handle,dr_record_number)
23665 ! DR_File_Handle - file must be opened as keyed !:
        !      if not then just delte rec= !:
        ! this function will return a 1 if successful or a -Error Number if not, this function never returns a 0
23670   dim dr_record$*32767
23675   dim dr_key_original$*512 ! Key of the original record (the record to be deleted)
23680   dim dr_key_nomatch ! 0=No, 1=Yes, Could find the Record to be deleted, but the Keys are no longer matching
23685   gosub SETUP_MESSAGEBOX
23690   let form_generic_c_len=min(rln(dr_file_handle),32767) ! necessary for FORM_GENERIC_C
23695   let set_fndelrec=1
23700 ! read,release rec= and get the key
23705   let dr_key_original$=fnkeybuildby_recno$(dr_file_handle,dr_record_number)
23710   let dr_key_nomatch=dr_found=0
23715   restore #dr_file_handle,key=dr_key_original$,release: nokey DR_RESTORE_NOKEY ioerr DR_RESTORE_ERR
23720   do 
23725     read #dr_file_handle,using FORM_GENERIC_C,release: dr_record$
23730     if dr_record_number=rec(dr_file_handle) then 
23735       let dr_found=1
23740     else if dr_key_original$<>fnkeybuildby_buff$(dr_file_handle,dr_record$) then 
23745       let dr_key_nomatch=1
23750     end if 
23755   loop until dr_found or dr_key_nomatch
23760   goto DR_FINIS
23765 DR_RESTORE_NOKEY: ! 
23770   let dr_key_nomatch=1
23775   goto DR_FINIS
23780 DR_RESTORE_ERR: ! 
23785   if err=702 then let dr_found=0 : let dr_key_nomatch=1 : goto DR_FINIS else goto DR_ERR_GENERIC
23790 DR_ERR_DELETE: ! 
23795   if err=721 and lwrc$(env$("Developer"))='yes' then !:
          let fnmessagebox_("An Error 721 occured because the calling program passed a file handle that points to a File which has not been opened OutIn.",mb_exclamation+mb_okonly,"Collection-Master Developer") !:
          let set_fndelrec=-err : goto DR_XIT else goto DR_ERR_GENERIC
23800 DR_ERR_GENERIC: ! 
23805   let set_fndelrec=-err ! LET FNMESSAGEBOX_("An Error "&STR$(ERR)&" on line "&STR$(LINE)&" during a fnDelRec("&STR$(DR_FILE_HANDLE)&",("&STR$(DR_RECORD_NUMBER)&").",MB_EXCLAMATION+MB_OKONLY,"Collection-Master") !:
        goto DR_XIT
23810 DR_FINIS: ! 
23815   if dr_found and rec(dr_file_handle)=dr_record_number then 
23820     read #dr_file_handle,same: 
23825     delete #dr_file_handle: ioerr DR_ERR_DELETE
23830   else if dr_key_nomatch then 
23835     delete #dr_file_handle,rec=dr_record_number: ioerr DR_ERR_DELETE
23840     if lwrc$(env$("Developer"))='yes' then let fn_log("Dev-[Session].log","fnDel_Rec tried to delete from "&file$(dr_file_handle)&" Record Number "&str$(dr_record_number)&" and was forced to do it via ""Delete #X:Rec=""")
23845   end if 
23850 DR_XIT: ! 
23855   let fndelrec=set_fndelrec
23860 fnend 
23870 def library fnmatrices(mat mat_code$) ! Mat_
23872   gosub SETUP_LIBRARY
23874   gosub SETUP_SQL
23876   let fnmatrices=fn_matrices(mat mat_code$) ! Mat_
23878 fnend  ! FnMatrices
23880 def fn_matrices(mat mat_code$) ! Mat_
23885   if ~mat_setup then 
23890     let mat_setup=1
23895     dim mat_lp_handle(1)
23900     dim mat_heading$*512,mat_lp_head$*512
23905     dim mat_grid_line$(1)*80
23910     dim mat_display_line$*512
23915     let mat_heading$="Heading=PF Code;Type;Forw;EDI Code;Action 1;Action 2;Action 3;Action 4;Action 5;Action 6;Action 7;Action 8;Action 9;Action 10"
23920     let mat_lp_head$="Title=Matching EDI Matrices "&mat_heading$ ! &" WIDTH=10;10;10;10;10;10;10;10;10;10;10;10;10" ! &" FORM=C 10;C 10;C 10;C 10;C 10;C 10;C 10;C 10;C 10;C 10;C 10;C 10;C 10"
23925   end if  ! ~Mat_Setup
23930   let mat_edimatrx_handle=fnindex_handle("Name=EDI\EDIMatrx.Int,KFName=EDI\EDIMatrx.Idx",'',mat_edimatrx_record_prior)
23935   if env$("GUIMode")<>"ON" then gosub ERASE_BUTTONS
23940   let mat_grid_line_item=0
23945   for mat_code_item = 1 to udim(mat mat_code$)
23950     dim mat_pf_code_filter$*8
23955     let mat_pf_code_filter$=rpad$(mat_code$(mat_code_item),kln(mat_edimatrx_handle,1))
23960     restore #mat_edimatrx_handle,search>=mat_pf_code_filter$: nokey MAT_EDIMATRX_EOF
23965     do 
23970       read #mat_edimatrx_handle,using edimatrx_formall$,release: mat edimatrx_data$,mat edimatrx_data eof MAT_EDIMATRX_EOF nokey MAT_EDIMATRX_EOF
23975       if edimatrx_data$(edimatrx_pf_code)<>mat_pf_code_filter$ then goto MAT_EDIMATRX_EOF
23980       let mat_display_line$=mat_code$(mat_code_item)&""&edimatrx_data$(edimatrx_matrix_type)&""&edimatrx_data$(edimatrx_forw)&""&edimatrx_data$(edimatrx_edi_code)&""&edimatrx_data$(edimatrx_action_1)&""&edimatrx_data$(edimatrx_action_2)&""&edimatrx_data$(edimatrx_action_3)&""&edimatrx_data$(edimatrx_action_4)&""&edimatrx_data$(edimatrx_action_5)&""&edimatrx_data$(edimatrx_action_6)&""&edimatrx_data$(edimatrx_action_7)&""&edimatrx_data$(edimatrx_action_8)&""&edimatrx_data$(edimatrx_action_9)&""&edimatrx_data$(edimatrx_action_10)
23985       mat mat_grid_line$(mat_grid_line_item+=1)
23990       let mat_grid_line$(mat_grid_line_item)=mat_display_line$(1:80)
23995       if env$("GUIMode")="ON" then 
24000         if mat_lp_handle(1)=0 then let mat_lp_handle(1)=fngethandle_
24005         let fn_list_print(mat_display_line$,mat_lp_handle(1),0,mat_lp_head$,3,2,20,78)
24010       end if  ! Env$("GUIMode")="ON"
24015     loop 
24020 MAT_EDIMATRX_EOF: ! 
24025   next mat_code_item
24027   if mat_grid_line_item<=0 then let fnmessagebox_("Document code "&trim$(mat_code$(1))&" is not assigned to any EDI matrices.",48,"Matrix Search Results") : goto L24085
24030   if mat_grid_line_item>0 then 
24035     if env$("GUIMode")="ON" then 
24040       let mat_choice=0
24045       let fn_list_print_pause(mat mat_lp_handle,mat_lp_handle(1),1,close_after_view=1)
24050       let matrices_result_key$=fn_matrices_line_to_key$(fn_list_print_choice$(mat_lp_handle(1)))
24055     else 
24060       mat mat_grid_line$(udim(mat mat_edimatrx_data_01$))
24065       let mat_choice=fnwinscroll_(mat mat_grid_line$,0,mat_heading$)
24070       let matrices_result_key$=fn_matrices_line_to_key$(mat_grid_line$(mat_choice))
24075     end if 
24080   end if  ! Mat_Grid_Line_Item>0
24085 L24085: if mat_edimatrx_record_prior<=0 then close #mat_edimatrx_handle: 
24090 fnend  ! fn_matrices
24100 def library fnmatrices_result_key$
24102   let fnmatrices_result_key$=fn_matrices_result_key$
24104 fnend  ! fnmatrices_result_key$
24110 def fn_matrices_result_key$
24112 ! fn_matrices MUST be run before this function.  This function simply returns the key value of the selected record from the fn_matrices display
24114 ! this function does not take into account any FKey or button pressed.
24116   let fn_matrices_result_key$=matrices_result_key$
24118 fnend  ! fn_matrices_result_key$
24120 def fn_matrices_line_to_key$(mltk_line$)
24122 ! pr 'mltk_line$="'&mltk_line$&'"' : pause
24124 ! 
24126 ! 
24128 ! 
24130   let fn_matrices_line_to_key$=''
24132 fnend  ! fn_matrices_line_to_key$
24140 FA: form pos 74,x 2,pd 6.2,c 1,10*pd 6.2,pos 147,b 3,pos 45,3*pd 6.2
24142 FB: form pos 74,x 2,pd 6.2,c 1,9*pd 6.2,b 4.2,pos 147,b 3,pos 45,3*pd 6.2,pos 141,bh 3,pos 144,bh 3
24144 FC: form pos 74,x 2,pd 6.2,c 1,pd 6.2,c 1,3*pd 6.2,pos 147,b 3,pos 45,3*pd 6.2,pos 108,4*bh 4.2,bh 3
24146 FI: form pos 74,x 2,pd 6.2,c 20,c 8,pos 137,b 4.2,c 1,pos 147,b 3,pos 45,3*pd 6.2
24150 dim buckets_key$*80
24155 def library fnget_buckets(buckets_handle,_finan_fileno$,_finan_date,_finan_time,_finan_c0de$,_finan_type$,_finan_recno,mat buckets_categ,mat buckets_amt)
24160   let nbuckets=0 !:
        mat buckets_categ(0)=(0) !:
        mat buckets_amt(0)=(0) !:
        let buckets_key$=_finan_fileno$&cnvrt$('BH 4',_finan_date)&cnvrt$('BH 4',_finan_time)&_finan_c0de$&_finan_type$&cnvrt$('BH 4',_finan_recno)
24165   read #buckets_handle,using "FORM POS 1,C 8,2*BH 4,C 8,C 1,2*BH 4,BH 2,PD 6.2",key=buckets_key$,release: tfileno$,t_trans_date,t_trans_time,t_c0de$,t_type$,t_recno,t_refno,t_category,t_amount nokey L24190
24170 L24170: if t_recno<>_finan_recno then goto L24190
24175   let nbuckets+=1 !:
        mat buckets_categ(nbuckets) : mat buckets_amt(nbuckets) !:
        let buckets_categ(nbuckets)=t_category !:
        let buckets_amt(nbuckets)=t_amount
24180   read #buckets_handle,using "FORM POS 1,C 8,2*BH 4,C 8,C 1,2*BH 4,BH 2,PD 6.2",release: tfileno$,t_trans_date,t_trans_time,t_c0de$,t_type$,t_recno,t_refno,t_category,t_amount eof L24190
24185   goto L24170
24190 L24190: ! END OF BUCKETS
24195   let fnget_buckets=nbuckets
24200 fnend 
24210 def library fnsql2finan(&fileno$,mat s2f_finan_data$,mat s2f_finan_data,&c0de$,&trans_date$,&trans_time$,&user,&recno,&received,&disbursed,&amount,&datee$,&refno,&coll_costs,&coll_charges,&other_fees,&daily11,&co_fees,&interest,&stat_due,&costs_due,&charges_due,&contract,&checkno,&sf_out,&comm_out,&sf_c_out,&comm_c_out,&bpj$,&bill$,mat frec,mat filerec,mat line1,mat line2,mat line3) ! calling program must Dim FileRec$(20),FRec(20)
24212   let fnsql2finan=fnsql2finan_(fileno$,mat s2f_finan_data$,mat s2f_finan_data,c0de$,trans_date$,trans_time$,user,recno,received,disbursed,amount,datee$,refno,coll_costs,coll_charges,other_fees,daily11,co_fees,interest,stat_due,costs_due,charges_due,contract,checkno,sf_out,comm_out,sf_c_out,comm_c_out,bpj$,bill$,mat frec,mat filerec,mat line1,mat line2,mat line3)
24214 fnend  ! fnSQL2Finan
24220 def fnsql2finan_(&fileno$,mat s2f_finan_data$,mat s2f_finan_data,&c0de$,&trans_date$,&trans_time$,&user,&recno,&received,&disbursed,&amount,&datee$,&refno,&coll_costs,&coll_charges,&other_fees,&daily11,&co_fees,&interest,&stat_due,&costs_due,&charges_due,&contract,&checkno,&sf_out,&comm_out,&sf_c_out,&comm_c_out,&bpj$,&bill$,mat frec,mat filerec,mat line1,mat line2,mat line3)
24222   if ~setup_sql then gosub SETUP_SQL
24224 READ_NEW_FINAN: mat line1=(0): mat line2=(0): mat line3=(0) !:
        let refno=in=out=co_fees=sf_out=comm_out=sf_c_out=comm_c_out=invpay=datee=0 : let inv$="": let bill$=invver$=datee$="" !:
        ! ** What about INV?
24226   let trans_date=s2f_finan_data(finan_trans_date): !:
        let trans_date$=fndate10_$(str$(s2f_finan_data(finan_trans_date))) !:
        let trans_time=s2f_finan_data(finan_trans_time) !:
        let trans_time$=fnstime_$(s2f_finan_data(finan_trans_time)) !:
        let user=s2f_finan_data(finan_user_id) !:
        let recno=s2f_finan_data(finan_recno) !:
        let received=line1(6)=s2f_finan_data(finan_received) !:
        let disbursed=s2f_finan_data(finan_disbursed)
24228   let amount=s2f_finan_data(finan_amount) !:
        let datee$=fndate10_$(str$(s2f_finan_data(finan_datee))) !:
        let refno=s2f_finan_data(finan_refno) !:
        let coll_costs=s2f_finan_data(finan_coll_costs) !:
        let line2(5)=s2f_finan_data(finan_costs_expended) !:
        let coll_charges=s2f_finan_data(finan_coll_charged) !:
        let line2(4)=s2f_finan_data(finan_costs_returned)
24230   let line2(1)=s2f_finan_data(finan_principal) !:
        let line2(2)=s2f_finan_data(finan_interest) !:
        let line1(2)=s2f_finan_data(finan_costs) !:
        let line3(1)=s2f_finan_data(finan_prin) !:
        let line3(2)=s2f_finan_data(finan_contract) !:
        let line3(3)=s2f_finan_data(finan_legal) !:
        let line3(8)=s2f_finan_data(finan_other)
24232   let line2(6)=s2f_finan_data(finan_costs_received) !:
        let line2(7)=s2f_finan_data(finan_suit_fee) !:
        let line2(8)=s2f_finan_data(finan_commission) !:
        let line1(3)=s2f_finan_data(finan_stat_fee) !:
        let other_fees=s2f_finan_data(finan_other_fee) !:
        let line1(4)=s2f_finan_data(finan_net) !:
        let daily11=s2f_finan_data(finan_adjustments) !:
        let co_fees=s2f_finan_data(finan_co_fees) !:
        let int=s2f_finan_data(finan_int) !:
        let cbal=s2f_finan_data(finan_cost_balance)
24234   let stat_due=s2f_finan_data(finan_stat_due) !:
        let costs_due=s2f_finan_data(finan_costs_due) !:
        let charges_due=s2f_finan_data(finan_charges_due) !:
        let other_due=s2f_finan_data(finan_other_due) !:
        let filerec(1)=s2f_finan_data(finan_claim_orig_bal) !:
        let filerec(2)=s2f_finan_data(finan_claim_suit_amt) !:
        let filerec(3)=s2f_finan_data(finan_stat_fee) !:
        let filerec(4)=s2f_finan_data(finan_claim_jdg_amt)
24236   let filerec(5)=line1(5)=s2f_finan_data(finan_balance) !:
        let filerec(6)=s2f_finan_data(finan_cost_balance) !:
        let filerec(8)=s2f_finan_data(finan_tot_principal) !:
        let filerec(9)=s2f_finan_data(finan_tot_interest) !:
        let filerec(18)=s2f_finan_data(finan_tot_commission) !:
        let filerec(19)=s2f_finan_data(finan_tot_suit_fee) !:
        let filerec(20)=s2f_finan_data(finan_tot_stat_fee) !:
        let filerec(16)=s2f_finan_data(finan_tot_rec_exp) !:
        let filerec(17)=s2f_finan_data(finan_tot_costs)
24238   let checkno=s2f_finan_data(finan_checkno) !:
        let contract=s2f_finan_data(finan_claim_contract) !:
        let frec(14)=s2f_finan_data(finan_claim_pre_j_int) !:
        let frec(22)=s2f_finan_data(finan_compr_amt)
24240   let fileno$=s2f_finan_data$(finan_fileno) !:
        let c0de$=s2f_finan_data$(finan_code) !:
        let bpj$=s2f_finan_data$(finan_bpj) !:
        let bill$=s2f_finan_data$(finan_bill) !:
        let line2(3)=filerec(8)+filerec(9)
24242   let sf_out=s2f_finan_data(finan_sf_out) !:
        let comm_out=s2f_finan_data(finan_comm_out) !:
        let sf_c_out=s2f_finan_data(finan_sf_c_out) !:
        let comm_c_out=s2f_finan_data(finan_comm_c_out) ! ** ?? Should SF_OUT be 50 or 49?
24244 ! LET MISC_AMT1=0 !:
        ! ** MISC_AMT IS MERCHANDICE, THIS IS NOW DETERMINED VIA BUCKETS !:
        ! ** I DON'T THINK WE CARE ABOUT THIS ANY MORE
24246 fnend  ! FNSQL2FINAN_
24250 L24250: form pos 1,c 8,bh 4,bh 4,c 28,c 20,c 8,pos 74,bh 2
24260 def library fno_rates(mat rates,d1_state$)
24262   if ~cls_setup then let fnclssetup
24270   mat rates(2)=o_rates
24275   let _d1_state=srch(mat o_rates_states$,uprc$(trim$(d1_state$)))
24280   if _d1_state>0 then let rates(1)=o_rates_pre(_d1_state) !:
          let rates(2)=o_rates_post(_d1_state)
24285 fnend 
24290 def library fnsalutation$*80(name$*80;sal_type)
24291   let is_uppercase=(name$==uprc$(name$))
24292   if ~cls_setup then let fnclssetup
24294   dim last_name$*80,sal$*80
24296 ! REM 1 Addr full name,2 Salutation 3 first  4 last  5 Full Name
24298   if sal_type=0 then let sal_type=2
24300   let _pos1=pos(name$,"/",3) !:
        let name$=rtrm$(name$) !:
        let nlen=len(name$) !:
        let sal=10 !:
        if _pos1<=0 then let sal=11 ! Use 11 or "Corp Salutation if no slash in Name!"
24302   let sal$=trim$(name$(nlen:nlen)) !:
        let tsal=val(sal$) conv L24310 !:
        if tsal=0 then goto L24310 else !:
          let sal=tsal : let name$(nlen:nlen)=""
24304   if _pos1<=0 then goto L24332
24310 L24310: let last_name$=rtrm$(name$(_pos1+1:len(name$)))
24312   let name$=name$(1:_pos1-1)
24314   if sal_type=1 or sal_type=5 then !:
          let sal$=last_name$&" "&name$: goto L24318
24316   if sal_type=3 then !:
          let sal$=last_name$ else !:
          let sal$=name$
24318 L24318: ! LET Y$="Mr.       Mrs.      Ms.       Mr. & Mrs.Dr.       Capt.     Gentlemen" !:
        let last_name$=rpt$("*",80)
24320   let name$=trim$(salut$(sal)) !:
        let sal$=trim$(sal$) !:
        if sal_type=2 then let name$="Dear "&name$: let sal$=sal$&":"
24322   if sal_type=5 then let name$=""
24324   let salut_corp=0 !:
        if len(salut$(sal))=pos(salut$(sal),":",-1) then let salut_corp=1
24326   if salut_corp=1 and sal_type=2 then !:
          let name$=trim$(salut$(sal)): let sal$="" else !:
          if salut_corp=1 then let name$=""
24327   if is_uppercase then !:
          let name$=uprc$(name$) !:
          let sal$=uprc$(sal$)
24328   let fnsalutation$=trim$(ltrm$(rtrm$(name$))&" "&sal$)
24330   goto L24336
24332 L24332: ! COMMERCIAL ACCOUNT GENTLEMEN PROMPT"
24333   if is_uppercase then !:
          let name$=uprc$(name$) !:
          let sal$=uprc$(sal$)
24334   if sal_type=2 then !:
          let fnsalutation$=trim$(salut$(sal)) else !:
          let fnsalutation$=name$
24336 L24336: fnend 
24340 ! CHECK_APP_NAME changes the "CLS Applicatinn Name" !:
      ! TC Must = 2 !:
      ! mat REFNO or REFNO(2) MUST contain the LAST Check #!:
      ! FILENO + MESSAGE report
24342 def library fncheck_app_name(fileno$*8,trust$,message$*999,tc,mat refno)
24344   dim check_app$*999
24346   if tc=2 then 
24348     let _check_app=pos(env$("APPLICATION_NAME")," ")
24350     let check_app$=env$("APPLICATION_NAME")(1:_check_app)&" Check #"&str$(refno(tc))&" "&trust$&" ID:"&session$&" File #:"&fileno$&" : "&rtrm$(message$)&" - " !:
          ! User="&LOGIN_NAME$&"
24352     execute "*CONFIG APPLICATION "&check_app$(1:100)
24354   end if 
24356 fnend 
24360 def library fncm_app_name
24362   execute "*CONFIG APPLICATION "&env$("APPLICATION_NAME")
24364 fnend 
24370 def library fnhtml_to_systempc$*4096(htsp_input$*4096) ! htsp_
24372   let fnhtml_to_systempc$=fn_html_to_systempc$(htsp_input$)
24374 fnend  ! fnhtml_to_systempc$
24380 def fn_html_to_systempc$*4096(htsp_input$*4096)
24385 ! converts from HTML to SystemPC  (opposite of fnhtml)
24390 ! if ~xlate_setup then let fnxlate_setup
24395 ! ! ASCII codes 252-255
24400 ! ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(252),"*") superscript n
24405 ! ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(255),"*") unknown
24410 ! ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(254),"*") unknown
24415   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(253),"&#178;") ! &sup2;
24420 ! ! ASCII codes 248-251
24425 ! ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(251),"*") radical
24430   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(250),"&#183;") ! &middot;
24435   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(249),"&#183;") ! &middot;
24440   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(248),"&#176;") ! &deg;
24445 ! ! ASCII codes 244-247
24450 ! ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(247),"*") equivalent
24455   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(246),"&#247;") ! &divide;
24460 ! ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(245),"*") inverted hook
24465 ! ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(244),"*") hook
24470 ! ! ASCII codes 240-243
24475 ! ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(240),"*") three horizontal bars
24480   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(243),"&lt;=")
24485   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(242),"&gt;=")
24490   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(241),"&#177;") ! &plusmn;
24495 ! ! ASCII codes 224-239 (Greek symbols)
24500 ! ! ASCII codes 176-223 (Line drawing)
24505 ! ! ASCII codes 172-175
24510   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(175),"&#187;") ! &raquo;
24515   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(174),"&#171;") ! &laquo;
24520   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(173),"&#161;") ! &iexcl;
24525   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(172),"&#188;") ! &frac14;
24530 ! ! ASCII codes 168-171
24535   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(171),"&#189;") ! &frac12;
24540   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(170),"&#172;") ! &not;
24545 ! ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(169),"*") reversed not sign?
24550   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(168),"&#191;") ! &iquest;
24555 ! ! ASCII codes 164-167
24560   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(167),"&#186;") ! &ordm;
24565   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(166),"&#170;") ! &ordf;
24570   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(165),"&#209;") ! &Ntilde;
24575   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(164),"&#241;") ! &ntilde;
24580 ! ! ASCII codes 160-163
24585   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(163),"&#250;") ! &uacute;
24590   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(162),"&#243;") ! &oacute;
24595   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(161),"&#237;") ! &iacute;
24600   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(160),"&#225;") ! &aacute;
24605 ! ! ASCII codes 156-159
24610 ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(159),"*") elongated 'f'
24615 ! LET htsp_input$=fn_srep_reverse$(htsp_input$,CHR$(158),"*") Pt symbol
24620   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(157),"&#165;") ! &yen;
24625   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(156),"&#163;") ! &pound;
24630 ! ! ASCII codes 152-155
24635   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(155),"&#162;") ! &cent;
24640   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(154),"&#220;") ! &Uuml;
24645   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(153),"&#214;") ! &Ouml;
24650   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(152),"&#255;") ! &yuml;
24655 ! ! ASCII codes 148-151
24660   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(151),"&#249;") ! &ugrave;
24665   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(150),"&#251;") ! &ucirc;
24670   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(149),"&#242;") ! &ograve;
24675   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(148),"&#246;") ! &ouml;
24680 ! ! ASCII codes 144-147
24685   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(147),"&#212;") ! &ocirc;
24690   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(146),"&#196;") ! &AElig;
24695   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(145),"&#230;") ! &aelig;
24700   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(144),"&#201;") ! &Eacute;
24705 ! ! ASCII codes 140-143
24710   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(143),"&#197;") ! &Aring;
24715   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(142),"&#196;") ! &Auml;
24720   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(141),"&#236;") ! &igrave;
24725   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(140),"&#238;") ! &icirc;
24730 ! ! ASCII codes 136-139
24735   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(139),"&#239;") ! &iuml;
24740   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(138),"&#232;") ! &egrave;
24745   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(137),"&#235;") ! &euml;
24750   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(136),"&#234;") ! &ecirc;
24755 ! ! ASCII codes 132-135
24760   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(135),"&#231;") ! &ccedil;
24765   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(134),"&#229;") ! &aring;
24770   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(133),"&#224;") ! &agrave;
24775   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(132),"&#228;") ! &auml;
24780 ! ! ASCII codes 128-131
24785   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(131),"&#226;") ! $acirc;
24790   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(130),"&#233;") ! &eacute;
24795   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(129),"&#252;") ! &uuml;
24800   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(128),"&#199;") ! &Ccedil;
24805 ! LET HTSP_INPUT$=FN_SREP_REVERSE$(HTSP_INPUT$,CHR$(254),"^")  ! Don't Convert ^ into chr$(254!)  (^ is Carot)
24810   let htsp_input$=fn_srep_reverse$(htsp_input$,"'","&#39;")
24815   let htsp_input$=fn_srep_reverse$(htsp_input$,"#","&#35;")
24820   let htsp_input$=fn_srep_reverse$(htsp_input$,"","-")
24825   let htsp_input$=fn_srep_reverse$(htsp_input$,"","|")
24830   let htsp_input$=fn_srep_reverse$(htsp_input$,">","&gt;")
24835   let htsp_input$=fn_srep_reverse$(htsp_input$,"<","&lt;")
24840   let htsp_input$=fn_srep_reverse$(htsp_input$,chr$(34),"&quot;")
24845   let htsp_input$=fn_srep_reverse$(htsp_input$,"&","&amp;")
24850 ! let htsp_input$ = xlate$(htsp_input$, html_xlate$)
24855   let fn_html_to_systempc$=rtrm$(htsp_input$) ! trim$ removed - perhaps rtrm$ should be removed too.
24860 fnend  ! fn_html_to_systempc$
24870 def fn_srep_reverse$*4096(sr_input$*4096,sr_replace_to$*10,sr_replace_from$*10) ! sr_
24872   let fn_srep_reverse$=srep$(sr_input$,sr_replace_from$,sr_replace_to$)
24874 fnend  ! fn_srep_reverse$
24880 def fn_unicode_to_ansi(&uta_text$)
24882 ! converst UTF-8 (without BOM) to ASCII
24884   let hts_return$=srep$(hts_return$,hex$("E282AC"),chr$(128))
24886   let hts_return$=srep$(hts_return$,hex$("C281"),chr$(129))
24888   let hts_return$=srep$(hts_return$,hex$("E2809A"),chr$(130))
24890   let hts_return$=srep$(hts_return$,hex$("C692"),chr$(131))
24892   let hts_return$=srep$(hts_return$,hex$("E2809E"),chr$(132))
24894   let hts_return$=srep$(hts_return$,hex$("E280A6"),chr$(133))
24896   let hts_return$=srep$(hts_return$,hex$("E280A0"),chr$(134))
24898   let hts_return$=srep$(hts_return$,hex$("E280A1"),chr$(135))
24900   let hts_return$=srep$(hts_return$,hex$("CB86"),chr$(136))
24902   let hts_return$=srep$(hts_return$,hex$("E280B0"),chr$(137))
24904   let hts_return$=srep$(hts_return$,hex$("C5A0"),chr$(138))
24906   let hts_return$=srep$(hts_return$,hex$("E280B9"),chr$(139))
24908   let hts_return$=srep$(hts_return$,hex$("C592"),chr$(140))
24910   let hts_return$=srep$(hts_return$,hex$("C28D"),chr$(141))
24912   let hts_return$=srep$(hts_return$,hex$("C5BD"),chr$(142))
24914   let hts_return$=srep$(hts_return$,hex$("C28F"),chr$(143))
24916   let hts_return$=srep$(hts_return$,hex$("C290"),chr$(144))
24918   let hts_return$=srep$(hts_return$,hex$("E28098"),"'") ! ,chr$(145))  ! E28098 is Unicode  for Fancy Open
24920   let hts_return$=srep$(hts_return$,hex$("E28099"),"'") ! ,chr$(146))  ! E28099 is Unicode for Fancy Closed
24922   let hts_return$=srep$(hts_return$,hex$("E2809C"),'"') ! ,chr$(147))  ! E2809C is Unicode for Fancy Open
24924   let hts_return$=srep$(hts_return$,hex$("E2809D"),'"') ! ,chr$(148))  ! E2809D is Unicode for Fancy Closed
24926   let hts_return$=srep$(hts_return$,hex$("E280A2"),chr$(149))
24928   let hts_return$=srep$(hts_return$,hex$("E28093"),chr$(150))
24930   let hts_return$=srep$(hts_return$,hex$("E28094"),'-') ! ,chr$(151)) ! E28094 is a long dash
24932   let hts_return$=srep$(hts_return$,hex$("CB9C"),chr$(152))
24934   let hts_return$=srep$(hts_return$,hex$("E284A2"),chr$(153))
24936   let hts_return$=srep$(hts_return$,hex$("C5A1"),chr$(154))
24938   let hts_return$=srep$(hts_return$,hex$("E280BA"),chr$(155))
24940   let hts_return$=srep$(hts_return$,hex$("C593"),chr$(156))
24942   let hts_return$=srep$(hts_return$,hex$("C29D"),chr$(157))
24944   let hts_return$=srep$(hts_return$,hex$("C5BE"),chr$(158))
24946   let hts_return$=srep$(hts_return$,hex$("C5B8"),chr$(159))
24948   let hts_return$=srep$(hts_return$,hex$("C2A0"),chr$(160))
24950   let hts_return$=srep$(hts_return$,hex$("C2A1"),chr$(161))
24952   let hts_return$=srep$(hts_return$,hex$("C2A2"),chr$(162))
24954   let hts_return$=srep$(hts_return$,hex$("C2A3"),chr$(163))
24956   let hts_return$=srep$(hts_return$,hex$("C2A4"),chr$(164))
24958   let hts_return$=srep$(hts_return$,hex$("C2A5"),chr$(165))
24960   let hts_return$=srep$(hts_return$,hex$("C2A6"),chr$(166))
24962   let hts_return$=srep$(hts_return$,hex$("C2A7"),chr$(167))
24964   let hts_return$=srep$(hts_return$,hex$("C2A8"),chr$(168))
24966   let hts_return$=srep$(hts_return$,hex$("C2A9"),chr$(169))
24968   let hts_return$=srep$(hts_return$,hex$("C2AA"),chr$(170))
24970   let hts_return$=srep$(hts_return$,hex$("C2AB"),chr$(171))
24972   let hts_return$=srep$(hts_return$,hex$("C2AC"),chr$(172))
24974   let hts_return$=srep$(hts_return$,hex$("C2AD"),chr$(173))
24976   let hts_return$=srep$(hts_return$,hex$("C2AE"),chr$(174))
24978   let hts_return$=srep$(hts_return$,hex$("C2AF"),chr$(175))
24980   let hts_return$=srep$(hts_return$,hex$("C2B0"),chr$(176))
24982   let hts_return$=srep$(hts_return$,hex$("C2B1"),chr$(177))
24984   let hts_return$=srep$(hts_return$,hex$("C2B2"),chr$(178))
24986   let hts_return$=srep$(hts_return$,hex$("C2B3"),chr$(179))
24988   let hts_return$=srep$(hts_return$,hex$("C2B4"),chr$(180))
24990   let hts_return$=srep$(hts_return$,hex$("C2B5"),chr$(181))
24992   let hts_return$=srep$(hts_return$,hex$("C2B6"),chr$(182))
24994   let hts_return$=srep$(hts_return$,hex$("C2B7"),chr$(183))
24996   let hts_return$=srep$(hts_return$,hex$("C2B8"),chr$(184))
24998   let hts_return$=srep$(hts_return$,hex$("C2B9"),chr$(185))
25000   let hts_return$=srep$(hts_return$,hex$("C2BA"),chr$(186))
25002   let hts_return$=srep$(hts_return$,hex$("C2BB"),chr$(187))
25004   let hts_return$=srep$(hts_return$,hex$("C2BC"),chr$(188))
25006   let hts_return$=srep$(hts_return$,hex$("C2BD"),chr$(189))
25008   let hts_return$=srep$(hts_return$,hex$("C2BE"),chr$(190))
25010   let hts_return$=srep$(hts_return$,hex$("C2BF"),chr$(191))
25012   let hts_return$=srep$(hts_return$,hex$("C380"),chr$(192))
25014   let hts_return$=srep$(hts_return$,hex$("C381"),chr$(193))
25016   let hts_return$=srep$(hts_return$,hex$("C382"),chr$(194))
25018   let hts_return$=srep$(hts_return$,hex$("C383"),chr$(195))
25020   let hts_return$=srep$(hts_return$,hex$("C384"),chr$(196))
25022   let hts_return$=srep$(hts_return$,hex$("C385"),chr$(197))
25024   let hts_return$=srep$(hts_return$,hex$("C386"),chr$(198))
25026   let hts_return$=srep$(hts_return$,hex$("C387"),chr$(199))
25028   let hts_return$=srep$(hts_return$,hex$("C388"),chr$(200))
25030   let hts_return$=srep$(hts_return$,hex$("C389"),chr$(201))
25032   let hts_return$=srep$(hts_return$,hex$("C38A"),chr$(202))
25034   let hts_return$=srep$(hts_return$,hex$("C38B"),chr$(203))
25036   let hts_return$=srep$(hts_return$,hex$("C38C"),chr$(204))
25038   let hts_return$=srep$(hts_return$,hex$("C38D"),chr$(205))
25040   let hts_return$=srep$(hts_return$,hex$("C38E"),chr$(206))
25042   let hts_return$=srep$(hts_return$,hex$("C38F"),chr$(207))
25044   let hts_return$=srep$(hts_return$,hex$("C390"),chr$(208))
25046   let hts_return$=srep$(hts_return$,hex$("C391"),chr$(209))
25048   let hts_return$=srep$(hts_return$,hex$("C392"),chr$(210))
25050   let hts_return$=srep$(hts_return$,hex$("C393"),chr$(211))
25052   let hts_return$=srep$(hts_return$,hex$("C394"),chr$(212))
25054   let hts_return$=srep$(hts_return$,hex$("C395"),chr$(213))
25056   let hts_return$=srep$(hts_return$,hex$("C396"),chr$(214))
25058   let hts_return$=srep$(hts_return$,hex$("C397"),chr$(215))
25060   let hts_return$=srep$(hts_return$,hex$("C398"),chr$(216))
25062   let hts_return$=srep$(hts_return$,hex$("C399"),chr$(217))
25064   let hts_return$=srep$(hts_return$,hex$("C39A"),chr$(218))
25066   let hts_return$=srep$(hts_return$,hex$("C39B"),chr$(219))
25068   let hts_return$=srep$(hts_return$,hex$("C39C"),chr$(220))
25070   let hts_return$=srep$(hts_return$,hex$("C39D"),chr$(221))
25072   let hts_return$=srep$(hts_return$,hex$("C39E"),chr$(222))
25074   let hts_return$=srep$(hts_return$,hex$("C39F"),chr$(223))
25076   let hts_return$=srep$(hts_return$,hex$("C3A0"),chr$(224))
25078   let hts_return$=srep$(hts_return$,hex$("C3A1"),chr$(225))
25080   let hts_return$=srep$(hts_return$,hex$("C3A2"),chr$(226))
25082   let hts_return$=srep$(hts_return$,hex$("C3A3"),chr$(227))
25084   let hts_return$=srep$(hts_return$,hex$("C3A4"),chr$(228))
25086   let hts_return$=srep$(hts_return$,hex$("C3A5"),chr$(229))
25088   let hts_return$=srep$(hts_return$,hex$("C3A6"),chr$(230))
25090   let hts_return$=srep$(hts_return$,hex$("C3A7"),chr$(231))
25092   let hts_return$=srep$(hts_return$,hex$("C3A8"),chr$(232))
25094   let hts_return$=srep$(hts_return$,hex$("C3A9"),chr$(233))
25096   let hts_return$=srep$(hts_return$,hex$("C3AA"),chr$(234))
25098   let hts_return$=srep$(hts_return$,hex$("C3AB"),chr$(235))
25100   let hts_return$=srep$(hts_return$,hex$("C3AC"),chr$(236))
25102   let hts_return$=srep$(hts_return$,hex$("C3AD"),chr$(237))
25104   let hts_return$=srep$(hts_return$,hex$("C3AE"),chr$(238))
25106   let hts_return$=srep$(hts_return$,hex$("C3AF"),chr$(239))
25108   let hts_return$=srep$(hts_return$,hex$("C3B0"),chr$(240))
25110   let hts_return$=srep$(hts_return$,hex$("C3B1"),chr$(241))
25112   let hts_return$=srep$(hts_return$,hex$("C3B2"),chr$(242))
25114   let hts_return$=srep$(hts_return$,hex$("C3B3"),chr$(243))
25116   let hts_return$=srep$(hts_return$,hex$("C3B4"),chr$(244))
25118   let hts_return$=srep$(hts_return$,hex$("C3B5"),chr$(245))
25120   let hts_return$=srep$(hts_return$,hex$("C3B6"),chr$(246))
25122   let hts_return$=srep$(hts_return$,hex$("C3B7"),chr$(247))
25124   let hts_return$=srep$(hts_return$,hex$("C3B8"),chr$(248))
25126   let hts_return$=srep$(hts_return$,hex$("C3B9"),chr$(249))
25128   let hts_return$=srep$(hts_return$,hex$("C3BA"),chr$(250))
25130   let hts_return$=srep$(hts_return$,hex$("C3BB"),chr$(251))
25132   let hts_return$=srep$(hts_return$,hex$("C3BC"),chr$(252))
25134   let hts_return$=srep$(hts_return$,hex$("C3BD"),chr$(253))
25136   let hts_return$=srep$(hts_return$,hex$("C3BE"),chr$(254))
25138   let hts_return$=srep$(hts_return$,hex$("C3BF"),chr$(255))
25160 fnend  ! fn_unicode_to_ansi
25170 FS: form pos 74,x 2,12*bh 4.2,6*bh 4.2
25180 !
25182 def library fndiary_exists(fileno$,dcode,ddate$,dcmt$*20,dqueue$,dtime$,dpriority$)
25184   let fndiary_exists=fndiary_exists_(fileno$,dcode,ddate$,dcmt$,dqueue$,dtime$,dpriority$)
25186 fnend 
25190 def fndiary_exists_(fileno$,dcode,ddate$,dcmt$*20,dqueue$,dtime$,dpriority$)
25192   if not h_diary_input then !:
          open #h_diary_input:=fngethandle_: "name=diary.int//6,kfname=diary.fil//6,shr",internal,input,keyed 
25194   let dcmt$=trim$(dcmt$(1:20)) : let match_found=0 : let dqueue$=trim$(dqueue$)
25200   read #h_diary_input,using F_DIARY,key=fileno$&ddate$&rpad$(dtime$(1:5),5)&lpad$(trim$(dpriority$),3),release: readno$,readcode,readcode$,readdate$,readcomm$,readque$,readtime$,readpri$ nokey X_DIARY_EXISTS
25205   do while fileno$=readno$ and ddate$=readdate$ and dtime$=readtime$ and match_found=0
25210     if readcode=dcode and trim$(readque$)=dqueue$ and dcmt$=trim$(readcomm$) then let match_found=1
25215     read #h_diary_input,using F_DIARY,release: readno$,readcode,readcode$,readdate$,readcomm$,readque$,readtime$,readpri$ eof X_DIARY_EXISTS
25220   loop 
25222 X_DIARY_EXISTS: !:
        let fndiary_exists_=match_found
25224 fnend 
25230 def library fnparse_name2(pn2_name$*256,mat pn2_name$)
25232   if ~cls_setup then let fnclssetup
25234   let fnparse_name2=fn_parse_name2(pn2_name$,mat pn2_name$)
25236 fnend  ! fnparse_name2
25240 def fn_parse_name2(pn2_name$*256,mat pn2_name$)
25242   let fnparse_name_$(pn2_name$,fn_parse_name_type(pn2_name$),mat pn2_name$)
25244 fnend  ! fn_Parse_Name2
25250 def fn_parse_name_type(pnt_name$*256) ! also in DBillRpt/Prog2
25255   let set_pnt=0
25260   if pos(pnt_name$,"/")>0 then let set_pnt=1 else let set_pnt=2
25265   let fn_parse_name_type=set_pnt
25270 fnend  ! fn_Parse_Name_Type
25280 def library fnatty1_data$*60(atty1_field$)
25282   if ~cls_setup then let fnclssetup
25284   let fnatty1_data$=fn_atty1_data$(atty1_field$)
25286 fnend  ! fnatty1_data$
25290 def fn_atty1_data$*60(atty1_field$) ! atty1_
25292   if ~setup_atty1 then 
25300     let setup_atty1=1
25302     if ~setup_sql_attyfile then gosub SETUP_SQL_ATTYFILE
25304     dim atty1_data$(1)*80,atty1_data(1),atty1_return$*80
25306     mat atty1_data$(udim(mat attyfile_data$)) : mat atty1_data(udim(mat attyfile_data))
25308     let atty1_attyfile_handle=fnindex_handle("Name=M:AttyFile,KFName=M:AttyFile.Idx", "",atty1_atty_rec_priot)
25310     read #atty1_attyfile_handle,using attyfile_formall$,key=cnvrt$("BH 2",1): mat atty1_data$,mat atty1_data
25312     if atty1_atty_rec_priot=-1 then 
25314       close #atty1_attyfile_handle: ioerr ignore
25320     else if atty1_atty_rec_priot>0 then 
25322       restore #atty1_attyfile_handle,key=cnvrt$("BH 2",atty1_atty_rec_priot): ioerr ignore
25324     end if  ! atty1_atty_rec_priot=-1   /   atty1_atty_rec_priot>0
25330   end if  ! ~setup_atty1
25332   let atty1_return$=''
25334   let atty1_field$=uprc$(trim$(atty1_field$))
25336   if atty1_field$='ATTY_NO' then let atty1_return$=str$(atty1_data(attyfile_atty_no))
25338   if atty1_field$='NAME' then let atty1_return$=atty1_data$(attyfile_name)
25340   if atty1_field$='ADDR' then let atty1_return$=atty1_data$(attyfile_addr)
25342   if atty1_field$='CSZ' then let atty1_return$=atty1_data$(attyfile_csz)
25344   if atty1_field$='BAR' then let atty1_return$=atty1_data$(attyfile_bar)
25346   if atty1_field$='INIT' then let atty1_return$=atty1_data$(attyfile_init)
25348   if atty1_field$='FIRM_NAME' then let atty1_return$=atty1_data$(attyfile_firm_name)
25350   if atty1_field$='FIRM_PHONE' then let atty1_return$=atty1_data$(attyfile_firm_phone)
25352   if atty1_field$='FIRM_FAX' then let atty1_return$=atty1_data$(attyfile_firm_fax)
25354   if atty1_field$='ATTY_KEY' then let atty1_return$=atty1_data$(attyfile_atty_key)
25356   if atty1_field$='EMAIL' then let atty1_return$=atty1_data$(attyfile_email)
25358   if atty1_field$='HOME_PAGE' then let atty1_return$=atty1_data$(attyfile_home_page)
25360   if atty1_field$='PHONE_EXT' then let atty1_return$=atty1_data$(attyfile_phone_ext)
25370   let fn_atty1_data$=atty1_return$
25372 fnend  ! fn_atty1_data$
25380 def library fnexit_cm
25382   if ~setup_fnexit_cm then gosub SETUP_FNEXIT_CM
25384   if ~env$("EXIT_CM")="YES" and ~env$("DONT_EXIT_CM")="YES" and policy_exit_cm and exists("EXIT_CM.TXT") then 
25386     open #admin_close_win:=fngethandle_: fn_open_parent$("SCol=8,SRow=10,Cols=65,Rows=5,BORDER=DN[X],N=[W],Caption=Administrator Request,Parent=None,Name=Admin-Close-Window"),display,outin 
25388     print bell; !:
          print #admin_close_win,fields "2,1,CC 65,[S]": "The Administrator has requested that you exit Collection-Master!" !:
          print #admin_close_win,fields "5,58,CC 7,[BUTTON],B0": "OK" !:
          print bell;bell; !:
          let kstat$(1,15) !:
          print bell;bell;
25390     close #admin_close_win: !:
          let setenv("EXIT_CM","YES") !:
          ! ENV tell CM to keep on quiting!
25392   end if  ! if EXISTS("EXIT_CM.TXT") THEN
25394   if env$("EXIT_CM")="YES" then 
25396     let fkey(93) !:
          let fnexit_cm=1
25398   end if  ! exit_CM: if ENV$("EXIT_CM") THEN
25400 fnend 
25410 SETUP_FNEXIT_CM: ! r: Setup Policy for EXIT CM.
25412 let setup_fnexit_cm=1
25414 if user_init$="" then let user_init$=fnuserinit$
25416 let policy_exit_cm=fnsecurity_("ADM:EXIT CM",'',0,user_init$,inquiry_only:=1) : if policy_exit_cm=-1 then let policy_exit_cm=0
25418 return ! /r
25420 ! ---------LIBRARY----------FNGET_SCRN()---------------------------
25425 def library fnget_scrn(mat scrn$)
25430   for z=1 to 23 !:
          let scrn$(z)=str$(z)&",2,C 78,[W]" !:
        next z
25435 fnend 
25440 def library fnwin_menu(caption$*80,_menu$*3999,_results$*3999;_status$*1999,wm_io_handle)
25445   for nmenu=11 to 22 !:
          let _menu$=srep$(_menu$,'[F'&str$(nmenu)&']','[Shift+F'&str$(nmenu-10)&']') !:
        next nmenu
25450 ! PRINT "MENU:";CAPTION$ !:
        ! LET KSTAT$(1)
25455   dim _tmenubar$(1)*80,_tmenuprg$(1)*80,_tmenustatus$(1)*80,tmenu$(1)*80, last_tmenubar$(1)*80,last_tmenuprg$(1)*80,last_tmenustatus$(1)*80
25460   if trim$(_menu$)="" then goto L25515
25465   let tmenu_items1=str2mat(caption$&";"&_menu$,mat _tmenubar$,";")
25470   let tmenu_items2=str2mat(";"&_results$,mat _tmenuprg$,";")
25475   let tmenu_items3=str2mat(";"&_status$,mat _tmenustatus$,";")
25480   if tmenu_items3<tmenu_items1 then !:
          mat _tmenustatus$(tmenu_items1) !:
          mat _tmenustatus$(tmenu_items3+1:tmenu_items1)=("E") ! ** Fill in any missing "E" status entries!
25485   if udim(_tmenubar$)<>udim(_tmenuprg$) or udim(_tmenubar$)<>udim(_tmenustatus$) then !:
          let fnmessagebox_("Alert - Pull Down Menu Has A Problem - MenuBar:"&str$(udim(_tmenubar$))&"- MENUPRG:"&str$(udim(_tmenuprg$))&"- MENUSTATUS:"&str$(udim(_tmenustatus$))) else !:
          goto L25492
25490   let debug_handle=fngethandle_ !:
        open #debug_handle: "name=[wbwork]debug.txt,replace",display,output  !:
        for z=1 to udim(_tmenuprg$) !:
          print #debug_handle: z;" - MenuBar:"&_tmenubar$(z)&"- MENUPRG:"&_tmenuprg$(z)&"- MENUSTATUS:"&_tmenustatus$(z) !:
        next z !:
        let buff$=file$(debug_handle) !:
        close #debug_handle: !:
        let scr_thaw: execute "sys start "&buff$
25492 L25492: if wm_io_handle then 
25494 ! DISPLAY Menu : "","","" ! This should work but doesn't
25495     display menu : mat _tmenubar$, mat _tmenuprg$, mat _tmenustatus$ ! For now, the menu is displayed on both screens. !:
          ! TODO: When BR fixes the bug, remove this unwanted menu.
25496     display #wm_io_handle,menu : mat _tmenubar$, mat _tmenuprg$, mat _tmenustatus$
25498   else 
25500     display menu : mat _tmenubar$, mat _tmenuprg$, mat _tmenustatus$
25502   end if  ! wm_io_handle
25515 L25515: fnend 
25520 F_MASTER_STATUS: form pos 299,c 8,c 3
25522 F_MASTER_STATUS2: form pos 732,c 8,pos 762,c 3
25524 F_DIARY: form pos 1,c 8,x 1,b 3,2*c 8,c 20,c 8,c 5,cr 3
25526 F_LETTERS: form pos 32,x 40,n 3,n 3,pos 78,c 8,x 800,c 3,n 3,x 30,x 360,x 84,n 8,c 3,x 104,c 8,pos 1610,c 3,n 3
25528 F_ACTIVE: form c 8,bh 4,bh 4,c 28,c 20,c 8,pos 74,bh 2,2*bh 4,2*bh 4.2
25530 def fnbad_debtor_doc_req(fileno$,pcode$,pedi_cmt$,user;pdate,ptime$)
25535 ! dim ad_dc(1),ad_dc$(1)*3,ad_dd$(1)*8,ad_dcom$(1)*20,ad_dqueue$(1)*8,ad_drec(1)
25540   if not setup_sql then gosub SETUP_SQL
25545   if days(pdate)=0 then let pdate=date("CYMD")
25550   if h_diary=0 then !:
          let h_diary=fnindex_handle("Name=I:Diary.int,KFName=I:Diary.fil","OutIn")
25555   if h_active_all=0 then !:
          let h_active_all=fnopen_master(mat active_handles)
25560   if h_letters=0 then !:
          let h_letters=fnindex_handle("Name=I:letters,KFName=I:letters.Y")
25565   if h_master_all=0 then !:
          let h_master_all=fnopen_master(mat master_handles)
25570   read #h_letters,using F_LETTERS,key=uprc$(rpad$(pcode$,kln(h_letters)))(1:kln(h_letters)),release: dc0de,dspan,dcode1$,scode$,sspan,wpcode,par_ver$,queue$,scode2$,sspan2 nokey L25675
25575   let ddate$=date$(days(date)+dspan) !:
        let sdate$=date$(days(date)+sspan) !:
        let sdate$=date$(days(date)+sspan2)
25580   if trim$(scode$)<>"" then 
25585     rewrite #h_master_all,using F_MASTER_STATUS,key=fileno$: sdate$,scode$ nokey L25590
25590 L25590: end if 
25595   if trim$(scode2$)<>"" then 
25600     rewrite #h_master_all,using F_MASTER_STATUS2,key=fileno$: sdate2$,scode2$ nokey L25605
25605 L25605: end if 
25610   if trim$(dcom$)="" then let dcom$="Added via "&pcode$
25615   if dc0de<>0 then 
25620     read #h_master_all,using master_formc$,key=fileno$,release: master_data$ nokey X_BAD_DEBTOR_DOC_REQ
25621     reread #h_master_all,using master_formn$,release: mat master_data
25630     let venue=master_data(master_venue1_no) !:
          let sher=master_data(master_sher_no)
25635     let forw=master_data(master_forw_no) !:
          let masco=master_data(master_coco_no)
25640     let atty_no=master_data(master_atty) !:
          let para_no=master_data(master_para)
25645     let collector_no=master_data(master_collector) !:
          let sales_no=master_data(master_sales_no) !:
          let priority$=master_data$(master_c_priority)
25650     if not fndiary_exists_(fileno$,dc0de,date$(days(fndate10_(ddate$)),"CYMD"),dcom$,fnqueue$(queue$,venue,sher,forw,masco,atty_no,para_no,collector_no,sales_no),"@@:@@",priority$) then 
25655       let fn_diary_add_var('bad_debtor_doc_req',h_diary,fileno$,dc0de,lpad$(rtrm$(str$(dc0de)),8),date$(days(fndate10_(ddate$)),"CYMD"),dcom$,fnqueue$(queue$,venue,sher,forw,masco,atty_no,para_no,collector_no,sales_no),"@@:@@",priority$)
25660     end if  ! not fndiary_exists_(fileno$,dc0de,date$(days(fndate10_(ddate$)),"CYMD"),dcom$,fnqueue$(queue$,venue,sher,forw,masco,atty_no,para_no,collector_no,sales_no),"@@:@@",priority$)
25665   end if 
25670   let dcom$=""
25675 L25675: write #h_active_all,using F_ACTIVE: fileno$,pdate,fnstime_(time$),pedi_cmt$,"",pcode$(1:8),user,0,lrec(h_active)+1,0,0
25680   let pcode$="    ''  " !:
        if len(trim$(pedi_cmt$))>28 then let fnpaper_$(pedi_cmt$(29:9999),pcode$)
25685 X_BAD_DEBTOR_DOC_REQ: !:
      fnend 
25690 ! ---------LIBRARY----------FNGET_SCREEN()---------------------------
25695 def library fnget_screen(screen_dat$,mat getscreen_input$,mat getscreen_print$,mat getscreen_help$,mat getscreen_fields$,mat getscreen_fields,mat getscreen_name$)
25700   dim buff$*32767,buff1$*10000,getscreen_input$(1)*4096,getscreen_print$(1)*4096,getscreen_help$(1)*4096,getscreen_fields$(1)*4096,getscreen_fields(1),getscreen_name$(1)*80,ext_buff$*32767
25705   mat getscreen_input$(1)=("") !:
        mat getscreen_print$(1)=("") !:
        mat getscreen_help$(1)=("") !:
        mat getscreen_fields$(1)=("") !:
        mat getscreen_fields$(1)=("") !:
        mat getscreen_fields(1)=(0) !:
        mat getscreen_name$(1)=("")
25710   gosub GET_SCREEN
25715 fnend 
25720 GET_SCREEN: ! r:
25721 let supdata=fngetdisplay_(screen_dat$) !:
      if supdata=0 then let fnmessagebox_(file_type$&" Screen Data is Damaged\n[Line 36000 in CLSUTIL]",16,"Screen Data Damaged") !:
        pause  !:
        stop 
25725 let st_scr=0 !:
      let scr=0
25730 L25730: linput #supdata: buff$ eof L25770
25735 if trim$(buff$)="||DONE:" then goto DONE_SUP
25740 if st_scr=0 and trim$(buff$(1:8))<>"||SCREEN" then goto L25730 else let st_scr=1
25745 if trim$(buff$(1:8))="||SCREEN" then gosub NEW_SCREEN !:
        goto L25730
25750 if trim$(buff$(1:10))="||FIELDSI:" then !:
        let fngetscreen(getscreen_input$(screen_num)) !:
        goto L25730
25755 if trim$(buff$(1:10))="||FIELDSP:" then !:
        let fngetscreen(getscreen_print$(screen_num)) !:
        goto L25730
25760 if trim$(buff$(1:7))="||HELP:" then !:
        let fngetscreen(getscreen_help$(screen_num)) !:
        goto L25730
25765 if trim$(buff$(1:9))="||FIELDS:" then !:
        let fngetscreen(getscreen_fields$(screen_num)) !:
        goto L25730
25770 L25770: print "PROBLEM:";buff$ !:
      pause 
25775 DONE_SUP: close #supdata: !:
      return  ! /r DONE Getting Screen Info
25780 NEW_SCREEN: ! r: Get Next Screen Info
25785 let screen_num=val(buff$(9:10)) !:
      let xpos1=pos(buff$,":") !:
      let xpos2=pos(buff$,"-") !:
      let num_fields=val(buff$(xpos1+1:xpos2-1))
25790 if scr<screen_num then !:
        mat getscreen_input$(screen_num) !:
        mat getscreen_print$(screen_num) !:
        mat getscreen_help$(screen_num) !:
        mat getscreen_fields$(screen_num) !:
        mat getscreen_fields(screen_num) !:
        mat getscreen_name$(screen_num) !:
        let scr=screen_num
25795 let fn_tab_input(mat getscreen_input$)
25800 let getscreen_name$(screen_num)=buff$(xpos2+1:99) !:
      let getscreen_fields(screen_num)=num_fields
25805 return ! /r
25810 def fngetscreen(&section$)
25815   linput #supdata: buff$ !:
        let section$=trim$(buff$)
25820 fnend 
25830 def fnc(field$)
25832   let nfield=srch(mat master_fieldsc$,field$)
25834   if nfield>0 then let fnc=nfield
25836 fnend 
25838 def fnn(field$)
25840   let nfield=srch(mat master_fieldsn$,field$)
25842   if nfield>0 then let fnn=nfield
25844 fnend 
25850 ! Additional INI file functions
25852 def library fnini_delete_section(ini_section_name$*256)
25854   let fn_ini_delete_section(ini_section_name$)
25856 fnend 
25858 def fn_ini_delete_section(ini_section_name$*256;___,deletestart,deleteend)
25860   let ini_section_name$=trim$(trim$(ini_section_name$,"["),"]")
25862   let deletestart = fn_srch_case_insensitive(mat ini_section$, ini_section_name$) : let deleteend = deletestart
25864   if deletestart > 0 then 
25866     do : let deleteend += 1 : loop until deleteend > udim(ini_section$) or uprc$(ini_section$(deleteend)) <> uprc$(ini_section_name$)
25868     let deleteend -= 1
25870     if deleteend < udim(ini_section$) then !:
            mat ini_section$(deletestart:deletestart-1+(udim(ini_section$)-deleteend)) = ini_section$(deleteend + 1:udim(ini_section$)) !:
            mat ini_field$(deletestart:deletestart-1+(udim(ini_field$)-deleteend)) = ini_field$(deleteend + 1:udim(ini_field$)) !:
            mat ini_value$(deletestart:deletestart-1+(udim(ini_value$)-deleteend)) = ini_value$(deleteend + 1:udim(ini_value$))
25872     mat ini_section$(udim(ini_section$)-1-(deleteend-deletestart)) !:
          mat ini_field$(udim(ini_field$)-1-(deleteend-deletestart)) !:
          mat ini_value$(udim(ini_value$)-1-(deleteend-deletestart))
25874 ! Recalc and set Ii_Line$ and Ii_Section$
25876     let deletestart = fn_srch_case_insensitive(mat ii_line$, "["&ini_section_name$&"]") : let deleteend = deletestart
25878     do : let deleteend += 1 : loop until deleteend > udim(ii_line$) or ii_line$(deleteend)(1:1) = "["
25880     let deleteend -= 1
25882     if deleteend < udim(ii_line$) then !:
            mat ii_line$(deletestart:deletestart-1+(udim(ii_line$)-deleteend)) = ii_line$(deleteend+1:udim(ii_line$)) !:
            mat ii_section$(deletestart:deletestart-1+(udim(ii_section$)-deleteend)) = ii_section$(deleteend+1:udim(ii_section$))
25884     mat ii_line$(udim(ii_line$)-1-(deleteend-deletestart)) !:
          mat ii_section$(udim(ii_section$)-1-(deleteend-deletestart))
25886   end if 
25888 fnend 
25890 def library fnini_read_section(ini_section_name$*256,mat section_field$,mat section_value$)
25892   let fn_ini_read_section(ini_section_name$,mat section_field$,mat section_value$)
25894 fnend 
25896 def fn_ini_read_section(ini_section_name$*256,mat section_field$,mat section_value$;___,sectionstart,sectionend,itemindex,startchar$,inifield$,keypos)
25898   let ini_section_name$ = trim$(trim$(ini_section_name$, "["), "]")
25900   let sectionstart = fn_srch_case_insensitive(mat ii_line$, "["&ini_section_name$&"]") : let sectionend = sectionstart
25902   do : let sectionend += 1 : loop until sectionend > udim(ii_line$) or ii_line$(sectionend)(1:1) = "["
25904   let sectionend -= 1
25906   if sectionstart > 0 then 
25908     mat section_field$(1) : mat section_value$(1)
25910     mat section_field$(sectionend - sectionstart) : mat section_value$(sectionend - sectionstart)
25912     for itemindex = sectionstart + 1 to sectionend
25914       let startchar$ = ii_line$(itemindex)(1:1)
25915       let _pos_delim=pos(ii_line$(itemindex),"=") !:
            if _pos_delim<=0 then let _pos_delim=pos(ii_line$(itemindex),tab$)
25916       if startchar$ = "!" or startchar$ = ";" or startchar$ = "#" or _pos_delim = 0 then 
25918         let section_field$(itemindex - sectionstart) = "" : let section_value$(itemindex - sectionstart) = ii_line$(itemindex)
25920       else 
25922         let section_field$(itemindex - sectionstart) = trim$(trim$(trim$(trim$(ii_line$(itemindex)(1:_pos_delim-1)),tab$),'"'),tab$)
25924         let section_value$(itemindex - sectionstart) = fn_ini_read$(ini_section_name$, section_field$(itemindex - sectionstart))
25926       end if 
25928     next itemindex
25930   else 
25932     mat section_field$(0) : mat section_value$(0)
25934   end if 
25936 ! if Udim(Section_Field$) = 1 THEN PAUSE
25938 fnend 
25940 def library fnini_set_line(ini_section_name$*256, ini_line$*1024)
25942   let fn_ini_set(ini_section_name$, "", ini_line$)
25944 fnend 
25946 def library fnini_section_names(mat section_name$)
25948   let fn_ini_section_names(mat section_name$)
25950 fnend 
25952 def fn_ini_section_names(mat section_name$)
25954   mat section_name$(0)
25956   for lineindex = 1 to udim(ii_line$)
25958     if ii_line$(lineindex)(1:1) = "[" then !:
            mat section_name$(udim(section_name$) + 1) !:
            let section_name$(udim(section_name$)) = trim$(trim$(ii_line$(lineindex),"["),"]")
25960   next lineindex
25962 fnend 
26105 def library fnini_sections(mat ini_sections$)
26110   let fnini_sections=fn_ini_sections(mat ini_sections$)
26115 fnend 
26120 def fn_ini_sections(mat ini_sections$)
26125   mat ini_sections$(udim(ini_section$))=("") : let _sections=0
26130   for _ini_section=1 to udim(ini_section$)
26135     let _section=srch(mat ini_sections$,ini_section$(_ini_section))
26140     if _section<=0 then !:
            let _sections+=1 !:
            let ini_sections$(_sections)=ini_section$(_ini_section)
26145   next _ini_section
26150   mat ini_sections$(_sections)
26155   let fn_ini_sections=udim(ini_sections$)
26160 fnend 
26170 def library fnini_save
26172   let fnini_save=fn_ini_save
26174 fnend  ! fnINI_SAVE
26180 def fn_ini_save
26185 !  uses (built by FN_INI_OPEN): mat II_LINE$, mat INI_SECTION$, mat INI_FIELD$, mat INI_VALUE$, Tab$, INI_FILE$
26190 !  uses (functions) : fnGetHandle
26195   dim inir_line$*2048
26200   dim inir_field$*256,inir_value$*1024
26205   dim inir_section$*1024
26210   dim inir_temp_file$*1024
26215   open #inir_temp_handle:=fngethandle_: "Name="&env$("Temp")&"\inir-"&session$&".ini,RecL=2048,Replace",display,output 
26220   let inir_temp_file$=file$(inir_temp_handle)
26225   if ini_file$="" then 
26230     if lwrc$(env$("Debug"))="yes" then print "INI_File$ is empty.  FN_INI_SAVE will abort.  You must specifying a file via FN_INI_OPEN, before calling this function."
26235     if lwrc$(env$("Developer"))="yes" then pause 
26240     goto XIT_FN_INI_SAVE
26245   end if  ! INI_File$=""
26250   for ii_item=1 to udim(mat ii_line$)
26255     if ii_line$(ii_item)(1:1)='[' then 
26260       let inir_section$=uprc$(trim$(trim$(trim$(ii_line$(ii_item)),"["),"]"))
26265       let inir_line$=ii_line$(ii_item)
26270       gosub INIR_WRITE
26275     else if ii_line$(ii_item)(1:1)='!' or ii_line$(ii_item)(1:1)=';' or ii_line$(ii_item)(1:1)='#' or trim$(ii_line$(ii_item))="" then 
26280       let inir_line$=ii_line$(ii_item)
26285       gosub INIR_WRITE
26290     else 
26295       let fn_add_one$(mat ini_section$,ii_section$)
26300       let ii_pos_equal=pos(ii_line$(ii_item),"=")
26305       if ii_pos_equal=-1 then let ii_pos_equal=pos(ii_line$(ii_item),tab$) ! if no equals sign than use a tab instead
26310       let inir_field$=trim$(trim$(trim$(trim$(ii_line$(ii_item)(1:ii_pos_equal-1),tab$),'"')),tab$)
26315       let inir_value$=fn_ini_read$(inir_section$,inir_field$)
26320       if inir_value$='' then let inir_value$=""
26325       let inir_line$=ii_line$(ii_item)(1:ii_pos_equal)&' '&inir_value$
26330       gosub INIR_WRITE
26335       let fn_add_one$(mat ini_value$,ii_value$)
26340     end if  ! II_Line$(II_Item)(1:1)=     '['     /  '!'...   /     else 
26345   next ii_item
26350   close #inir_temp_handle: 
26355   execute "*Free "&ini_file$ ioerr ignore
26360   execute "*Copy "&inir_temp_file$&" "&ini_file$ ioerr ignore
26365   goto XIT_FN_INI_SAVE
26370 ! 
26375 INIR_WRITE: ! 
26380   print #inir_temp_handle: inir_line$
26385 !   PRINT INIR_LINE$ : PAUSE
26390   return 
26395 XIT_FN_INI_SAVE: ! 
26400 fnend 
26410 def library fnini_open(ii_file$*256) ! ,MAT INI_SECTION$, mat INI_FIELD$, mat INI_VALUE$)
26412   gosub SETUP_CONSTANTS
26414   let fnini_open=fn_ini_open(ii_file$)
26416 fnend  ! fnINI_OPEN
26420 def fn_ini_open(ii_file$*256) ! ,MAT INI_SECTION$, mat INI_FIELD$, mat INI_VALUE$)
26425   if ~setup_fn_ini_open then 
26430 !    library "CLSUtil/Library":FNASCI, fn_add_one$, fnGetHandle
26435     dim ii_line$(1)*2048,ii_section$(1)*1024,ii_section$*1024,ii_value$*1024,ini_file$*256,ini_field$*256
26440     dim ini_section$(1)*1024, ini_field$(1)*256, ini_value$(1)*1024
26445     let setup_fn_ini_open=1
26450   end if  ! ~Setup_FN_INI_OPEN
26455   let ini_file$=trim$(ii_file$)
26460   let ini_field_len_longest=0
26465   let fnasci_(ini_file$,mat ii_line$)
26470   if udim(mat ii_line$)=1 and ii_line$(1)="" then mat ii_line$(0)
26475   mat ii_section$(udim(ii_line$))=("")
26480   mat ini_section$(0) : mat ini_field$(0) : mat ini_value$(0)
26481   let ii_section$=""
26485   for ii_item=1 to udim(mat ii_line$)
26490     if ii_line$(ii_item)(1:1)='[' then 
26495       let ii_line$(ii_item)=trim$(ii_line$(ii_item))
26500       let ii_section$=uprc$(trim$(trim$(trim$(ii_line$(ii_item)),"["),"]"))
26505       let ii_section$(ii_item)=ii_section$
26510     else if ii_line$(ii_item)(1:1)='!' or ii_line$(ii_item)(1:1)=';' or ii_line$(ii_item)(1:1)='#' then 
26515       let ii_section$(ii_item)=ii_section$
26520     else 
26525       let ii_section$(ii_item)=ii_section$
26530       let fn_add_one$(mat ini_section$,ii_section$)
26535       let ii_pos_equal=pos(ii_line$(ii_item),"=")
26540       if ii_pos_equal=-1 then let ii_pos_equal=pos(ii_line$(ii_item),tab$) ! if no equals sign than use a tab instead
26545       let ini_field$=trim$(trim$(trim$(trim$(ii_line$(ii_item)(1:ii_pos_equal-1),tab$),'"')),tab$)
26550       let fn_add_one$(mat ini_field$,ini_field$)
26555       let ini_field_len_longest=max(ini_field_len_longest,ii_pos_equal-2) !:
            ! Ini_Field_Len_Longest is 1 shorter than the field label (We expext a minimum of 1 space before the =!:
            ! if not, later when we rpad & rewrite, we will add the space.
26560       let ii_value$=trim$(trim$(ii_line$(ii_item)(ii_pos_equal+1:len(ii_line$(ii_item)))),tab$)
26565       if lwrc$(ii_value$)="blank" then let ii_value$=''
26570       let fn_add_one$(mat ini_value$,ii_value$)
26575     end if  ! II_Line$(II_Item)(1:1)=     '['     /  '!'   /     else 
26580   next ii_item
26585 fnend 
26590 !
26592 def library fnini_read$*1024(il_section$*300,il_field$*300) ! shares mat INI_Section$, mat INI_Field$, mat INI_Value$ with FN_INI_OPEN
26594   gosub SETUP_CONSTANTS
26596   let fnini_read$=fn_ini_read$(il_section$,il_field$)
26598 fnend  ! fnINI_READ$
26600 def fn_ini_read$*1024(il_section$*300,il_field$*300) ! shares mat INI_Section$, mat INI_Field$, mat INI_Value$ with FN_INI_OPEN
26605   dim set_fn_ini_read$*2048
26610   let set_fn_ini_read$=""
26615   let il_field$=trim$(il_field$)
26620   if il_field$="" then let il_field$='blank'
26625   let il_section$=trim$(trim$(uprc$(il_section$),"]"),"[")
26630   let il_section_first=fn_srch_case_insensitive(mat ini_section$, il_section$)
26635   if il_section_first>0 then 
26640     let match=fn_srch_case_insensitive(mat ini_field$,il_field$,il_section_first)
26645     if match>0 then 
26650       if ini_section$(match)=il_section$ then 
26655         let set_fn_ini_read$=trim$(ini_value$(match),tab$)
26660       end if  ! INI_Section$(Match)=IL_Section$
26665     else 
26670 !     let set_fn_ini_read$=il_field$
26675       let set_fn_ini_read$=""
26680 !      if Developer THEN PRINT 'SET_FN_INI_READ$ not found.' : PAUSE  ! XXX
26685     end if  ! Match>0   /   else 
26690   else 
26695     let il_field$=""
26700 !   if debug then print 'no such section ('&il_section$&')'
26705 !    if Developer THEN PAUSE
26710   end if  ! IL_Section_First>0   /   else 
26715   let fn_ini_read$=set_fn_ini_read$
26720 fnend 
26730 def library fnini_set(inis_section$*256,inis_field$*256,inis_value$*1024)
26732   let fnini_set=fn_ini_set(inis_section$,inis_field$,inis_value$)
26734 fnend  ! fnINI_Set
26740 def fn_ini_set(inis_section$*256,inis_field$*256,inis_value$*1024)
26745 ! shares mat INI_Section$, mat INI_Field$, mat INI_Value$, mat II_Section$, INI_Field_Len_Longest with FN_INI_OPEN
26750   let inis_field$=trim$(inis_field$)
26755   if inis_field$="" then let inis_field$=''
26760   let inis_section$=trim$(trim$(inis_section$,"]"),"[")
26765   let inis_section_first=fn_srch_case_insensitive(mat ii_section$, inis_section$) : let inis_field_item = 0
26770   if inis_section_first>0 then 
26775     do : let inis_field_item=fn_srch_case_insensitive(mat ini_field$,inis_field$,inis_field_item+1) : loop until inis_field_item = 0 or ini_section$(inis_field_item)=uprc$(inis_section$)
26780     if inis_field_item>0 and ini_section$(inis_field_item)=uprc$(inis_section$) then 
26785 ! if Ini_Section$(Inis_Field_Item)=Uprc$(Inis_Section$) THEN
26790       let ini_value$(inis_field_item)=inis_value$
26795 ! end if  ! INI_Section$(INIS_Field_Item)=INIS_Section$
26800     else 
26805 !     pr ' ** need a new field (existing section) **' : pr 'Section='&INIS_SECTION$ : pr '  Field='&INIS_FIELD$ : pr '  Value='&INIS_Value$ : pr 'now go add it!!!' : pause ! insert into mat II_Section$, mat II_Line$, mat INI_Section$, mat INI_Field$, mat INI_Value$
26810       let insert_item_number=inis_section_first
26815       do  ! set Insert_Item_Number to be the last of each section
26820         let insert_item_number+=1
26825       loop until insert_item_number>udim(ii_line$) or uprc$(inis_section$)<>uprc$(ii_section$(insert_item_number))
26830       let insert_kv_number = 1
26835       for ini_line_index = 1 to insert_item_number - 1
26840         let ini_line_start$ = ii_line$(ini_line_index)(1:1) : if ini_line_start$ <> "[" and ini_line_start$ <> ";" and ini_line_start$ <> "!" and ini_line_start$ <> "#" then let insert_kv_number+=1
26845       next ini_line_index
26850       let ini_field_len_longest=max(ini_field_len_longest,len(inis_field$))
26855       let fn_array_item_insert$(mat ii_section$,inis_section$,insert_item_number)
26860       if inis_field$ <> "" then !:
              let fn_array_item_insert$(mat ii_line$,rpad$(inis_field$,ini_field_len_longest)&" = "&inis_value$,insert_item_number) !:
            else !:
              let fn_array_item_insert$(mat ii_line$,inis_value$,insert_item_number)
26865 ! MSGBOX(Str$(Insert_KV_Number)&"/"&Str$(UDim(Ini_Section$))&" , "&Str$(Insert_Item_Number)&"/"&Str$(UDim(Ii_Section$)))
26870       if inis_field$ <> "" then let fn_array_item_insert$(mat ini_section$,uprc$(inis_section$),insert_kv_number)
26875       if inis_field$ <> "" then let fn_array_item_insert$(mat ini_field$,inis_field$,insert_kv_number)
26880       if inis_field$ <> "" then let fn_array_item_insert$(mat ini_value$,inis_value$,insert_kv_number)
26885     end if  ! INIS_Field_Item>0   /   else 
26890   else 
26895 !      pr ' ** need a new section and a new field in it **' : pr 'Section='&INIS_SECTION$ : pr '  Field='&INIS_FIELD$ : pr '  Value='&INIS_Value$ ! insert into mat II_Section$, mat II_Line$, mat INI_Section$, mat INI_Field$, mat INI_Value$
26900     let ini_field_len_longest=max(ini_field_len_longest,len(inis_field$))
26905     let fn_add_one$(mat ii_section$,inis_section$)
26910     let fn_add_one$(mat ii_section$,inis_section$)
26915     let fn_add_one$(mat ii_line$,"["&inis_section$&"]")
26920     if inis_field$ <> "" then !:
            let fn_add_one$(mat ii_line$,rpad$(inis_field$,ini_field_len_longest)&" = "&inis_value$) !:
          else !:
            let fn_add_one$(mat ii_line$,inis_value$)
26925     if inis_field$ <> "" then let fn_add_one$(mat ini_section$,uprc$(inis_section$))
26930     if inis_field$ <> "" then let fn_add_one$(mat ini_field$,inis_field$)
26935     if inis_field$ <> "" then let fn_add_one$(mat ini_value$,inis_value$)
26940   end if  ! INIS_Section_First>0   /   else 
26945 fnend 
26950 def library fnarray_item_insert$(mat array$, insert_item$*1024, insert_item_number)
26952   let fnarray_item_insert$=fn_array_item_insert$(mat array$, insert_item$, insert_item_number)
26954 fnend  ! fnARRAY_ITEM_INSERT$
26960 def fn_array_item_insert$(mat array$, insert_item$*1024, insert_item_number)
26962   let array_item_count=udim(mat array$)
26964   if insert_item_number>array_item_count then 
26966     mat array$(insert_item_number)
26968     let array$(insert_item_number)=insert_item$
26970   else 
26972     let array_item_count+=1
26974     mat array$(array_item_count)
26976     mat array$(insert_item_number+1:array_item_count)=array$(insert_item_number:array_item_count-1)
26978     let array$(insert_item_number)=insert_item$
26980   end if  ! Insert_Item_Number>Array_Item_Count   /   else 
26982 fnend 
26990 def library fnarray_item_insert(mat array, insert_item, insert_item_number)
26992   let fnarray_item_insert=fn_array_item_insert(mat array, insert_item, insert_item_number)
26994 fnend  ! fnARRAY_ITEM_INSERT
27000 def fn_array_item_insert(mat array, insert_item, insert_item_number)
27002   let array_item_count=udim(mat array)
27004   if insert_item_number>array_item_count then 
27006     mat array(insert_item_number)
27008     let array(insert_item_number)=insert_item
27010   else 
27012     let array_item_count+=1
27014     mat array(array_item_count)
27016     mat array(insert_item_number+1:array_item_count)=array(insert_item_number:array_item_count-1)
27018     let array(insert_item_number)=insert_item
27020   end if  ! Insert_Item_Number>Array_Item_Count   /   else 
27022 fnend 
27030 def library fnclose_free(close_handle)
27035   dim close_file$*256, close_handle
27040   let close_file$=file$(close_handle)
27045   let close_check=0
27050   close #close_handle,free: error FNCLOSE_FREE_ERROR
27055   do while close_check+=1 < 10 and exists(close_file$)
27060     execute "FREE "&close_file$ error FNCLOSE_ERROR2
27065   loop 
27070   if ~exists(close_file$) then let fnclose_free=1
27075   goto XIT_FNCLOSE_FREE
27080 FNCLOSE_FREE_ERROR: ! 
27085   print bell;" ";: let sleep(1): continue 
27090 FNCLOSE_ERROR2: ! 
27095   print bell; " ";: let sleep(while_close_check) : continue 
27100 XIT_FNCLOSE_FREE: ! 
27105 fnend 
27110 def library fnshutdown
27120   if uprc$(env$("CLIENT_SERVER"))="YES" then 
27130     if env$("FREE_CS")="" then !:
            let setenv("FREE_CS","Yes") !:
            execute "*Free *[SESSION].*" error ignore
27140     if env$("FREE_CS_TEMP")="" then !:
            let setenv("FREE_CS_TEMP","Yes") !:
            execute "*Free [TEMP]\*.*" error ignore !:
            ! Clean TEMP for all sessions!
27150   end if  ! Uprc$(Env$("CLIENT_SERVER"))="YES" THEN
27160   if env$("FREE_CLIENT_TEMP")="" then !:
          execute "*SYS -c -M DEL %TEMP%\*"&session$&".*" !:
          let setenv("FREE_CLIENT_TEMP","Yes") ! -c -M
27199 fnend 

27200   def fnparse_name_$(name$*80,type,mat results$)
27202 ! NAME = DEBTOR NAME !:
          ! TYPE 1= LAST/FIRST !:
          !      2= FIRST LAST !:
          !      3= LAST FIRST (No Delimiter Todo: Can we auto fix ",")!:
          ! mat results$ !:
          ! (1)=Prefix !:
          ! (2)=First !:
          ! (3)=Middle !:
          ! (4)=LAST Name !:
          ! (5)=Suffix
27204     mat results$(5)=("")
27210     on type goto LAST_FIRST,FIRST_LAST,LAST_SPACE_FIRST
27212 LAST_FIRST: let buff1$=name$ !:
          goto PARSE_NAME
27214 FIRST_LAST: let buff1$=fnflip_$(name$,30) !:
          goto PARSE_NAME
27220 LAST_SPACE_FIRST: ! Parse Name Assuming that Last Name is First!
27225     if ~parse_setup then let fnparse_setup
27230     let first_slash=pos(name$,"/")
27235     if first_slash>0 then !:
            let type=1 !:
            goto LAST_FIRST
27240     let first_space=pos(name$&" "," ") !:
          let first_comma=pos(name$,",") !:
          let last_space=pos(rtrm$(name$)," ",-1) !:
          let last_comma=pos(rtrm$(name$),",",-1)
27241     if last_space>0 and uprc$(trim$(srep$(name$(last_space+1:999),".","")))="INC" then !:
            let name$=name$&"/" !:
            let type=1 !:
            goto LAST_FIRST
27242     if last_comma>0 and uprc$(trim$(srep$(name$(last_comma+1:999),".","")))="INC" then !:
            let name$=name$&"/" !:
            let type=1 !:
            goto LAST_FIRST
27250     for _generation=1 to nparse_generation
27255       let first_generation=pos(uprc$(name$)&" ",uprc$(parse_generation$(_generation))&" ")
27260       let first_generation_period=pos(uprc$(name$),uprc$(parse_generation$(_generation))&".")
27265       if first_generation>0 then 
27270         let next_space=pos(name$&" "," ",first_generation)
27275         let name$(next_space:next_space)="/" !:
              let type=1 !:
              goto LAST_FIRST
27280       else if first_generation_period>0 then 
27285         let next_period=pos(name$&".",".",first_generation_period)
27290         let name$(next_period:next_period)="/" !:
              let type=1 !:
              goto LAST_FIRST
27295       end if  ! First_Generation>0
27300     next _generation
27301     if first_comma>0 and first_comma<first_space then !:
            let name$(first_comma:first_comma)="/" !:
            let type=1 !:
            goto LAST_FIRST
27305     let is_compound=srch(mat parse_compound$,uprc$(trim$(name$(1:first_space))))
27310     if is_compound>0 then !:
            let first_space=pos(name$&" "," ",first_space+1)
27315     let name$(first_space:first_space)="/" !:
          let type=1 !:
          goto LAST_FIRST
27330 PARSE_NAME: let sal_len=len(rtrm$(buff1$)) !:
          let salut=val(buff1$(sal_len:sal_len)) conv L27345
27335     if salut then let buff1$(sal_len:sal_len)=""
27340     if salut=1 then let results$(1)="Mr" !:
          else if salut=2 then let results$(1)="Mrs" !:
          else if salut=3 then let results$(1)="Ms" !:
          else if salut=4 then let results$(1)="Mr & Mrs" !:
          else if salut=5 then let results$(1)="Dr" !:
          else if salut=6 then let results$(1)="Capt"
27345 L27345: let last=pos(buff1$,"/") !:
      if last<=0 then let last=len(buff1$)+1
27350 let results$(4)=trim$(buff1$(1:last-1)) !:
      let results$(2)=trim$(buff1$(last+1:999))
27355 let middle_pos=pos(results$(2)," ",-1)
27360 if middle_pos>0 then !:
        let results$(3)=trim$(results$(2)(middle_pos:999)) !:
        let results$(2)=trim$(results$(2)(1:middle_pos))
27365 if ~parse_setup then let fnparse_setup
27370 let tgen$=rtrm$(results$(4)) !:
      let suffix_pos=pos(tgen$," ",-1) !:
      if suffix_pos<=0 then goto L27410
27375 let tgen$=uprc$(srep$(tgen$,".",""))
27380 for ngen=1 to udim(parse_generation$)
27385   if uprc$(trim$(tgen$(suffix_pos:999)))=uprc$(parse_generation$(ngen)) then !:
          let results$(5)=trim$(results$(4)(suffix_pos:999)) !:
          let results$(4)=trim$(results$(4)(1:suffix_pos)) !:
          let ngen=999
27390 next ngen
27410 L27410: fnend 
27420 def library fnflip$*40(flip$*40;salut_pos)
27422   let fnflip$=fnflip_$(flip$,salut_pos)
27424 fnend 
27430 def fnflip_$*40(flip$*40;salut_pos)
27432   if ~parse_setup then let fnparse_setup
27434   if ~cls_setup then let fnclssetup
27436   if trim$(flip$)="" then goto L27508
27438   dim uflip$*40,generation$*20,compound$*20,salutation$*20,uflip_nogen$*40,tgen$*80
27440   let flip$=trim$(flip$) !:
        let lspace=pos(flip$," ",-1) !:
        if lspace>0 and trim$(srep$(srep$(uprc$(flip$(lspace:999)),".",""),",",""))="INC" then !:
          goto L27508 !:
          ! if the last word is "INC" then not a name
27442   let lspace=pos(uprc$(flip$),",",-1) !:
        if lspace>0 and trim$(srep$(srep$(uprc$(flip$(lspace:999)),".",""),",",""))="INC" then !:
          goto L27508 !:
          ! if the last word is ",INC" then not a name
27444   if pos(flip$,"/")>0 then !:
          goto L27508 !:
          ! if "/" is in name, don't touch, perhaps it is already flipped
27446   let flip$=" "&srep$(srep$(flip$,".",""),";","")&" " !:
        let uflip$=uprc$(flip$) !:
        if flip$=uflip$ then let uflip=1 else let uflip=0
27448 MOVE_GENERATIONAL: ! Move the Generational Info if needed
27450   for nmove=1 to nparse_generation
27452     let generation$=" "&trim$(parse_generation$(nmove))&" " !:
          let xpos=pos(uflip$,uprc$(generation$)) !:
          if xpos>0 then !:
            let flip$(999:0)=flip$(xpos+1:xpos+3) !:
            let flip$(xpos+1:xpos+3)="" !:
            let flip$=srep$(flip$,rtrm$(generation$)&generation$,generation$) !:
            let flip$=srep$(flip$,uprc$(rtrm$(generation$)&generation$),uprc$(generation$)) !:
            let uflip$=uprc$(flip$)
27454   next nmove
27456   if salut_pos=0 then let salut_pos=30
27458   let salu=0 !:
        if pos(" "&uflip$," MR ")>0 and pos(" "&uflip$," MRS")>0 then !:
          let salu=4 !:
          let flip$=srep$(flip$,"Mr & Mrs","") : let flip$=srep$(flip$,uprc$("MR & MRS")," ") !:
          let flip$=srep$(flip$," Mr "," ") : let flip$=srep$(flip$,uprc$(" MR ")," "): let flip$=srep$(flip$," Mrs "," ") : let flip$=srep$(flip$,uprc$(" MRS ")," ") : let uflip$=uprc$(flip$) !:
          goto L27472
27460   for nsalut=1 to 9
27462     let salutation$=" "&trim$(srep$(srep$(salut$(nsalut),".",""),":",""))&" "
27464     if trim$(salutation$)="" then goto L27470
27466     if pos(" "&uflip$," "&uprc$(salutation$))>0 then !:
            let salu=nsalut : let nsalut=99
27468     let flip$=srep$(flip$,salutation$," ") !:
          let flip$=srep$(flip$,uprc$(salutation$)," ") !:
          let uflip$=uprc$(flip$)
27470 L27470: next nsalut
27472 L27472: let flip$=trim$(flip$) !:
        let xspace=pos(flip$,"  ") !:
        if xspace>0 then let flip$=srep$(flip$,"  "," ") !:
          goto L27472
27474   let flip$=trim$(flip$) !:
        let uflip$=uflip_nogen$=uprc$(flip$)
27476   for nmove=1 to nparse_generation
27478     let generation$=" "&trim$(parse_generation$(nmove))&" " !:
          let uflip_nogen$(999:0)=" " !:
          let uflip_nogen$=srep$(uflip_nogen$,generation$," ") !:
          let uflip_nogen$=srep$(uflip_nogen$,uprc$(generation$)," ") !:
          let uflip_nogen$=rtrm$(uflip_nogen$)
27480   next nmove
27482   let lspace=pos(uflip_nogen$," ",-1)
27484 L27484: let lspace1=pos(uflip$(1:lspace-1)," ",-1) !:
        let lspace2=pos(uflip$(1:lspace1-1)," ",-1) !:
        if lspace1<=0 then goto L27502 !:
          ! No More Complex Names Found
27486   if uflip$(lspace1:lspace)=" LOS " and uflip$(lspace2:lspace1)=" DE " then !:
          let lspace=lspace2 !:
          goto L27484
27488   let is_compound=0 !:
        for nmove=1 to nparse_compound
27490     let compound$=" "&trim$(parse_compound$(nmove))&" "
27492     if uflip_nogen$(lspace1:lspace)=uprc$(compound$) then !:
            let is_compound=1: let nmove=99
27494   next nmove !:
        if is_compound then !:
          let lspace=lspace1 !:
          goto L27484
27496   if uflip$(lspace1:lspace)=" LAST " and trim$(uflip$(lspace:999))="NAME" then !:
          let lspace=lspace1 !:
          goto L27484
27498   if pos(uflip$(lspace1:lspace),"'")>0 and pos(uflip$(1:lspace1-1)," ")>=2 then !:
          let lspace=lspace1 !:
          goto L27484
27500   if len(trim$(uflip$(lspace:999)))=1 then let lspace=lspace1 !:
          goto L27484 !:
          ! if the Last Name is only 1 Char, then presume a two part last name
27502 L27502: let flip$=rpad$(trim$(flip$(lspace+1:999))&"/"&flip$(1:lspace-1),salut_pos)
27504   if salu>0 then let flip$(salut_pos:salut_pos)=str$(salu) !:
          let uflip$(salut_pos:salut_pos)=str$(salu)
27506   if uflip then let flip$=uprc$(flip$)
27508 L27508: let fnflip_$=flip$
27510 fnend 
27520 ! ---------LIBRARY----------FNPARSE_NAME$()----------------------------
27522 def library fnparse_name$(name$*80,type,mat results$)
27524   let fnparse_name$=fnparse_name_$(name$,type,mat results$)
27526 fnend 
27530 def library fnstates(mat setup_states$,mat setup_st$)
27532   if setup_states=0 then let fnsetup_states
27534   mat setup_states$(udim(states$))=states$ !:
        mat setup_st$(udim(st$))=st$
27536   let fnstates=udim(setup_states$)
27538   for _setup_states=1 to udim(setup_states$) !:
          let setup_states$(_setup_states)=fninitcap$(setup_states$(_setup_states))
27540   next _setup_states
27542 fnend 
27550 ! ---------LIBRARY----------FNASSIGN_CSZ$()----------------------------
27552 def library fnassign_csz(csz$*80,&city$;&state$,&zip$)
27554   mat csz$(3)=("") !:
        let csz$(1)=city$ !:
        let csz$(2)=state$ !:
        let csz$(3)=zip$
27556   let fnparse_csz_$(csz$,mat csz$)
27558 ! ON SOFLOW IGNORE
27560   let city$=csz$(1) !:
        let state$=csz$(2) !:
        let zip$=csz$(3)
27562 fnend 
27570 ! ---------LIBRARY----------FNPARSE_CSZ$()----------------------------
27572 def library fnparse_csz$(csz$*80,mat results$)
27574   let fnparse_csz$=fnparse_csz_$(csz$,mat results$)
27576 fnend 
27580 dim last_state$*40,last_st$*40
27582 def fnparse_csz_$(csz$*80,mat results$)
27584 ! CSZ = City State &/Or Zip                                                   ! mat results$ !:
        ! (1)=City !:
        ! (2)=State !:
        ! (3)=Zip
27586   mat results$(3)=("") : let state=0
27588   if setup_states=0 then let fnsetup_states
27590   let csz$=srep$(csz$,"."," ") !:
        let csz$=srep$(csz$,","," ")
27592   let csz$=srep$(csz$,"    "," ") !:
        let csz$=srep$(csz$,"   "," ") !:
        let csz$=srep$(csz$,"  "," ") !:
        let csz$=trim$(csz$)
27594   if trim$(csz$)="" then goto XIT_SEARCH_STATES
27596 GET_ZIP: let zpos=pos(csz$," ",-1) !:
        let tzip$=csz$(zpos:999)
27598   let tzip=val(srep$(tzip$,"-","")) conv L27602
27600   if tzip>0 then let results$(3)=trim$(tzip$) !:
          let csz$(zpos:999)=""
27602 L27602: let results$(1)=trim$(csz$): let uresults$(1)=uprc$(results$(1)) !:
        if uresults$(1)="WASHINGTON" and trim$(results$(2))="" then !:
          goto L27644 !:
          ! ** When Only the word WASHINGTON is passed, we will assume that it is the City, and not the STATE !:
          ! Washington, DC & Washington, NJ are both valid !:
          ! WA the state wil not be assumed
27604   if uresults$(1)(1:13)="WASHINGTON DC" then !:
          let results$(1)(11:99)="" !:
          let results$(2)="DC" !:
          goto L27644
27606   let state=state_pos=0 !:
        let ucsz$=uprc$(trim$(csz$)) !:
        if trim$(csz$)="" then goto XIT_SEARCH_STATES
27608   if trim$(last_state$)<>"" then 
27610     let tz=srch(mat states$,last_state$) !:
          let x1=pos(ucsz$," "&st$(tz),-1) !:
          let x2=pos(ucsz$,states$(tz),-1)
27612     if x1<=0 and x2<=0 then goto SEARCH_STATES
27614     if x2>0 and ucsz$(x2:99)=states$(tz) then !:
            let state_pos=x2: let state=tz !:
            let tz=99 !:
            goto XIT_SEARCH_STATES
27616     if x1>0 and ucsz$(x1+1:99)=st$(tz) then !:
            let state_pos=x1+1: let state=tz !:
            let tz=99 !:
            goto XIT_SEARCH_STATES
27618   end if 
27620 SEARCH_STATES: for tz=1 to udim(states$)
27622     if state<>0 then goto LOOP_SEARCH_STATES
27624     let x1=pos(ucsz$," "&st$(tz),-1) !:
          let x2=pos(ucsz$,states$(tz),-1)
27626     if x1<=0 and x2<=0 then goto LOOP_SEARCH_STATES
27628     if x2>0 and ucsz$(x2:99)=states$(tz) then !:
            let state_pos=x2: let state=tz !:
            let last_state$=states$(tz) !:
            let last_st$=" "&st$(tz) !:
            let tz=99 !:
            goto LOOP_SEARCH_STATES
27630     if x1>0 and ucsz$(x1+1:99)=st$(tz) then !:
            let state_pos=x1+1: let state=tz !:
            let last_state$=states$(tz) !:
            let last_st$=" "&st$(tz) !:
            let tz=99 !:
            goto LOOP_SEARCH_STATES
27632 LOOP_SEARCH_STATES: next tz
27634 XIT_SEARCH_STATES: ! 
27636   let results$(1)=csz$
27638   if state>0 then !:
          let results$(1)=csz$(1:state_pos-1): let results$(2)=trim$(st$(state))
27640   let results$(1)=trim$(results$(1))
27642   if trim$(results$(2))="" and srch(mat st$,results$(1))>0 then !:
          let results$(2)=results$(1) !:
          let results$(1)=""
27644 L27644: fnend 
27650 def library fnget_st$*80(csz$*80)
27652   let fnparse_csz_$(csz$,mat csz_results$)
27654   let fnget_st$=csz_results$(2)
27656 fnend 
27658 def library fnget_zip$*80(csz$*80)
27660   let fnparse_csz_$(csz$,mat csz_results$)
27662   let fnget_zip$=csz_results$(3)
27664 fnend 
27666 def library fnget_city$*80(csz$*80)
27668   let fnparse_csz_$(csz$,mat csz_results$)
27670   let fnget_city$=csz_results$(1)
27672 fnend 
27680 def fnsetup_categ
27685   dim categ2$(99)*80,heading$(48)*80,categ2$*80,autostatus2$(99),finlstat$(1)*20
27690   mat categ$(udim(categ2$)) !:
        ! THIS WOULD BE BEST, BUT CAUSED GPF
27695   let categ_worked=setup_categ=1
27700 ! CATEG2$(1)-CATEG2$(99) Are No Longer Hard Coded!:
        ! Use CATEG.LST//9 To Modify the List !:
        ! Codes 33-80 Are Defined by 2-S-2 and "Heading//8"
27701   library "PSubCdLU/Library": fnpayment_subcode_desc$
27705   let _categ=fngetdisplay_("CATEG.LST//9")
27710   linput #_categ: mat categ2$
27715   close #_categ: 
27720   let _heading=fngetfile("HEADING/COMMON/5")
27725   if _heading<=0 then let fnmessagebox_("Warning COULD NOT OPEN FINANCIAL"&chr$(10)&"HEADING/COMMON/5"&chr$(10)&"Error:"&str$(err)&" Line:"&str$(line)&" - In CLSUTIL",16,"Error!") !:
          let categ_worked=0 !:
          goto SETUP_CATEG_10980
27730 F2: form 30*c 30
27735 F3: form 18*c 30
27740   read #_heading,using F2,rec=1,release: mat heading$(19:48) norec ignore
27745   read #_heading,using F3,rec=2,release: mat heading$(1:18) norec ignore
27750 ! 
27755   close #_heading: ioerr ignore
27760 SETUP_CATEG_10980: ! 
27765   for z=1 to 48: let categ2$(z+32)=ltrm$(heading$(z)(4:99)): next z
27770   for z=1 to udim(categ2$)
27775     let categ2$(z)=rpad$(categ2$(z),30)
27780   next z
27785   let fnsetup_categ=categ_worked
27790   let autostatus_worked=fnasci_("finlstat.ini//8",mat finlstat$)
27795   if autostatus_worked<1 then goto EXIT_FNSETUP_CATEG
27800   let _finlstat=udim(finlstat$)
27805   if _finlstat<99 then 
27810     mat finlstat$(99)
27815     for j=_finlstat+1 to 99
27820       let finlstat$(j)=str$(j)&","
27825     next j
27830   end if 
27835   if _finlstat>99 then mat finlstat$(99)
27840   for j=1 to 99
27845     let autostatus2$(j)=finlstat$(j)(pos(finlstat$(j),',')+1:len(finlstat$(j)))
27850   next j
27855 EXIT_FNSETUP_CATEG: ! 
27860 fnend  ! fnsetup_categ
27870 def fnsetup_states
27875   dim states$(1)*40,st$(1)*2
27880   let setup_states=1
27885   let _parse=fnasci_("Parse.St//8",mat states$) !:
        if _parse=0 and last_parse_error=0 then let fnmessagebox_("Warning Parse.st//8 is Missing, Parsing of States Will Not Function Correctly!",48,"File Missing") !:
          let last_parse_error=1
27890   mat st$(udim(states$))=("")
27895   for tst=1 to udim(states$)
27900     let tcom=pos(states$(tst),",") !:
          let st$(tst)=trim$(states$(tst)(1:tcom-1)) !:
          let states$(tst)=trim$(states$(tst)(tcom+1:999))
27905   next tst
27910   let states_al=srch(mat st$,"AL") ! AL is the First "Actual State" in the States Table!
27915 fnend 
27920 def fninit_parse
27925   let init_parse=1
27930   dim dir_s$(1)*80,dir_l$(1)*80,part$*1024,street_s$(1)*80,street_l$(1)*80,apt_s$(1)*80,apt_l$(1)*80,aptfull_s$(1)*80,aptfull_l$(1)*80
27935   let ldirections=lstreet=0
27940   open #(parse_handle:=fngethandle_): "NAME=PARSE.INI//8,SHR",display,input 
27945   linput #parse_handle: part$ eof L27985
27950 L27950: ! AFTER LINPUT
27955   if part$="||DIRECTIONS" then !:
          let fngetarray(ldirections,mat dir_s$,mat dir_l$) !:
          goto L27950
27960   if part$="||STREET TYPE" then !:
          let fngetarray(lstreet,mat street_s$,mat street_l$) !:
          goto L27950
27965   if part$="||APT_#" then !:
          let fngetarray(lapt,mat apt_s$,mat apt_l$) !:
          goto L27950
27970   if part$="||FULL_APT" then !:
          let fngetarray(laptfull,mat aptfull_s$,mat aptfull_l$) !:
          goto L27950
27975   if part$="||DONE" then goto L27985
27980   pause 
27985 L27985: close #parse_handle: 
27990 fnend 
28000 def fngetarray(&counter,mat array_s$,mat array_l$)
28005   let part$="||DONE"
28010 L28010: linput #parse_handle: buff$ eof L28035
28015   if buff$(1:2)="||" then let part$=buff$ !:
          goto L28035
28020   let counter+=1 !:
        mat array_s$(counter): mat array_l$(counter)
28025   let buff$=uprc$(buff$) !:
        let pos_comma=pos(buff$,",") !:
        if pos_comma>0 then !:
          let array_s$(counter)=trim$(buff$(1:pos_comma-1)) !:
          let array_l$(counter)=trim$(buff$(pos_comma+1:999)) else !:
          let array_s$(counter)=array_l$(counter)=buff$
28030   goto L28010
28035 L28035: fnend 
28040 def library fnparse_street$(street$*80,mat results$)
28042   let fnparse_street$=fnparsestreet$(street$,mat results$)
28044 fnend 
28050 def fnparsestreet$(street$*80,mat results$)
28055   if init_parse=0 then !:
          let fninit_parse
28060   mat results$(6)=("")
28065   let street$=srep$(street$,"."," ") !:
        let street$=srep$(street$,","," ") !:
        let street$=srep$(street$,"."," ") !:
        let street$=srep$(street$,"  "," ") !:
        let street$=srep$(street$,"P O ","PO ") !:
        let street$=srep$(street$,"R D ","RD ") !:
        let street$=srep$(street$,"POB ","PO ")
28070   let street$=srep$(street$,"ROUTE #","RTE ") !:
        let street$=srep$(street$,"Route #","RTE ") !:
        let street$=srep$(street$,"RTE #","RTE ") !:
        let street$=srep$(street$,"Rte #","RTE ") !:
        let street$=srep$(street$,"RT #","RTE ") !:
        let street$=srep$(street$,"Rt #","RTE ")
28075 ! RESULTS CONTAINS PARSED RESULTS !:
        ! 1=Street # !:
        ! 2=Street Dir !:
        ! 3=Street Name !:
        ! 4=Street_Type !:
        ! 5=Apt Type !:
        ! 6=Apt #
28080   let street$=trim$(street$)&" "
28085   let first_space=pos(street$," ")
28090   let street_no=val(srep$(srep$(street$(1:first_space-1),"-",""),"/","")) conv NO_STREET
28095   if street_no then goto YES_STREET else !:
          goto NO_STREET
28100 NO_STREET: ! Strange Street Address - No Street #
28105 ! LET STREET$=SREP$(STREET$,"#","") !:
        ! LET STREET$=SREP$(STREET$,"-","") !:
        ! ### if No Street #, then problem if # or - confuse with apt #
28110   if (pobox_pos:=pos(uprc$(street$),"PO BOX"))>0 then !:
          let pobox_next=pos(street$," ",pobox_pos+7) !:
          let results$(1)="B"&trim$(street$(pobox_pos+7:pobox_next)) !:
          let street$(pobox_pos:pobox_next)="" !:
          goto L28175
28115   if (pobox_pos:=pos(uprc$(street$),"PO "))>0 then !:
          let pobox_next=pos(street$," ",pobox_pos+4) !:
          let results$(1)="B"&trim$(street$(pobox_pos+4:pobox_next)) !:
          let street$(pobox_pos:pobox_next)="" !:
          goto L28175
28120   let street$=trim$(street$)&" " !:
        let apt_num=0 !:
        let apt_count=1
28125   do until apt_num
28130     let apt_pos:=pos(uprc$(street$),apt_s$(apt_count)&" ") !:
          if apt_pos=1 then let apt_num=apt_count
28135     let apt_count+=1 !:
          if apt_count>udim(apt_s$) then let apt_num=-1
28140   loop 
28145   if apt_num>0 then !:
          let apt_len=len(apt_s$(apt_num)) !:
          let apt_next=pos(street$," ",apt_len+2) !:
          let results$(5)=trim$(street$(1:apt_len)) !:
          let results$(6)=trim$(street$(apt_len+1:apt_next)) !:
          let street$(1:apt_next)="" !:
          goto L28175
28150 ! 
28155   let first_dash=pos(street$,"-") !:
        if first_dash>0 and first_space<15 and first_dash<first_space then goto YES_STREET
28160   let tempx=val(street$(1:1)) conv L28165 !:
        if tempx>0 then goto YES_STREET
28165 L28165: ! 
28170 ! PRINT STREET$
28175 L28175: ! end of stuff
28180   goto L28205
28185 YES_STREET: ! Street # is defined, proceed
28190   let results$(1)=trim$(street$(1:first_space))
28195   let street$(1:first_space)=""
28200   goto L28205
28205 L28205: ! find Full Apt #
28210   let street$=" "&trim$(street$)
28215   let aptfull_num=0 !:
        let aptfull_count=1
28220   do until aptfull_num
28225     if (aptfull_pos:=pos(uprc$(street$)," "&aptfull_s$(aptfull_count))) then let aptfull_num=aptfull_count
28230     let aptfull_count+=1 !:
          if aptfull_count>udim(aptfull_s$) then let aptfull_num=-1
28235   loop 
28240   if aptfull_num<=0 then goto L28255
28245   let results$(5)=street$(aptfull_pos:999) !:
        let street$(aptfull_pos:999)=""
28250   goto L28300 !:
        ! Skip Apt # if APTFULL FOUND
28255 L28255: ! Find Part APT #
28260   let street$=" "&trim$(street$)
28265   let apt_num=0 !:
        let apt_count=1
28270   do until apt_num
28275     if (apt_pos:=pos(uprc$(street$)," "&apt_s$(apt_count))) then !:
            let apt_num=apt_count else !:
            if (apt_pos:=pos(uprc$(street$),"-"&apt_s$(apt_count))) then !:
              let apt_num=apt_count
28280     let apt_count+=1 !:
          if apt_count>udim(apt_s$) then let apt_num=-1
28285   loop 
28290   if apt_num>0 then !:
          let apt_len=len(apt_s$(apt_num)) !:
          let results$(5)=trim$(street$(apt_pos:apt_pos+apt_len)) !:
          let results$(6)=trim$(street$(apt_pos+apt_len+1:999)) !:
          let street$(apt_pos:999)=""
28295   goto L28300 !:
        ! Skip Apt # if APTFULL FOUND
28300 L28300: ! find next section
28305 FIND_DIR: let street$=" "&trim$(street$)&" "
28310   let dir_num=0 !:
        let dir_count=1
28315   do until dir_num
28320     if (dir_pos:=pos(uprc$(street$)," "&dir_s$(dir_count)&" ")) then let dir_num=dir_count
28325     let dir_count+=1 !:
          if dir_count>udim(dir_s$) then let dir_num=-1
28330   loop 
28335   if dir_num<=0 then goto FIND_STREET
28340   let results$(2)=dir_l$(dir_num) !:
        let dir_len=len(dir_s$(dir_num)) !:
        let street$(dir_pos:dir_pos+dir_len)=""
28345 FIND_STREET: let street$=" "&trim$(street$)&" "
28350   let street_num=0 !:
        let street_count=1
28355   do until street_num
28360     if (street_pos:=pos(uprc$(street$)," "&street_s$(street_count)&" ")) then let street_num=street_count
28365     let street_count+=1 !:
          if street_count>udim(street_s$) then let street_num=-1
28370   loop 
28375   if street_num<=0 then goto L28385
28380   let results$(4)=street_l$(street_num) !:
        let street_len=len(street_s$(street_num)) !:
        let street$(street_pos:street_pos+street_len)=""
28385 L28385: let results$(3)=street$
28390 fnend 
28400 def library fnos_filename$*256(; ofn_filename$*256)
28402   let fnos_filename$=fn_os_filename$(ofn_filename$)
28404 fnend  ! fnos_filename$
28410 def fn_os_filename$*256(; ofn_filename$*256) ! ofn_
28415   if ofn_filename$(2:2)=':' and ofn_filename$(3:3)<>'\' and ofn_filename$(1:1)<>'@' and ofn_filename$(1:1)<>':' then 
28420     let ofn_filename$(1:2)=os_filename$(ofn_filename$(1:2))&'\'
28425   end if  ! ofn_filename$(2:2)=':' and ofn_filename$(3:3)<>'\'
28430   let fn_os_filename$=os_filename$(ofn_filename$)
28435 fnend  ! fn_os_filename$
28440 def library fnclient_path$*256(fil$*256)
28442   let fnclient_path$=fn_client_path$(fil$)
28444 fnend 
28450 def fn_client_path$*256(fil$*256)
28455   if uprc$(env$("CLIENT_SERVER"))<>"YES" or fil$(2:2)<>":" or fil$(1:2)="\\" or fil$(1:1)=":" or fil$(1:3)="@::" or uprc$(fil$(1:2))="F:" or uprc$(fil$(1:2))="N:" then goto L28475
28460   if trim$(os_filename$(fil$(1:2)&"\"))=trim$(fil$(1:2)&"\") and exists(fil$(1:2)&"\") then goto L28475
28465   if trim$(os_filename$(fil$))(1:2)="\\" then goto L28475
28470   if ~exists(fil$) and exists("@::"&fil$(1:2)&"\") then !:
          let fil$(0:-1)="@::"
28475 L28475: let fn_client_path$=fil$
28480 fnend 
28490 !
28492 ! ---------LIBRARY----------FNCHOP1$()----------------------------------
28494 def library fnchop1$*128(chop$*2048,delim$*30)
28496   let delim_pos=pos(chop$,delim$) !:
        if delim_pos>0 then let chop$=chop$(1:delim_pos-1)
28498   let fnchop1$=trim$(chop$)
28500 fnend 
28510 ! ---------LIBRARY----------FNCHOP2$()----------------------------------
28512 def library fnchop2$*256(chop$*2048,delim$*30)
28514   let delim_pos=pos(chop$,delim$) !:
        if delim_pos<=0 then let chop$="" !:
        else !:
          let chop$=chop$(delim_pos+len(delim$):999)
28516   let fnchop2$=trim$(chop$)
28518 fnend 
28520 ! ---------LIBRARY----------FNEXISTS() ---------------------------
28522 def library fnexists(fil$*80)
28524   let fnexists=fnexists_(fil$)
28526 fnend 
28530 def fnexists_(fil$*80)
28532 ! THIS FUNCTION REPLACES THE EXISTS FUNCTION, IT IS FAILING if FILE IS READ ONLY
28534 ! 1 = DIRECTORY !:
        ! 6 = FILE !:
        ! 10= WILL OPEN BUT NOT EXISTS !:
        ! 4205 = EXISTS, BUT NO RIGHTS !:
        ! 4148 = EXISTS, BUT NO SHARE
28536   let texists=exists(fil$) !:
        if texists then goto L28556
28538   let topen=899
28540 L28540: if file(topen)>=0 then let topen-=1 !:
          goto L28540
28542   open #topen: "NAME="&trim$(fil$)&",RECL=1,SHR",external,input ioerr L28544
28544 L28544: if lrec(topen)>0 then let texists=10 !:
          goto L28552
28546   let texists=err
28548   if texists=4205 or texists=4148 then goto L28552
28550   let texists=0
28552 L28552: close #topen: ioerr L28554
28554 L28554: ! 
28556 L28556: let fnexists_=texists
28558 fnend 
28560 def library fnexists_client(fil$*256)
28562   let fnexists_client=fn_exists_client(fil$)
28564 fnend 
28570 def fn_exists_client(fil$*256)
28572   if uprc$(env$("CLIENT_SERVER"))="YES" then 
28574     let fn_exists_client=exists("@::"&fil$)
28576   else 
28578     let fn_exists_client=exists(fil$)
28580   end if 
28582 fnend 
28590 def library fnexists_cache(fil$*80)
28592   let fnexists_cache=fnexists_cache_(fil$)
28594 fnend 
28600 def fnexists_cache_(fil$*80)
28602   dim exists_cache$(1)*80,exists_cache(1)
28604   let fil$=trim$(fil$)
28606   let cache_exists=srch(mat exists_cache$,fil$) !:
        if cache_exists>0 then let fnexists_cache_=exists_cache(cache_exists) !:
          goto L28616
28608   let exists_cache+=1 !:
        if exists_cache>250 then let exists_cache=1
28610   if exists_cache>max_cache then let max_cache=exists_cache !:
          mat exists_cache$(max_cache): mat exists_cache(max_cache)
28612   let exists_cache$(exists_cache)=fil$ !:
        let exists_cache(exists_cache)=exists(fil$)
28614   let fnexists_cache_=exists_cache(exists_cache)
28616 L28616: fnend 
28620 def library fngenerate_buttons(keys$*1024,labels$*1024,buttons_row;screen_label,auto_add_fkey_to_label)
28622   let fngenerate_buttons=fngenerate_buttons_(keys$,labels$,buttons_row,screen_label,auto_add_fkey_to_label)
28624 fnend 
28630 def fngenerate_buttons_(keys$*1024,labels$*1024,buttons_row;screen_label,auto_add_fkey_to_label)
28632 ! AUTO_ADD_FKEY_TO_LABEL - 1=Yes, auto adds [Esc] or [F1] to beginning of your labels, but not [F13]
28634   let str2mat(labels$,mat b_lab$,",") !:
        let str2mat(keys$,mat b_key$,",") !:
        let tot_keys=max(udim(b_key$),1) !:
        mat b_lab$(tot_keys) !:
        mat b_key(tot_keys) !:
        mat b_key$(tot_keys)
28636   for ncount=1 to tot_keys ! build mat B_Key from mat B_Key$ !:
          let b_key(ncount)=val(b_key$(ncount)) conv ignore
28638   next ncount
28640   if auto_add_fkey_to_label=1 then 
28642     for b_lab_count=1 to udim(b_lab$)
28644       if b_key(b_lab_count)=99 and pos(lwrc$(b_lab$(b_lab_count)),"esc")<=0 then let b_lab$(b_lab_count)="[Esc] "&trim$(b_lab$(b_lab_count))
28646       if b_key(b_lab_count)=90 and pos(lwrc$(b_lab$(b_lab_count)),"pgup")<=0 and pos(lwrc$(b_lab$(b_lab_count)),"pg up")<=0 then let b_lab$(b_lab_count)="[PgUp] "&trim$(b_lab$(b_lab_count))
28648       if b_key(b_lab_count)=91 and pos(lwrc$(b_lab$(b_lab_count)),"pgdn")<=0 and pos(lwrc$(b_lab$(b_lab_count)),"pg down")<=0 and pos(lwrc$(b_lab$(b_lab_count)),"pg dn")<=0 then let b_lab$(b_lab_count)="[PgDn] "&trim$(b_lab$(b_lab_count))
28650       if b_key(b_lab_count)=0 and pos(lwrc$(b_lab$(b_lab_count)),"enter")<=0 and trim$(b_lab$(b_lab_count))<>"" then let b_lab$(b_lab_count)="[Enter] "&trim$(b_lab$(b_lab_count))
28652       if b_key(b_lab_count)=>1 and b_key(b_lab_count)<=12 and pos(lwrc$(b_lab$(b_lab_count)),"[f"&str$(b_key(b_lab_count))&"]")<=0 then let b_lab$(b_lab_count)="[F"&str$(b_key(b_lab_count))&"] "&trim$(b_lab$(b_lab_count))
28654     next b_lab_count
28656   end if 
28658   let m_row$=str$(buttons_row)
28660   let status_string$=b_string$="" !:
        display buttons m_row$&",1,C 80": "" error ignore ! Delete Button Row
28662   dim b_lab$(1)*80,b_key(1),b_key$(1)*20,b_string$*512,status_string$*512
28664   let max_button=0 !:
        for b_count=1 to udim(b_lab$)
28666     if len(b_lab$(b_count))+2>max_button then !:
            let max_button=len(b_lab$(b_count))+2
28668   next b_count
28670   if max_button*udim(b_lab$)<=80 then let b_size=max_button else !:
          let b_size=int((81-udim(b_lab$))/udim(b_lab$))
28672   let b_space=min(1,int((81-(b_size*udim(b_lab$)))/udim(b_lab$))) !:
        if b_space>b_size then let b_space=1 !:
          ! * Min(#, Determins the # of spaces between buttons !:
          ! Leaving it at 1 makes the buttons look more consistent
28674   let bx=80-((udim(b_lab$)*b_size+(udim(b_lab$)-1)*b_space))+1
28676   for b_count=1 to udim(b_lab$)
28678     let b_string$=b_string$&m_row$&","&str$(bx)&","&str$(b_size)&"/C 80,[BUTTON],"&str$(b_key(b_count))&";"
28680     if b_key(b_count)=>1 and b_key(b_count)<=22 and pos(lwrc$(b_lab$(b_count)),"[f"&trim$(b_key$(b_count))&"]")<=0 then 
28682       let status_string$=status_string$&rpad$("[F"&trim$(b_key$(b_count))&"] "&b_lab$(b_count),b_size)&"  "
28684     else if b_key(b_count)=99 and pos(lwrc$(b_lab$(b_count)),'[esc]')<=0 then 
28686       let status_string$=status_string$&rpad$("[Esc] "&b_lab$(b_count),b_size)&"  "
28688     else if b_key(b_count)=90 and pos(lwrc$(b_lab$(b_count)),'[pgup]')<=0 then 
28690       let status_string$=status_string$&rpad$("[PgUp] "&b_lab$(b_count),b_size)&"  "
28692     else if b_key(b_count)=91 and pos(lwrc$(b_lab$(b_count)),'[pgdn]')<=0 then 
28694       let status_string$=status_string$&rpad$("[PgDn] "&b_lab$(b_count),b_size)&"  "
28696     else if b_key(b_count)=0 and pos(lwrc$(b_lab$(b_count)),'[enter]')<=0 and trim$(b_lab$(b_count))<>"" then 
28698       let status_string$=status_string$&rpad$("[Enter] "&b_lab$(b_count),b_size)&"  "
28700     else 
28702       let status_string$=status_string$&rpad$("[Enter] "&b_lab$(b_count),b_size)&"  "
28704     end if 
28706     let bx+=(b_size+b_space)
28708   next b_count
28710   let b_string$=rtrm$(b_string$,";")
28712 ! if UPRC$(ENV$("Developer"))="YES" THEN
28714 !   FOR DEV_J=1 TO UDIM(B_LAB$)
28716 !    if LEN(B_LAB$(DEV_J))>B_SIZE THEN !:
        !    LET FNMESSAGEBOX_("Your button ("&B_LAB$(DEV_J)&") is not being displayed because it is too large.\nBe sure to fix it",(MB_EXCLAMATION=48)+(MB_OKONLY:=0),"CLS Developer Warning")
28718 !   NEXT DEV_J
28720 ! end if
28722   display buttons b_string$: mat b_lab$ error ignore
28724   let status_string$=trim$(status_string$) !:
        let status_string$=rtrm$(status_string$,"")
28726   let status_string$=srep$(status_string$,"F99-","ESC-")
28728   if screen_label>0 then print fields str$(screen_label)&",1,80/c 100,[s]": status_string$
28730   let auto_add_fkey_to_label=0
28732 fnend 
28740 F_TEMPWP: form pos 1,c 8,c 4,c 28,c 8,c 1,12*c 60,6*pd 6.2,pos 816,c 3,bh 2,2*c 1,b 4
28742 F_LETTERS_DEF_D: form pos 1,pos 1616,c 30
28744 PUSH_INIT_WRITE_TEMPWP: ! used for QMonitor to pass tempwp noshr handle
28750 def library fnpush_init_write_tempwp(twp_handle)
28752   if not write_tempwp then !:
          let write_tempwp=h_letters=fnindex_handle("Name=I:letters,KFName=I:letters.Y") !:
          let h_debtor=fnindex_handle("Name=I:debtor,KFName=I:debtor.idx") !:
          let orig_h_tempwp=h_tempwp=twp_handle !:
          let h_active_all=fnopen_active(mat active_handles)
28754 fnend 
28760 def library fnwrite_tempwp(fileno$,llcode$,wp_com$*28,doc_flag$,mat ps$,mat nums,rp_init$;delete_diary_recno,debtors$*30,formula_flag$,h_temp_tempwp)
28770   if ~diaryint_setup then let fn_setup_diaryint_suite
28780   dim def_debtor$*30
28790   if delete_diary_recno>0 then !:
          let del_diary_indicator$="D" !:
        else !:
          let del_diary_indicator$=""
28800   dim bad_d$*1024
28810   if not write_tempwp then !:
          let write_tempwp=h_letters=fnindex_handle("Name=I:letters,KFName=I:letters.Y") !:
          let h_debtor=fnindex_handle("Name=I:debtor,KFName=I:debtor.idx") !:
          let fnopentempwp_(h_tempwp:=fngethandle_) !:
          let orig_h_tempwp=h_tempwp !:
          let h_active_all=fnopen_active(mat active_handles)
28815   if h_temp_tempwp then !:
          let h_tempwp=h_temp_tempwp !:
        else !:
          let h_tempwp=orig_h_tempwp
28820   if user=0 then let fnget_user
28830   if trim$(debtors$)<>"" then !:
          let def_debtor$=debtors$ !:
        else !:
          let def_debtor$="" !:
          read #h_letters,using F_LETTERS_DEF_D,key=uprc$(rpad$(llcode$(1:kln(h_letters)),kln(h_letters))),release: def_debtor$ nokey L28840
28840 L28840: if trim$(def_debtor$)="" then !:
          write #h_tempwp,using F_TEMPWP: fileno$,llcode$(1:4),wp_com$,llcode$,doc_flag$,mat ps$,mat nums,rp_init$,1,formula_flag$,del_diary_indicator$,delete_diary_recno !:
          goto X_WRITE_TEMPWP
28850   let d_this_claim=fnnextdebt_(fileno$,h_debtor)
28860   if trim$(def_debtor$)="*" then 
28870     let def_debtor$="1"
28880     for adddj=2 to d_this_claim !:
            let def_debtor$=def_debtor$&","&str$(adddj) ! 
28890     next adddj
28900   end if 
28910   mat dno(0) : mat relation_dno(0) !:
        let bad_d$=bad_relation$="" !:
        let def_debtor$=uprc$(def_debtor$) !:
        gosub D_RELATION !:
        let fn_range_to_array(def_debtor$,mat dno)
28920 ! combine two arrays RELATION_DNO & DNO
28930   for abj=1 to udim(relation_dno)
28940     let abj_ele=fnstretch_n_(mat dno)
28950     let dno(abj_ele)=relation_dno(abj)
28960   next abj
28970   if sum(dno)=0 then !:
          let fnbad_debtor_doc_req(fileno$,"@BAD_D",trim$(llcode$)&" "&def_debtor$,user) !:
          goto X_WRITE_TEMPWP
28980   let def_debtor$=fn_array_to_range$(mat dno) !:
        ! convert def_debtor$ to all #'s
28990   for dj=1 to udim(dno)
29000     if dno(dj)<=d_this_claim then 
29010       write #h_tempwp,using F_TEMPWP: fileno$,llcode$(1:4),wp_com$,llcode$,doc_flag$,mat ps$,mat nums,rp_init$,dno(dj),formula_flag$,del_diary_indicator$,delete_diary_recno
29020     else 
29030       let bad_d$=bad_d$&","&str$(dno(dj))
29040     end if 
29050   next dj
29060 ! PRINT FNNOPAPER_$(BAD_D$) : PAUSE !:
        if len(trim$(fnnopaper_$(bad_d$&bad_relation$)))>0 then !:
          ! may need to srep more puctuation !:
          let fnbad_debtor_doc_req(fileno$,"@BAD_D",trim$(llcode$)&bad_d$&bad_relation$,user)
29070 X_WRITE_TEMPWP: !:
      fnend 
29080 def library fnpush_init_write_tempwp_close
29085   close #h_letters: ioerr ignore
29090   close #h_debtor: ioerr ignore
29095 ! CLOSE #H_TEMPWP: IOERR IGNORE - NO Don't Do thiS !
29100   for active_handles_item=1 to udim(mat active_handles)
29105     close #active_handles(active_handles_item): ioerr ignore
29110   next active_handles_item
29115   let fnindex_handle_reset !:
        let write_tempwp=h_letters=h_debtor=0 !:
        mat active_handles(0)=(0)
29120 fnend  ! fnpush_init_write_tempwp_close
29130 D_RELATION: let fnd_rel(fileno$,mat d_rel$,h_debtor) ! r:
29135 dim bad_relation$*256
29140 mat get_relation$(0)
29145 let fnparse_csv_(def_debtor$,mat get_relation$,",")
29150 for d_relj=1 to udim(get_relation$)
29155   let get_relation$(d_relj)=uprc$(get_relation$(d_relj))
29160 next d_relj
29165 for d_relj=1 to udim(get_relation$)
29170   let gr_ele=srch(d_rel$,get_relation$(d_relj))
29175   if gr_ele>0 then 
29180     let dno_ele=fnstretch_n_(mat relation_dno) !:
          let relation_dno(dno_ele)=gr_ele
29185   else 
29190     let dummy=val(get_relation$(d_relj)) conv L29195 !:
          ! test for numbers which get evaluated elsewhere !:
          goto L29200
29195 L29195: mat test_dno(0) !:
          let fn_range_to_array(get_relation$(d_relj),mat test_dno) !:
          if udim(test_dno)<=0 then !:
            let bad_relation$=bad_relation$&","&get_relation$(d_relj) !:
            ! if relation can convert to numeric array, assume it's not a bad relation
29200 L29200: end if 
29205 next d_relj
29210 return  ! /r D_RELATION
29220 def fn_messagebox(mbx_message$*2048; mbx_type,mbx_title$*200,mbx_nogui$*28) ! mbx_
29225   let orig_mb_fkey=fkey
29230 ! mbx_name$*20 - if included than a checkbox for "[ ] don't ask me again next time" will be added to the message
29235   if ~mbx_setup then 
29240     let mbx_setup=1
29245     dim mbx_dont_ask_again_text$*40
29250     dim mbx_win_data$(1)*128,mbx_win$*2048,mbx_name$*40,mbx_button_fkey_list$*256
29255     dim mbx_file_os$(1)*256
29260     dim mbx_file_v$(1)*256
29265     dim mbx_win_field$(1)*40,mbx_win_text$(1)*40
29270 !   let mbx_dont_ask_again_text$='Remember my answer next time.'
29275     let mbx_wait_time=15*60 ! if jbowman then let mbx_wait_time=3 else let mbx_wait_time=15*60
29280   end if  ! ~mbx_setup
29285   if lwrc$(env$('Messagebox_Always_Ask'))='yes' then let mbx_always_ask=1 else let mbx_always_ask=0 ! note this line - this line forces the questions to be ask even if they have choosen not to remember prior answer.
29290   let mbx_name$=mbx_nogui$
29295   let mbx_message$=srep$(mbx_message$,crlf$,lf$)
29300   let mbx_message$=srep$(mbx_message$,cr$,lf$)
29305   let mbx_message$=srep$(mbx_message$,'\n',lf$)
29310   let fn_mbx_size(mbx_message$,mb3_text_rows,mb3_cols)
29315   let mb3_text_rows=max(mb3_text_rows,5)
29320   let mb3_parent_rows=mb3_text_rows+2
29325   let mb3_cols=min(mb3_cols,80)
29330   let mbx_button_default=fn_mbx_button_default(mbx_type)
29335   let mbx_icon$=fn_mbx_icon$(mbx_type)
29340   let mbx_button_count=fn_mbx_button(mbx_type,mbx_button_text$,mat mbx_button_return)
29345   if mbx_name$<>'' then 
29350     let mb3_parent_rows+=1 ! add line for dont ask again text and a blank line
29355     if udim(mat mbx_button_return)=1 then 
29360       let mbx_dont_ask_again_text$='Do not notify me again.'
29365     else 
29370       let mbx_dont_ask_again_text$='Remember my answer next time.'
29375     end if 
29380     let mb3_cols=max(mb3_cols,len(mbx_dont_ask_again_text$)+10)
29385     let mbx_dont_ask_row=mb3_parent_rows-1 ! mbx_dont_ask_row is the row to print the dont ask again text on
29390   end if  ! mbx_name$<>''
29395   let mbx_button_fkey_list$=''
29400   mat mbx_button_fkey(mbx_button_count)
29405   for mbx_button_fkey_item=1 to mbx_button_count
29410     let mbx_button_fkey(mbx_button_fkey_item)=2010+mbx_button_fkey_item
29415     let mbx_button_fkey_list$(inf:0)=str$(mbx_button_fkey(mbx_button_fkey_item))&';'
29420   next mbx_button_fkey_item
29425   let mbx_button_fkey_list$=mbx_button_fkey_list$(1:len(mbx_button_fkey_list$)-1) ! remove the last ;
29430 ! 
29435   if mbx_type<>0 then print 'mbx_type<>0 - something must be wrong' : pause 
29440 ! 
29445   if mbx_name$<>'' then 
29450     let mbx_name$='mbx_'&trim$(mbx_name$)&'_'&str$(mb3_parent_rows)&'x'&str$(mb3_cols)
29455     let mbx_win$='name='&mbx_name$&','
29460     let mbx_checked=fnregunum_get(mbx_name$)
29465   else 
29470     let mbx_checked=0
29475   end if  ! mbx_name$<>''   /   else 
29480   let mbx_file_count=fn_mbx_get_file_list(mbx_h_text,mbx_message$,mbx_h_cols,mat mbx_file_os$,mat mbx_file_v$)
29485   if mbx_always_ask or mbx_checked<=9999 then 
29490     mat mbx_win_field$(1)=('')
29495     mat mbx_win_text$(1)=('')
29500     let mbx_win$=''
29505     let mbx_timeout=0
29510 !   if mbx_checked>9999 then let mbx_dont_ask_again_text$='^'&mbx_dont_ask_again_text$
29515     let mbx_win$(inf:0)='Caption='&srep$(mbx_title$,',','.')
29520     let mbx_win$(inf:0)=',rows='&str$(mb3_parent_rows)
29525     let mbx_win$(inf:0)=',cols='&str$(mb3_cols)
29530     let mbx_win$(inf:0)=',center'
29535     let mbx_win$(inf:0)=',button.text='&mbx_button_text$ ! &';(f)Copy'
29540     if mbx_file_count>0 then 
29545       let mbx_win$(inf:0)=';(f)File'
29550       if mbx_file_count>1 then let mbx_win$(inf:0)='s'
29555 !     mbx_button_default+=1 ! because File will be the first button, so skip it.
29560     end if  ! mbx_file_count>0
29565     let mbx_win$(inf:0)=',button.fkey='&mbx_button_fkey_list$ ! &';33'
29570     if mbx_file_count>0 then 
29575       let mbx_win$(inf:0)=';33'
29580     end if  ! mbx_file_count>0
29585     let mbx_win$(inf:0)=',parent=none'
29590     if ~developer then let mbx_win$(inf:0)=',modal,Nomaximize'
29595     open #mbx_h_win:=fngethandle_: fn_open_parent$(mbx_win$,mat mbx_win_data$,1,1),display,output 
29600     let fn_generate_buttons_for_window(mat mbx_win_data$,mbx_h_win, 1,mat mbx_win_field$,mat mbx_win_text$)
29605     let fn_array_reverse$(mat mbx_win_field$)
29610     let fn_array_reverse$(mat mbx_win_text$)
29615     if exists('Icons\'&mbx_icon$&'.png') then print #mbx_h_win,fields '1,1,P 4/8,[W]': 'Icons\'&mbx_icon$&'.png:isotropic'
29620     let mbx_h_cols=val(mbx_win_data$(pw_cols))
29625     let mbx_h_text_rows=mb3_text_rows
29630     let mbx_h_text_cols=mbx_h_cols-10
29635     open #mbx_h_text:=fngethandle_: 'Modal,Parent='&str$(mbx_h_win)&',Border=None,SRow=1,SCol=10,Rows='&str$(mbx_h_text_rows)&',Cols='&str$(mbx_h_text_cols),display,output 
29640 ! if jbowman then print 'mbx_message$='&mbx_message$ : pause
29645     print #mbx_h_text,fields '1,1,'&fn_mbx_text_size$(mbx_h_text_cols,mbx_h_text_rows)&',[T]S,49': mbx_message$
29650     if mbx_name$<>'' then 
29655       let fn_add_one$(mat mbx_win_field$,str$(mbx_dont_ask_row)&',10,Check '&str$(len(mbx_dont_ask_again_text$)+1)&',[W]ae,2020')
29660       let fn_add_one$(mat mbx_win_text$,rpt$('^',min(1,mbx_checked-10000))&mbx_dont_ask_again_text$)
29665       let mbx_win_which_don_ask=udim(mat mbx_win_text$)
29670       if mbx_checked-10000>0 then let mbx_button_default=srch(mat mbx_button_fkey,mbx_checked-10000)
29675     end if  ! mbx_name$<>''
29680     for mbx_win_field_item=1 to udim(mat mbx_win_field$)
29685       let mbx_win_field$(mbx_win_field_item)=srep$(mbx_win_field$(mbx_win_field_item),'[Button]','[Button]ae')
29690     next mbx_win_field_item
29695     let curfld(mbx_button_default)
29700     do 
29705       let mb_x_click=0
29710       rinput #mbx_h_win,select mat mbx_win_field$,attr '[A]',wait=mbx_wait_time: mat mbx_win_text$ timeout ignore
29715       if fkey=93 or fkey=99 then 
29720         gosub MBX_DEFAULT_FKEY !:
              let mb_x_click=mb_x
29725       else if fkey=101 then 
29730         let mbx_timeout=1
29735         gosub MBX_DEFAULT_FKEY
29740       else if fkey=2020 then 
29745         if mbx_win_text$(mbx_win_which_don_ask)(1:1)='^' then 
29750           let mbx_win_text$(mbx_win_which_don_ask)(1:1)=''
29755         else 
29760           let mbx_win_text$(mbx_win_which_don_ask)(0:0)='^'
29765         end if  ! mbx_win_text$(mbx_win_which_don_ask)(1:1)='^'   /   else 
29770       else if fkey=33 and mbx_file_count>0 then ! Alt+F
29775         let fn_mbx_file_menu(mbx_title$,mbx_file_count,mbx_h_text_cols,mat mbx_file_os$,mat mbx_file_v$,mbx_wait_time)
29780       else if fkey=46 then ! Alt+C
29785         let setenv('ClipBoard',srep$(mbx_message$,lf$,crlf$))
29786       else if fkey=99 and mbx_button_count=1 then 
29787         let fkey(mbx_button_fkey(1))
29790       end if  ! fkey=...
29795     loop until srch(mat mbx_button_fkey,fkey)>0
29800     if mbx_name$<>'' and fkey<>101 then 
29805       if mbx_win_text$(mbx_win_which_don_ask)(1:1)='^' then let mbx_checked=1 else let mbx_checked=0
29810       if mbx_checked then 
29815         let fnregunum_put(mbx_name$,10000+fkey)
29820       else 
29825         let fnregunum_put(mbx_name$,0)
29830       end if  ! mbx_checked   /   else 
29835     end if  ! mbx_name$=''
29840     close #mbx_h_win: 
29845   else 
29850 !   print 'returning with fkey '&str$(mbx_checked-10000)&' from memory'
29855     let fkey(mbx_checked-10000)
29860 !   pause
29865   end if  ! mbx_always_ask or mbx_checked<=9999   /   else 
29870   goto MBX_XIT
29875 MBX_DEFAULT_FKEY: ! 
29880   if curfld<=mbx_button_count and srch(mat mbx_button_fkey,mbx_button_fkey(curfld))>0 then 
29885     let fkey(mbx_button_fkey(curfld))
29890   else 
29895     let fkey(mbx_button_fkey(mbx_button_default))
29900   end if  ! curfld<=mbx_button_count and srch(mat mbx_button_fkey,mbx_button_fkey(curfld))>0   /   else 
29905   return  ! MBX_DEFAULT_FKEY
29910 MBX_XIT: ! 
29915   if mb_x_click then !:
          let fn_messagebox=mb_x_click !:
        else !:
          let fn_messagebox=mbx_button_return(srch(mat mbx_button_fkey,fkey))
29920   if mbx_timeout then let fkey(101)
29925   if fkey<>93 and fkey<>101 then let fkey(orig_mb_fkey)
29930   let orig_mb_fkey=0
29935 fnend  ! fn_messagebox
29940 def fn_mbx_file_menu(mbxfm_title$*80,mbxfm_file_count,mbxfm_h_text_cols,mat mbxfm_file_os$,mat mbxfm_file_v$,mbxfm_wait_time) ! mbxfm_
29945 ! 
29950   dim mbxfm_action_win$*256,mbxfm_win_action_data$(1)*128
29955   dim mbxfm_file_path$*256,mbxfm_file_name_base$*128,mbxfm_file_name_extension$*128
29960   dim mbxfm_h_tab(2)
29965   dim mbxfm_action_tab$*256,mbxfm_selection$*256
29970   dim mbxfm_file_field$(1)*20
29975   let mbxfm_action_win$=mbxfm_s$=''
29980   if mbxfm_file_count>1 then let mbxfm_s$='s'
29985   let mbxfm_action_win$(inf:0)='Caption='&mbxfm_title$&' - File'&mbxfm_s$
29990   let mbxfm_action_win$(inf:0)=',center'
29995   let mbxfm_action_win$(inf:0)=',rows='&str$(mbxfm_file_count+3)
30000   let mbxfm_action_win$(inf:0)=',cols='&str$(mbxfm_win_action_cols:=max(40,mbxfm_h_text_cols)+2)
30005   let mbxfm_action_win$(inf:0)=',button.text=Close;(f)Copy;(f)Open;(f)Open Folder'
30010   let mbxfm_action_win$(inf:0)=',button.fkey=99;2001;2002;2003'
30015   let mbxfm_action_win$(inf:0)=',parent=none'
30020   if ~developer then let mbxfm_action_win$(inf:0)=',modal,Nomaximize'
30025   open #mbxfm_h_win:=fngethandle_: fn_open_parent$(mbxfm_action_win$,mat mbxfm_win_action_data$,1),display,output 
30030   let mbxfm_action_tab$='SRow=2,SCol=2,Rows='&str$(mbxfm_file_count+0)&',Cols='&str$(mbxfm_win_action_cols-2)&',Parent='&str$(mbxfm_h_win)
30035   let fn_generate_buttons_for_window(mat mbxfm_win_action_data$,mbxfm_h_win)
30040   open #mbxfm_h_tab(1):=fngethandle_: fn_open_parent$(mbxfm_action_tab$&',Tab=OS Path'&mbxfm_s$,mat mbxfm_tab_data$,1),display,output 
30045   open #mbxfm_h_tab(2):=fngethandle_: fn_open_parent$(mbxfm_action_tab$&',Tab=Virtual Path'&mbxfm_s$,mat mbxfm_tab_data$,1),display,output 
30050   mat mbxfm_file_field$(mbxfm_file_count)
30055   for mbxfm_file_item=1 to mbxfm_file_count
30060     let mbxfm_file_field$(mbxfm_file_item)=str$(mbxfm_file_item)&',1,40/C '&mbxfm_win_action_data$(pw_cols)&',[M]'
30065   next mbxfm_file_item
30070   let mbxfm_curtab=fnregunum_get('mbxfm_CurTab')
30075   if mbxfm_curtab<=0 then let mbxfm_curtab=2
30080   do 
30085     let curfld(mbxfm_curfld)
30090     if mbxfm_curtab=1 then 
30095       rinput #mbxfm_h_tab(mbxfm_curtab),select mat mbxfm_file_field$, attr '[L]',wait=mbxfm_wait_time: mat mbxfm_file_os$ timeout ignore
30100       let mbxfm_selection$=mbxfm_file_os$(curfld)
30105     else ! if mbxfm_curtab=2 then
30110       rinput #mbxfm_h_tab(mbxfm_curtab),select mat mbxfm_file_field$, attr '[L]',wait=mbxfm_wait_time: mat mbxfm_file_v$ timeout ignore
30115       let mbxfm_selection$=mbxfm_file_v$(curfld)
30120     end if  ! mbxfm_curtab=1   /   else 
30125     let mbxfm_curfld=curfld
30130     if fkey=92 then 
30135       if mbxfm_curtab=1 then let mbxfm_curtab=2 else let mbxfm_curtab=1
30140     else if fkey=101 then 
30145       let fkey(99)
30150     else if fkey=2001 then 
30155       let setenv('ClipBoard',mbxfm_selection$)
30160     else if fkey=2002 then 
30165       let fn_exe('-c -w','VB32\WinShell',mbxfm_file_os$(curfld))
30170     else if fkey=2003 then 
30175       let fn_filepath_parse(mbxfm_file_os$(curfld),mbxfm_file_path$,mbxfm_file_name_base$,mbxfm_file_name_extension$)
30180       execute "System -c -w explorer /select,"&srep$(mbxfm_file_os$(curfld),"@::","")&'"' !:
            ! fn_exe MIGHT NOT BE A GOOD IDEA HERE!
30185     end if  ! fkey=92   /   101   /   2001   /   2002   /   2003
30190   loop until fkey=99 or fkey=93
30195   let fnregunum_put('mbxfm_CurTab',mbxfm_curtab)
30200   close #mbxfm_h_win: 
30205 fnend  ! fn_mbx_file_menu
30210 def fn_mbx_get_file_list(mbxht_h_parent,mbxht_text$*2048,mbxht_cols,mat mbxht_file_os$,mat mbxht_file_v$) ! mbxht_
30215   dim mbxht_line$(1)*1024
30220   let str2mat(mbxht_text$,mat mbxht_line$) ! No Paramater needed here LF of all types
30225   mat mbxht_file_os$(0)
30230   mat mbxht_file_v$(0)
30235   for mbxht_line_item=1 to udim(mat mbxht_line$)
30240     if mbxht_line$(mbxht_line_item)(1:2)='\\' or mbxht_line$(mbxht_line_item)(2:2)=':' then ! the line specifies a file
30245       let os_filename$(mbxht_line$(mbxht_line_item)) error L30260 ! Check for "Bad File Names"
30250       let fn_add_one$(mat mbxht_file_v$,mbxht_line$(mbxht_line_item),0,1)
30255       let fn_add_one$(mat mbxht_file_os$,fn_client_os_path$(mbxht_line$(mbxht_line_item)),0,1) ! Fn_Os_Filename$ - FN_Client_OS_Path does this!
30260 L30260: end if  ! mbxht_line$(mbxht_line_item)(1:2)='\\' or mbxht_line$(mbxht_line_item)(2:2)=':'
30265   next mbxht_line_item
30270   let fn_mbx_get_file_list=udim(mat mbxht_file_os$)
30275 fnend  ! fn_mbx_get_file_list
30280 def fn_mbx_text_size$(mts_cols,mts_rows)
30285   let mts_cols_original=mts_cols
30290   let mts_rows_original=mts_rows
30295   let fn_mbx_text_size$=str$(mbx_h_text_cols*mbx_h_text_rows)&"/C" ! str$(mts_cols_original*mts_rows_original)&'/Cl '&str$(mts_cols*mts_rows)
30300 fnend  ! fn_mbx_text_size$
30310 def fn_array_reverse$(mat ar_reverse_me$)
30312   dim ar_reverse_tmp$(1)*40
30314   let ar_reverse_count=udim(mat ar_reverse_me$)
30316   mat ar_reverse_tmp$(ar_reverse_count)=ar_reverse_me$
30318   for ar_reverse_item=1 to ar_reverse_count
30320     let ar_reverse_me$(ar_reverse_item)=ar_reverse_tmp$(udim(ar_reverse_me$)-ar_reverse_item+1)
30322   next ar_reverse_item
30324 fnend  !  fn_array_reverse$(mat mbx_win_text$)
30330 def library fndocexist$*80(formexist$*80)
30335   let llcode$=formexist$
30340   dim form_dir$*80,wptype$*80,doc_ext$(5)*4,formexist$*80,form_doc$*256,is_wp_form_doc$*256
30345   if ~cls_setup then let fnclssetup
30350   let form_name$="" !:
        let form_count=1
30355   if trim$(wptype$)="MSWORD" and trim$(doc_ext$(form_count))="" then !:
          goto L30365
30360 L30360: if fnexists_(trim$(form_dir$)&"\"&trim$(llcode$)&"."&trim$(doc_ext$(form_count))) then !:
          let form_name$=trim$(trim$(lwrc$(trim$(llcode$)&"."&doc_ext$(form_count))),".") !:
          goto L30370
30365 L30365: if (form_count+=1)<=udim(doc_ext$) then goto L30360
30370 L30370: if form_name$<>"" then !:
          let fndocexist$=trim$(form_dir$)&"\"&form_name$ else !:
          let fndocexist$=""
30375 fnend 
30380 ! ---------------------------------------------------------------------
30385 def library fnparse_wp(wp$*100,mat wp$)
30390   mat wp$=("")
30395   let wp$=srep$(wp$,"\","")
30400   if pos(wp$,"#")<=0 or wp$(1:1)="*" then goto EXIT_WP_PARSE
30405   let delim3=pos(wp$,".") !:
        let delim1=pos(wp$(1:delim3),"#") !:
        if delim1<=0 then goto EXIT_WP_PARSE
30410   let delim2=pos(wp$,"#",delim1+1) !:
        let delim4=pos(wp$,"<") !:
        if delim4<=0 then let delim4=999
30415   let wp$(1)=wp$(1:delim1-1)
30420   if delim2<=0 then !:
          let delim2=delim3 !:
          let wp$(3)="" !:
        else !:
          let wp$(3)=uprc$(wp$(delim2+1:delim3-1))
30425   let wp$(2)=uprc$(wp$(delim1+1:delim2-1))
30430   let wp$(4)=uprc$(wp$(delim3+1:delim4-1))
30435   let wp$(5)=uprc$(wp$(delim4:999))
30440 EXIT_WP_PARSE: !:
      fnend 
30450 ! ---------------------------------------------------------------------
30452 def library fnget_ctfofil$*70(handle,filkey$, fofile$*20)
30454   dim forwarder_file$*70
30456   let fnget_ctfofil$ = fofile$
30458   if fofile$(1:1)='*' then !:
          read #handle,using L30460, key=rpad$(filkey$,8)&"*CtFoFil",release: forwarder_file$ nokey L30462 !:
          let fnget_ctfofil$ = forwarder_file$
30460 L30460: form pos 27,c 70
30462 L30462: fnend 
30470 ! ---------------------------------------------------------------------
30475 def library fnput_ctfofil$*20(handle,filkey$,user,fofile$*80)
30480   let fofile$=rtrm$(fofile$) !:
        if len(fofile$)<=20 then goto L30500
30485   rewrite #handle,using FORM_PI1,key=rpad$(filkey$,8)&"*CtFoFil": filkey$,"*CtFoFil","C",date('cymd'),fnstime_(time$),fnbh_1_$(user),fofile$ nokey L30490 !:
        goto L30495
30490 L30490: write #handle,using FORM_PI1: filkey$,"*CtFoFil","C",date('cymd'),fnstime_(time$),fnbh_1_$(user),fofile$ nokey L30490 !:
        goto L30495
30495 L30495: let x1=len(fofile$) !:
        let fofile$="*"&fofile$(x1-18:x1)
30500 L30500: let fnput_ctfofil$=fofile$
30505 fnend 
30506 def library fngetinf$(handle,inf_key$,&buff,&buff$)
30507   let fngetinf$=fn_getinf$(handle,inf_key$,buff,buff$)
30508 fnend 
30510 def fn_getinf$(handle,inf_key$,&buff,&buff$)
30515   dim inf_data$*70
30520   let buff=0 !:
        let buff$=inf_type$=""
30525 RINFINITY: form pos 1,c 8,x 8,c 1,pos 27,c 70
30530   read #handle,using RINFINITY,key=rpad$(inf_key$,kln(handle)),release: inf_fileno$,inf_type$,inf_data$ nokey L30555
30535   if inf_type$="C" or inf_type$="F" then let buff$=inf_data$ !:
          goto L30550
30540   if inf_type$="N" or inf_type$="I" then let buff$=str$(buff:=val(inf_data$)) !:
          goto L30550
30545   if inf_type$="D" then let buff$=trim$(inf_data$) !:
          let buff=val(srep$(buff$,"/","")) !:
          let buff=days(buff) !:
          goto L30550
30550 L30550: let fn_getinf$=inf_type$
30555 L30555: fnend 
30560 def library fnputinf$(inf_handle,sel_handle,filkey$,inf_key$,user,pi_value$*70,pi_value; type_filter$,pi_oc_slash$*3)
30562   if ~setup_library then gosub SETUP_LIBRARY
30564   if ~setup_constants then gosub SETUP_CONSTANTS
30566   let fnputinf$=fnputinf_$(inf_handle,sel_handle,filkey$,inf_key$,user,pi_value$,pi_value, type_filter$,pi_oc_slash$)
30568 fnend 
30570 def fnputinf_$(inf_handle,sel_handle,filkey$,inf_key$,user,pi_value$*70,pi_value; type_filter$,pi_oc_slash$*3)
30575 ! pi_oc_slash$ = '//1' or '//6'
30580 ! inf sel passed, but inf_mast s/b used
30585 ! ** ,INPUT is more compatible, might cause conflicts with out "OUTIN" later!
30590   if ~pi_setup then 
30595     let pi_setup=1
30600     dim inf_desc$*30,inf_help$*60
30605 FORM_PI1: form pos 1,c 8,c 8,c 1,2*bh 4,c 1,c 70
30610 FORM_PI2: form pos 1,2*c 8,c 1,c 30,c 60
30615     open #h_infmast:=fngethandle_: "Name=InfMast.Int//9,KFName=InfMast.Idx//9,Shr",internal,input,keyed 
30620   end if  ! ~pi_setup
30625   if pi_oc_slash$<>'//6' and pi_oc_slash$<>'//1' then let pi_oc_slash$=''
30630   if ~pioc_setup then !   in 7.2 use:        if pi_oc_slash$<>'' and ~pioc_setup then
30635     let pioc_setup=1
30640     dim pi_tmp_data$(1)*80,pi_tmp_data(1)
30645     let pi_changes_open_handle=fnopen_changes(mat pi_changes_open_handle)
30650     let pi_changes_closed_handle=fnclosed_changes(mat pi_changes_closed_handle)
30655     let pi_master_open_handle=fnindex_handle("Name=I:Master,KFName=I:MasterX")
30660     let pi_master_closed_handle=fnindex_handle("Name=H:History,KFName=H:HistoryX")
30665     let pi_master_first_only_formc$=cform$('Form Pos 1,C 8')
30670     let pi_master_first_only_formn$=cform$('Form Pos 17,BH 3')
30675   end if  ! pi_oc_slash$<>'' and ~pioc_setup
30680 ! todo: region top - comment this region in to make all calls to fnputinf$ make entries in changes    ** ***************** ***************** ***************** ***************** *****************
30685 ! if pi_oc_slash$='' then gosub PI_OC_GET
30690 ! if pi_oc_slash$='' and debug then print 'fnputinf$ could not find claim '&filkey$&' in open nor closed master.  *changes* entry (only) will be skipped.'
30695 ! if pi_oc_slash$='' and developer then pause
30700 ! todo: region end - in 7.2 comment out this region. ***************** ***************** ***************** ***************** ***************** ***************** ***************** ***************
30705   let inf_type$="" !:
        read #h_infmast,using FORM_PI2,key=rpad$(uprc$(inf_key$),8),release: tinf_key$,inf_date$,inf_type$,inf_desc$,inf_help$ nokey EXIT_PUTINF_ !:
        let inf_key$=tinf_key$ !:
        if inf_type$="D" then let pi_value$=fndate10_$(pi_value$) !:
        else !:
          if inf_type$="N" then let pi_value$=cnvrt$("PIC(---,---,---,--#.##)",pi_value) conv ignore !:
          else !:
            if inf_type$="I" then let pi_value$=cnvrt$("PIC(---,---,---,--#)",pi_value) conv ignore
30710   if type_filter$="D ONLY" and inf_type$<>"D" then goto EXIT_PUTINF_
30715   let filkey$=rpad$(filkey$,8)
30720   if pi_oc_slash$<>'' then 
30725     dim pi_prior_pi_value$*70
30730     read #inf_handle,using FORM_PI1,key=filkey$&uprc$(rpad$(inf_key$,8)),release: pi_prior_filkey$,pi_prior_inf_key$,pi_prior_inf_type$,pi_prior_date,pi_prior_time,pi_prior_user$,pi_prior_pi_value$ nokey PI_INF_NOKEY
30735     if pi_value$=pi_prior_pi_value$ then goto EXIT_PUTINF_
30740     if pi_oc_slash$='//6' then 
30745       let pi_changes_handle=pi_changes_open_handle
30750     else ! pi_oc_slash$='//1'
30755       let pi_changes_handle=pi_changes_closed_handle
30760     end if  ! pi_oc_slash$='//6'   /   else 
30765     if (uprc$(trim$(inf_key$))='*CDCC#' and fnsecurity_("MAST:*CDCC# HISTORY","",89,user_init$,1)<=0) then goto SKIP_WRITE_PAP
30766     let fn_change(pi_changes_handle,pi_active_handle,date('ccyymmdd'),fnstime_(time$),filkey$,0,0,'','','',user,0,pi_prior_pi_value$,0,pi_value$,0,inf_key$,'','Infinity',1)
30767 SKIP_WRITE_PAP: ! 
30770   end if  ! pi_oc_slash$<>''
30775   rewrite #inf_handle,using FORM_PI1,key=filkey$&uprc$(rpad$(inf_key$,8)),release: filkey$,inf_key$,inf_type$,date('cymd'),fnstime_(time$),fnbh_1_$(user),pi_value$ nokey PI_INF_NOKEY
30780   if trim$(pi_value$)="" then !:
          delete #inf_handle,key=filkey$&uprc$(rpad$(inf_key$,8)): 
30785   goto EXIT_PUTINF_
30790 PI_INF_NOKEY: ! 
30795   if trim$(pi_value$)<>"" then !:
          write #inf_handle,using FORM_PI1,release: filkey$,inf_key$,inf_type$,date('cymd'),fnstime_(time$),fnbh_1_$(user),pi_value$ !:
          ! Only create a Screen Infinity Field if the value is not blank.
30800   goto EXIT_PUTINF_
30805 PI_OC_GET: ! 
30810   let fn_read_oc(filkey$,mat pi_tmp_data$,mat pi_tmp_data,pi_oc$,pi_master_open_handle,pi_master_closed_handle,pi_master_first_only_formc$,pi_master_first_only_formn$)
30815   if pi_oc$='Open' then 
30820     let pi_oc_slash$='//6'
30825   else if pi_oc$='Closed' then 
30830     let pi_oc_slash$='//1'
30835   else 
30840     let pi_oc_slash$=''
30845   end if 
30850   return  ! PI_OC_GET
30855 EXIT_PUTINF_: ! 
30860   let fnputinf_$=inf_type$
30865 fnend  ! fnputinf_$
30870 def library fntab_input(mat tab_input_field$)
30872 ! if ~cls_setup then let fnclssetup
30874   let fntab_input=fn_tab_input(mat tab_input_field$)
30876 fnend 
30880 def fn_tab_input(mat tab_input_field$)
30885   if ~tab_input_setup then 
30890     let tab_input_setup=1
30895     if user_init$="" then let user_init$=fnuserinit$
30900     let policy_gui_tab_key=fnsecurity_("GUI:TAB KEY",'',0,user_init$,inquiry_only:=1) : if policy_gui_tab_key=-1 then let policy_gui_tab_key=0
30905     if uprc$(env$("GUI_FORCE_TABS"))="YES" then !:
            let policy_gui_tab_key=1 !:
          else if uprc$(env$("GUI_FORCE_TABS"))="NO" then !:
            let policy_gui_tab_key=0
30910 end if  ! ~tab_input_setup
30915 if ~policy_gui_tab_key then 
30920   for tab_input_item=1 to udim(mat tab_input_field$)
30925     if pos(tab_input_field$(tab_input_item),'{')>0 then 
30930       let tab_input_field$(tab_input_item)=srep$(tab_input_field$(tab_input_item),"[D]T","[D]")
30935       let tab_input_field$(tab_input_item)=srep$(tab_input_field$(tab_input_item),"[D]ST","[D]S")
30940       let tab_input_field$(tab_input_item)=srep$(tab_input_field$(tab_input_item),"}T","}")
30945       let tab_input_field$(tab_input_item)=srep$(tab_input_field$(tab_input_item),"T{","{")
30950       let tab_input_field$(tab_input_item)=srep$(tab_input_field$(tab_input_item),"}XT","}X")
30955       let tab_input_field$(tab_input_item)=srep$(tab_input_field$(tab_input_item),"}AT","}A")
30960     else 
30965       let tab_input_field$(tab_input_item)=srep$(tab_input_field$(tab_input_item),'T','')
30970       let tab_input_field$(tab_input_item)=srep$(tab_input_field$(tab_input_item),'t','')
30975     end if  ! pos(ab_input_field$(tab_input_item),'{')>0   /   else 
30980   next tab_input_item
30985 end if  ! ~policy_gui_tab_key
30990 fnend  ! fn_tab_input
31000 def library fnget_edi_refno$*30(ger_fileno$*8,ger_internal_backbone_handle,ger_edi_refno$*30) ! ger_
31002   read #ger_internal_backbone_handle,using "FORM POS 27,C 30",key=ger_fileno$&"  028MAIN      ",release: ger_edi_refno$ nokey ignore
31004   let fnget_edi_refno$=ger_edi_refno$
31006 fnend  ! fnget_edi_refno$
31010 def library fnget_jmt_no$*30(gjn_fileno$*8,gjn_internal_backbone_handle,gjn_value$*30) ! gjn_
31012   read #gjn_internal_backbone_handle,using "FORM POS 27,C 30",key=gjn_fileno$&"  0 2JUDGMENT  ",release: gjn_value$ nokey ignore
31014   let fnget_jmt_no$=gjn_value$
31016 fnend  ! fnget_jmt_no$
31020 def library fnget_filename$*80(data_fil$*80;fhelp$*1024,fprompt$*80) !:
        ! ! DATA_FIL$ - suggest file name || FHELP$ - optional help window
31022 ! DIM FPROMPT$*80
31024 ! if TRIM$(FPROMPT$)="" THEN LET FPROMPT$="Enter Name of File To Process:"
31026 ! PRINT FIELDS "3,1,CR 39,[W];24,1,CC 80,[S]": FPROMPT$,"Enter Name of ASCII File  Wildcards are acceptable  F5 Search"
31028 ! RINPUT FIELDS "3,40,CU 40/80,[D]SAE", HELP FHELP$: DATA_FIL$
31030 ! if (CMDKEY=99 OR CMDKEY=93) THEN LET DATA_FIL$=""
31032 ! ON ERROR GOTO 43210
31034 ! if CMDKEY=5 OR POS(DATA_FIL$,"*")>0 OR POS(DATA_FIL$,"?")>0 THEN !:
        ! LET DATA_FIL$=FNOPEN_$(TRIM$(DATA_FIL$),"") !:
        ! GOTO 43210
31036 ! ON ERROR SYSTEM
31038 ! LET FNGET_FILENAME$=TRIM$(DATA_FIL$)
31040   let askfile1_response=fnaskfile1(data_fil$,"", fprompt$,data_fil$,"",fhelp$)
31042   if askfile1_response=99 then 
31044     let fnget_filename$=""
31046   else 
31048     let fnget_filename$=data_fil$
31050   end if 
31052 fnend 
31060 ! --------------------------FNASCI()------------------------------------
31062 def fnasci_(ascifile$*256,mat asci$;include_empty)
31064   on soflow ignore 
31066   dim asci$*8192
31068   let ascifile=fngetdisplay_(ascifile$) !:
        if ascifile=0 then mat asci$(1)=("") !:
          goto L31104
31070   let line_cnt=0
31072   mat asci$(1)=("")
31074   for asci_masx=1 to 8
31076     let asci$(1)(1:0)=rpt$("*",4000)
31078   next asci_masx
31080   let max_entries=int((2**25-2**12)/len(asci$(1)))-1 !:
        let mem_max=int(268435200/len(asci$(1))) !:
        if max_entries>mem_max then let max_entries=mem_max !:
          ! ** Allow Max or roughly 32MB of Memory for ASCI imports !:
          ! Theoretical MAX is 268,435,200 bytes !:
          ! 32 bit Memory Limits make 32MB more practical
31082   let sys_max_entries=max_entries !:
        let max_entries_increment=0 !:
        let max_entries=1000 !:
        mat asci$(max_entries)=("") !:
        ! Allocate Memory to avoid Stretching Array
31084 L31084: linput #ascifile: asci$ eof L31100 !:
        if ~include_empty and trim$(asci$)="" then goto L31084
31086   let line_cnt+=1
31088   if line_cnt>=max_entries then 
31090     if line_cnt>=sys_max_entries then !:
            mat asci$(line_cnt): let asci$(line_cnt)="*****OUT OF MEMORY*****" !:
            close #ascifile: !:
            let fnasci_=-1: goto L31104
31092     let max_entries_increment+=1000 !:
          let max_entries+=max_entries_increment !:
          let max_entries=min(max_entries,sys_max_entries) !:
          mat asci$(max_entries)
31094   end if  ! LINE_CNT>=max_entries THEN
31096   let asci$(line_cnt)=asci$
31098   goto L31084
31100 L31100: close #ascifile: 
31102   let fnasci_=1 !:
        mat asci$(line_cnt) !:
        ! ** Resize array back to needed size
31104 L31104: fnend 
31110 def library fnasci(ascifile$*256,mat asci$;include_empty)
31112   let fnasci=fnasci_(ascifile$,mat asci$,include_empty)
31114 fnend 
31120 ! --------------------------FNLIST()------------------------------------
31125 def fnlist_(list$*4096,mat work$;delimiter$)
31130   if trim$(delimiter$)="" then let delimiter$=","
31135   on soflow ignore 
31140   let work=0 !:
        mat work$(20)=("*!*") !:
        let x=pos(list$,":") !:
        let list$=trim$(list$(x+1:9999))&delimiter$
31145   let work=str2mat(list$,mat work$,delimiter$)
31150   for _work=1 to work !:
          let work$(_work)=trim$(work$(_work)) !:
        next _work
31155   let fnlist_=work
31160 fnend 
31170 def library fnlist(list$*4096,mat work$;delimiter$)
31172   let fnlist=fnlist_(list$,mat work$,delimiter$)
31174 fnend 
31176 ! ---------LIBRARY----------FNINCREMENT()-------------------------------
31178 def library fnincrement(mat work$,counter)
31180   let counter+=1 !:
        if counter>udim(work$) then let counter=1
31182   let fnincrement=counter
31184 fnend 
31190 def fnparse_csv_(list$*4096,mat work$;separator$,notrim)
31195 ! Notrim=0 means trim$ each work$ item !:
        !       =1 means do not trim at all !:
        !       =2 means rtrm$ each work$ item
31200   if trim$(separator$)="" then let separator$=","
31205   let work=0 !:
        if notrim=1 then let list$(9999:0)=separator$ !:
        else if notrim=2 then !:
          let list$=rtrm$(list$) !:
          let list$(9999:0)=separator$ !:
        else !:
          let list$=trim$(list$) !:
          let list$(9999:0)=separator$
31210 L31210: let delim$='' !:
      if list$(1:1)='"' or list$(1:1)="'" then let delim$=list$(1:1) !:
        let list$(1:1)=""
31215 let xstart=0 !:
      let x_adv=1 !:
      if separator$<>chr$(9) and delim$<>"" then let xstart=pos(list$,delim$) !:
        let x_adv=2
31220 let x=pos(list$,separator$,xstart) !:
      if x<=0 then let x=len(list$)+1
31225 let work+=1 !:
      mat work$(work) !:
      let work$(work)=list$(1:x-x_adv) !:
      if notrim=1 then let list$=list$(x+len(separator$):9999) !:
      else if notrim=2 then let list$=rtrm$(list$(x+len(separator$):9999)) !:
      else let list$=trim$(list$(x+len(separator$):9999))
31230 if trim$(delim$)<>"" then !:
        let work$(work)=srep$(work$(work),chr$(254)," ") !:
        let work$(work)=srep$(work$(work),delim$&delim$,chr$(254)) !:
        let work$(work)=trim$(work$(work),delim$) !:
        let work$(work)=srep$(work$(work),chr$(254),delim$) !:
        ! Double Delimiters need to be properly parsed.
31235 ! We may want to parse further "\" variables in the future !:
      ! For example, we may want to remove trailing "\" fields.
31240 if trim$(delim$)="" then 
31245   let hexpos=1
31250 L31250: let hexpos = pos(work$(work),"\x",hexpos)
31255   if work$(work)(hexpos-1:hexpos-1)="\" then goto L31270
31260   if hexpos=<0 then goto L31285
31265   let chrval = val(work$(work)(hexpos+2:hexpos+3)) conv L31270 : goto L31275
31270 L31270: let hexpos+=4 !:
        goto L31250
31275 L31275: let work$(work)(hexpos:hexpos+3)=chr$(chrval)
31280   let hexpos+=4 !:
        goto L31250
31285 L31285: let work$(work) = srep$(work$(work),"\\","\")
31290 end if 
31295 if trim$(list$)<>separator$ and trim$(list$)<>"" then goto L31210
31300 let fnparse_csv_=work
31305 fnend 
31310 def library fnparse_csv(list$*4096,mat work$;separater$,notrim)
31312   let fnparse_csv=fnparse_csv_(list$,mat work$,separater$,notrim)
31314 fnend 
31320 ! ---------LIBRARY--------FN_SREP$------------------------------------
31322 def library fn_srep$*1024(srep_a$*1024,srep_b$*1024,srep_c$*1024; srep_case_insensitive)
31324   if srep_case_insensitive then 
31326     let srep_p=pos(uprc$(srep_a$),uprc$(srep_b$))
31328   else 
31330     let srep_p=pos(srep_a$,srep_b$)
31332   end if 
31334   if srep_p>0 then let srep_a$=srep_a$(1:srep_p-1)&srep_c$&srep_a$(srep_p+len(srep_b$):len(srep_a$))
31336   let fn_srep$=srep_a$
31338 fnend  ! fn_srep$
31340 ! ------------------------FNSQLTEXT$----------------------------------
31345 def fnsqltext$*1024(&lib_sql$)
31350   let lib_sql$(9999:0)=" "
31355 CHECK_FUNCTION: let sqltype=0 !:
        let sqltext=pos(uprc$(lib_sql$)," NOT IN(") !:
        if sqltext>0 then let sqltype=1 : goto FOUNDSQL
31360   let sqltext=max(pos(uprc$(lib_sql$)," IN("),pos(uprc$(lib_sql$)," IN (")) !:
        if sqltext>0 then let sqltype=2 : goto FOUNDSQL
31365   let sqltext=pos(uprc$(lib_sql$)," NOT BETWEEN") !:
        if sqltext>0 then let sqltype=3 : goto FOUNDSQL
31370   let sqltext=pos(uprc$(lib_sql$)," BETWEEN") !:
        if sqltext>0 then let sqltype=4 : goto FOUNDSQL
31372   let sqltext=pos(uprc$(lib_sql$)," LIKE") !:
        if sqltext>0 then let sqltype=5 : goto FOUNDSQL !:
        else !:
          let sqltype=0
31375 FOUNDSQL: let sqlstart=pos(lib_sql$(1:sqltext-1)," ",-1)+1
31380   let quote$=lib_sql$(sqltext-1:sqltext-1) ! CHECK FOR QUOTES IN STRINGS !:
        if quote$="'" or quote$='"' then !:
          let sqlstart=pos(lib_sql$(1:sqlstart-1)," ",-1)+1 !:
          goto FIND_SQLEND else !:
          if sqltype=0 then goto FIND_SQLEND
31385   let lib_sql$(sqltext:0)="'"
31390   let sqlstart=pos(lib_sql$(1:sqltext-1)," ",-1)
31395   let lib_sql$(sqlstart+1:0)="'"
31400   goto CHECK_FUNCTION
31405 FIND_SQLEND: if sqltype=5 then ! LIKE
31406     let sqllike=pos(lib_sql$,"*",sqltext) !:
          let sqlend=pos(lib_sql$,"'",sqllike) !:
          if sqlend=0 then let sqlend=pos(lib_sql$,'"',sqllike)
31407   else ! IN, BETWEEN
31408     let sqlend=pos(lib_sql$,") ",sqltext)
31409   end if  ! sqltype=5
31410   on sqltype goto NOT_IN,IN,NOT_BETWEEN,BETWEEN,LIKE none NOSQLTEXT
31415 NOT_IN: !:
        let lib_sql$(sqlstart:sqlend)=fnsqlstring$(lib_sql$,sqlstart,sqlend,sqltext,7," FNNOTIN( ") !:
        goto CHECK_FUNCTION
31420 IN: !:
        let lib_sql$(sqlstart:sqlend)=fnsqlstring$(lib_sql$,sqlstart,sqlend,sqltext,3," FNIN( ") !:
        goto CHECK_FUNCTION
31425 NOT_BETWEEN: !:
        let lib_sql$(sqlstart:sqlend)=fnsqlstring$(lib_sql$,sqlstart,sqlend,sqltext,12," FNNOTBETWEEN( ") !:
        goto CHECK_FUNCTION
31430 BETWEEN: !:
        let lib_sql$(sqlstart:sqlend)=fnsqlstring$(lib_sql$,sqlstart,sqlend,sqltext,8," FNBETWEEN( ") !:
        goto CHECK_FUNCTION
31432 LIKE: !:
        let lib_sql$(sqlstart:sqlend)=fnsqlstring$(lib_sql$,sqlstart,sqlend,sqltext,6," FN_LIKE( ") !:
        goto CHECK_FUNCTION
31435 NOSQLTEXT: let fnsqltext$=lib_sql$ ! 
31440 fnend 
31450 ! -----------------------------FNSQLSTRING$---------------------------
31452 def fnsqlstring$*1024(&lib_sql$,sqlstart,sqlend,sqltext,offset,func$*30)
31454   let fnsqlstring$=func$&lib_sql$(sqlstart:sqltext)&",'"&srep$(srep$(srep$(srep$(lib_sql$(sqltext+offset:sqlend),"'",""),'"',''),")"," "),"("," ")&"')"
31456 fnend 
31460 ! -----------------------------FNIN-----------------------------------
31462 def fnin(find$*80,in$*512)
31464   dim in$(1)*60
31466   let elements=fnlist_(in$,mat in$)
31468   let in=srch(mat in$,find$)
31470   if in>0 then let fnin=1
31472 fnend 
31480 ! -----------------------------FNNOTIN--------------------------------
31482 def fnnotin(find$*80,in$*512)
31484   let elements=fnlist_(in$,mat in$)
31486   let in=srch(mat in$,find$)
31488   if in<=0 then let fnnotin=1
31490 fnend 
31500 ! -----------------------------FNBETWEEN------------------------------
31505 def fnbetween(find$*80,in$*180)
31510   let find$=uprc$(find$) !:
        let in$=uprc$(in$)
31515   let elements=fnlist_(in$,mat in$)
31520   if elements<>2 then goto L31555 ! BETWEEN MUST HAVE 2 ELEMENTS
31525   let low=val(in$(1)) conv BETWEEN_CHAR
31530   let high=val(in$(2)) conv BETWEEN_CHAR
31535   let between=val(find$) conv BETWEEN_CHAR
31540   if between>=low and between<=high then !:
          let fnbetween=1 !:
          goto L31555 else goto L31555
31545 BETWEEN_CHAR: ! 
31550   if find$>=in$(1) and find$<=in$(2) then !:
          let fnbetween=1
31555 L31555: fnend 
31560 ! --------------------------FNNOTBETWEEN------------------------------
31565 def fnnotbetween(find$*80,in$*180)
31570   let elements=fnlist_(in$,mat in$)
31575   if elements<>2 then goto L31555 ! BETWEEN MUST HAVE 2 ELEMENTS
31580   let low=val(in$(1)) conv N_BETWEEN_CHAR
31585   let high=val(in$(2)) conv N_BETWEEN_CHAR
31590   let between=val(find$) conv N_BETWEEN_CHAR
31595   if between<low or between>high then !:
          let fnnotbetween=1 !:
          goto L31555 else goto L31555
31600 N_BETWEEN_CHAR: ! 
31605   if find$<in$(1) or find$>in$(2) then !:
          let fnnotbetween=1
31610 fnend 
31620 def library fninit_cap$*1024(init_cap$*1024; ic_source_type)
31622   let fninit_cap$=fninitcap$(init_cap$, ic_source_type)
31624 fnend 
31630 ! ---------LIBRARY----------FNINIT_CAP$-------------------------------
31635 def fninitcap$*1024(init_cap$*1024; ic_source_type)
31640 ! IC_Source_Type identifies the type of source string.  Thus changing the rules by which capitalization is applied. !:
        ! IC_Source_Type = 1 = Person's Name   (  a person's name will never contain a state abbreviation) !:
        ! IC_Source_Type = 2 = Description   (won't check for state) !:
        ! IC_Source_Type = 3 = Code   (won't check for state)
31645   dim newinit_cap$*1024
31650   if setup_states=0 then let fnsetup_states
31655   if uprc$(init_cap$)<>init_cap$ then !:
          let newinit_cap$=init_cap$ !:
          goto L31805
31660   let newinit_cap$=""
31665   let init_cap$=trim$(init_cap$)
31670 L31670: let pspace=pos(init_cap$," ") !:
        let pslash=pos(init_cap$,"/") !:
        let pbackslash=pos(init_cap$,"\") !:
        let pstar=pos(init_cap$,"*") !:
        let pcomma=pos(init_cap$,",") !:
        let pperiod=pos(init_cap$,".") !:
        let punder=pos(init_cap$,"_") !:
        let pdash=pos(init_cap$,"-") !:
        let pcolon=pos(init_cap$,":")
31675   let p=0 !:
        if p=0 then let p=pspace else !:
          if pspace then let p=min(pspace,p)
31680   if p=0 then let p=pcolon else !:
          if pcolon then let p=min(pcolon,p)
31685   if p=0 then let p=pstar else !:
          if pstar then let p=min(pstar,p)
31690   if p=0 then let p=pcomma else !:
          if pcomma then let p=min(pcomma,p)
31695   if p=0 then let p=pperiod else !:
          if pperiod then let p=min(pperiod,p)
31700   if p=0 then let p=punder else !:
          if punder then let p=min(punder,p)
31705   if p=0 then let p=pslash else !:
          if pslash then let p=min(pslash,p)
31710   if p=0 then let p=pbackslash else !:
          if pbackslash then let p=min(pbackslash,p)
31715   if p=0 then let p=pdash else !:
          if pdash then let p=min(pdash,p)
31720 ! P Should be 0 (No Symbols), or the First Symbol
31725   if p<>0 then !:
          let newinit_cap$=newinit_cap$&uprc$(init_cap$(1:1))&lwrc$(init_cap$(2:p)) else goto L31740
31730   let init_cap$=init_cap$(p+1:len(init_cap$))
31735   if trim$(init_cap$)<>"" then goto L31670
31740 L31740: let newinit_cap$=newinit_cap$&uprc$(init_cap$(1:1))&lwrc$(init_cap$(2:len(init_cap$)))
31745   let newinit_cap$=srep$(newinit_cap$," Llc"," LLC")
31750   let pmc=pos(newinit_cap$,"Mc")
31755   if pmc<>0 then !:
          let newinit_cap$=newinit_cap$(1:pmc+1)&uprc$(newinit_cap$(pmc+2:pmc+2))&newinit_cap$(pmc+3:len(newinit_cap$))
31760   let po=pos(newinit_cap$,"O'")
31765   if po<>0 then !:
          let newinit_cap$=newinit_cap$(1:po+1)&uprc$(newinit_cap$(po+2:po+2))&newinit_cap$(po+3:len(newinit_cap$))
31770   let newinit_cap$=newinit_cap$&" "
31775   if ic_source_type=0 then 
31780     let fn_init_cap_state(newinit_cap$)
31785     for st_count=1 to 51
31790       let newinit_cap$=srep$(newinit_cap$," "&st$(st_count)(1:1)&lwrc$(st$(st_count)(2:2))&" "," "&st$(st_count)&" ") !:
            let newinit_cap$=srep$(newinit_cap$,","&st$(st_count)(1:1)&lwrc$(st$(st_count)(2:2))&" ",","&st$(st_count)&" ")
31795     next st_count
31800   end if  ! IC_Source_Type=0
31805 L31805: let newinit_cap$=srep$(newinit_cap$," Ii "," II ") !:
        let newinit_cap$=srep$(newinit_cap$," Iii "," III ") !:
        let newinit_cap$=srep$(newinit_cap$," Iv "," IV ") !:
        let newinit_cap$=srep$(newinit_cap$," Vi "," VI ") !:
        let newinit_cap$=srep$(newinit_cap$," Vii "," VII ") !:
        let newinit_cap$=srep$(newinit_cap$," Viii "," VIII ") !:
        let newinit_cap$=srep$(newinit_cap$," Ix "," IX ")
31810   let newinit_cap$=srep$(newinit_cap$," Po "," PO ")
31815   if newinit_cap$(1:3)="Po " then !:
          let newinit_cap$(1:3)="PO "
31820   if ic_source_type=3 and newinit_cap$(1:1)="X" and newinit_cap$(2:2)=lwrc$(newinit_cap$(2:2)) then !:
          let newinit_cap$(1:1)="x" : let newinit_cap$(2:2)=uprc$(newinit_cap$(2:2))
31821   if uprc$(newinit_cap$(1:4))="*CC:" then !:
          let newinit_cap$(1:4)="*cc:"
31825   let fninitcap$=rtrm$(newinit_cap$)
31830 fnend 
31840 def fn_init_cap_state(&ics_string$) ! Ics_
31845 ! This function:
31850 !                will capialize only the State portion of CS or CSZ fields
31855 !                is subordinate to Fninitcap$.  This function requires mat St$
31860 !                requires mat St$
31865 !                returns a 1 if it changed something or a 0 if nothing was changed
31870   dim ics_results$(3)*512
31875   let csz_city=1 : let csz_state=2 : let csz_zip=3 ! fnParse_CSZ$ Enumerations
31880   let ics_return=0
31885   let fnparse_csz_$(ics_string$,mat ics_results$)
31890   if srch(mat st$,uprc$(ics_results$(csz_state)))>0 then 
31895     let ics_string$=ics_string$&' ' ! add a trailing space
31900     let ics_string$=srep$(ics_string$," "&uprc$(ics_results$(csz_state)(1:1))&lwrc$(ics_results$(csz_state)(2:2))&" "," "&uprc$(ics_results$(csz_state))&" ")
31905     let ics_string$=srep$(ics_string$,","&uprc$(ics_results$(csz_state)(1:1))&lwrc$(ics_results$(csz_state)(2:2))&" ",","&uprc$(ics_results$(csz_state))&" ")
31910     let ics_string$=ics_string$(1:len(ics_string$)-1) ! remove the trailing space
31915 !   pr Ics_String$ : pause
31920     let ics_return=1
31925   end if  ! Srch(Mat St$,uprc$(Ics_Results$(CSZ_State)))>0
31930   let fn_init_cap_state=ics_return
31935 fnend  ! Fn_Init_Cap_State
31940 def library fncustom(group$,feature$)
31945   dim tkey$*20,serial_no$*30
31950   if serial=12906 and (env$("USERDOMAIN")="FILIMERICA.LOCAL" or env$("USERDOMAIN")="CLS") then let fncustom=1 !:
          goto CUSTOM_XIT
31955   let custom_handle=fngethandle_ !:
        open #custom_handle: "NAME=REG-CUST.INT//8,KFNAME=REG-CUST.IDX//8,SHR",internal,input,keyed ioerr CUSTOM_XIT
31960 FORM_CUSTOM: form pos 1,2*c 10,c 10,c 30,n 10
31965   let tkey$=rpad$(group$(1:10),10)&rpad$(feature$(1:10),10)
31970   read #custom_handle,using FORM_CUSTOM,key=tkey$,release: tgroup$,tfeature$,exp_date$,serial_no$,serial_no nokey CUSTOM_FINIS
31975 ! So Far, we found the item, but is it still active?
31980   let exp_date=fndate10_(exp_date$) !:
        if exp_date=0 and serial_no=serial then let fncustom=1 !:
          goto CUSTOM_FINIS
31985   if days(date)<=days(exp_date) then let fncustom=1 !:
          goto CUSTOM_FINIS
31990   let msg$(tkey$&" Expired:"&exp_date$)
31995 CUSTOM_FINIS: ! 
32000   close #custom_handle: ioerr ignore
32005 CUSTOM_XIT: ! 
32010 fnend  ! fncustom
32020 def library fnmessagebox(message$*2048;type1,title$*200,nogui$*28)
32022   if ~setup then let fn_setup
32024   let fnmessagebox=fnmessagebox_(message$,type1,title$,nogui$)
32026 fnend  ! fnmessagebox
32030 def fnmessagebox_(message$*2048;type1,title$*200,nogui$*28)
32035   let mb_orig_fkey_=fkey
32040   if ~mb_setup then 
32045     let mb_setup=1
32050     let mbx_security_gui_messagebox=max(0,fnsecurity_("GUI:MESSAGEBOX",'',0,fnuserinit$,1))
32055   end if  ! ~mb_setup
32060   let message$=fnlocalize_$(srep$(message$,"\n",chr$(10)))
32065   let title$=fnlocalize_$(title$)
32070   let scr_thaw
32075   if trim$(title$)="" then let title$="Collection-Master"
32080   let nogui$=trim$(nogui$)
32085   if env$('GUIMode')='ON' and mbx_security_gui_messagebox and uprc$(nogui$)<>'NOGUI' then ! and nogui$<>''
32090     let fnmessagebox_=fn_messagebox(message$, type1,title$,nogui$)
32095   else 
32100     if uprc$(nogui$)="NOGUI" or fnwin_gui=0 then !:
            goto L32135 !:
          else !:
            let message_result=fnmappedmsgbox(message$, type1,title$) !:
            if message_result>=0 then goto L32130 !:
              ! The following implements the Windows Message Box
32105     open #(twin_handle:=fngethandle_): "NAME="&env$("TEMP")&"\CM-"&session$&".TXT,recl=10000,REPLACE",display,output  !:
          print #twin_handle: srep$(srep$(srep$(message$,chr$(13)&chr$(10),chr$(10)),chr$(13),chr$(10)),",",".") !:
          print #twin_handle: type1 !:
          print #twin_handle: title$ !:
          close #twin_handle: !:
          let scr_thaw !:
          let fn_exe('-w QUOTE=NONE','VB32\MSGBOX',env$("TEMP")&"\CM-"&session$&".TXT") error L32135 !:
          let fnclear
32110     let message_result=0 !:
          open #(twin_handle:=fngethandle_): "NAME="&env$("TEMP")&"\CM-"&session$&".TXT",display,input 
32115     linput #twin_handle: message_result$ ioerr L32120
32120 L32120: close #twin_handle: 
32125     let message_result=val(message_result$) conv L32130
32130 L32130: let fnmessagebox_=message_result !:
          goto L32705
32135 L32135: dim ff$*400
32140     let message_result=fnmappedmsgbox(message$, type1,title$) !:
          if message_result>=0 then let fnmessagebox_=message_result !:
            goto L32705 !:
            ! Even if GUI features are disabled, use the enhanced box if appropriate
32145 !   if we get this far, then we have a "Special Message Box" That is not supported by the "DOS" Mode
32150     if env$("GUIMODE")="ON" and message_result<>-998 then print "Warning: ";message$;type1;title$ !:
            pause 
32155     if len(message$)>1000 then let fnmessagebox_=-1: goto L32705
32160     let cols=min(max(50,int(len(message$)/5)),60) !:
          let rows=max(6,int(len(message$)/(cols-10)+6))
32165 WRAP_MESSAGE: let next_line=last_line=last_mark=0 ! WRAP MESSAGE BOX CONTENT
32170 L32170: let next_line=pos(message$,chr$(10),last_line+1) !:
          if next_line=0 then let next_line=len(message$)+1: let last_mark=1
32175     if len(message$(last_line:next_line-1))<=cols-12 then !:
            let last_line=next_line+1 else goto L32185
32180     if last_mark=0 then goto L32170 else goto L32190
32185 L32185: let find_space=pos(rtrm$(message$(1:last_line+cols-12))," ",-1) !:
          if find_space>0 then let message$(find_space:find_space)=chr$(10) !:
            goto WRAP_MESSAGE
32190 L32190: ! 
32195     let scol=int((80-cols)/2)
32200     let srow=int((26-rows)/2)
32205     let message_window=fngetwindow_(scol,srow,cols,rows,title$,"DS") !:
          print #message_window : newpage
32210     let sub_message_window=fngetwindow_(scol+11,srow+1,cols-12,rows-1)
32215     let b$=lpad$(fndec2bin_$(type1),12,"0")
32220     let default= fnbin2dec_(b$(1:4)) !:
          if default>2 then let default=1
32225     let symbol=fnbin2dec_(b$(5:8)) !:
          if symbol>4 then let symbol=2
32230     let button=fnbin2dec_(b$(9:12)) !:
          if button>5 then let button=0
32235     on symbol goto L32240,L32255,L32270,L32285
32240 L32240: let k=int((rows)/2)-1 !:
          let ff$=str$(k)&",3,C 4,[S];"&str$(k+1)&",2,C 6,[S];"&str$(k+2)&",3,C 4,[S]"
32245     print #message_window,fields ff$: ""," STOP ",""
32250     goto L32300
32255 L32255: let k=int((rows)/2)-1 !:
          let ff$=str$(k)&",3,c 6,[W];"&str$(k+1)&",8,c 1,[W];"&str$(k+2)&",5,c 4,[W];"&str$(k+3)&",5,c 1,[W];"&str$(k+4)&",5,C 1,[w]"
32260     print #message_window,fields ff$: " 旼컴","","旼켸","",""
32265     goto L32300
32270 L32270: let k=int((rows)/2)-2 !:
          let ff$=str$(k)&",5,c 3,[w];"&str$(k+1)&",5,c 3,[w];"&str$(k+2)&",5,c 3,[w];"&str$(k+3)&",5,c 3,[w];"&str$(k+4)&",5,c 3,[w];"&str$(k+5)&",5,c 3,[w]"
32275     print #message_window,fields ff$: "旼"," "," ","읕","旼","읕"
32280     goto L32300
32285 L32285: let k=int((rows)/2)-1 !:
          let ff$=str$(k)&",5,C 3,[W];"&str$(k+1)&",5,C 3,[W];"&str$(k+2)&",5,C 3,[W];"&str$(k+3)&",5,C 3,[W];"&str$(k+4)&",5,C 3,[W]"
32290     print #message_window,fields ff$: "旼","읕","旼"," ","읕"
32295     goto L32300
32300 L32300: let next_message_line=0
32305 L32305: if pos(message$,chr$(10))<=0 then !:
            goto L32325
32310     let npos1=pos(message$,chr$(10))
32315     print #sub_message_window,fields str$(next_message_line+=1)&",1,c,[w]": srep$(message$(1:npos1),chr$(10)," ") error L32320
32320 L32320: let message$(1:npos1)="" !:
          goto L32305
32325 L32325: print #sub_message_window,fields str$(next_message_line+=1)&",1,c,[w]": srep$(message$,chr$(10)," ") error L32330 !:
          ! ! Strip out the junk!
32330 L32330: let cols1=8 !:
          let rows1=1
32335     on button+1 gosub MB_BUTTON_SET_OKONLY,MB_BUTTON_SET_OKCANCEL,MB_BUTTON_SET_ABORTRETRYIGNORE,MB_BUTTON_SET_YESNOCANCEL,MB_BUTTON_SET_YESNO,MB_BUTTON_SET_RETRYCANCEL
32340     goto MB_FINIS
32345 !   ---Type 0-----
32350 MB_BUTTON_SET_OKONLY: ! 
32355     let scol1=int(cols/2) !:
          let int((80-cols)/2+(cols-cols1)/2)
32360     let srow1=rows-rows1-1 ! Use Sub Window Instead of Full Screen
32365 !   gosub 46820
32370     mat choice$(1)=("") !:
          let choice$(1)="OK"
32375     mat form$(1)=("") !:
          let form$(1)=str$(srow1)&","&str$(scol1)&",cc "&str$(cols1)&",[W]SAE"
32380     let mb_x=mb_ok ! on red x click or esc, behave as if ok is chosen.
32385 L32385: rinput #sub_message_window,select mat form$,attr '[L]': mat choice$: let choice=curfld
32390 !   RETURN
32395     if fkey>99 and fkey<200 then let curfld(curfld,fkey) !:
            goto L32385
32400     if fkey=200 then let choice=nxtfld
32405     if (cmdkey=99 or cmdkey=93) then let choice=udim(choice$)
32410 ! 
32415     gosub MB_PRINT_CHOICES_DISABLED
32420     return  ! MB_BUTTON_SET_OKONLY
32425 !   ---Types 1,4, and 5-----
32430 ! 
32435 MB_BUTTON_SET_OKCANCEL: ! 
32440     mat choice$(2)=("") !:
          let choice$(1)="OK" !:
          let choice$(2)="Cancel" !:
          let mb_x=mb_cancel ! on red x click or esc, behave as if cancel is chosen. !:
          goto MB_BUTTON_SET_145_CONTINUE
32445 MB_BUTTON_SET_YESNO: ! 
32450     mat choice$(2)=("") !:
          let choice$(1)="Yes" !:
          let choice$(2)="No" !:
          let mb_x=mb_no ! on red x click or esc, behave as if no is chosen. !:
          goto MB_BUTTON_SET_145_CONTINUE
32455 MB_BUTTON_SET_RETRYCANCEL: ! 
32460     mat choice$(2)=("") !:
          let choice$(1)="Retry" !:
          let choice$(2)="Cancel" !:
          let mb_x=mb_cancel ! on red x click or esc, behave as if cancel is chosen. !:
          goto MB_BUTTON_SET_145_CONTINUE
32465 MB_BUTTON_SET_145_CONTINUE: ! 
32470     let scol1=int(cols/2) -3 !:
          ! LET SCOL1=INT((80-COLS)/2+(COLS-COLS1*2)/2)-3
32475     let srow1=rows-rows1-1 ! Use Sub Window Instead of Full Screen
32480     let scol2=scol1+cols1+3
32485 !   gosub 46820
32490 !   gosub 46840
32495     mat form$(2)=("") !:
          let form$(1)=str$(srow1)&","&str$(scol1)&",cc "&str$(cols1)&",[W]SAE" !:
          let form$(2)=str$(srow1)&","&str$(scol2)&",cc "&str$(cols1)&",[W]SAE" !:
          let curfld(default+1)
32500 L32500: rinput #sub_message_window,select mat form$,attr '[L]': mat choice$: let choice=curfld
32505     if fkey>99 and fkey<200 then let curfld(curfld,fkey) !:
            goto L32500
32510     if fkey=200 then let choice=nxtfld
32515     if (cmdkey=99 or cmdkey=93) then let choice=udim(choice$)
32520 ! 
32525     gosub MB_PRINT_CHOICES_DISABLED
32530     let fkey(0)
32535     return  ! MB_BUTTON_SET_OKCANCEL, MB_BUTTON_SET_YESNO, MB_BUTTON_SET_RETRYCANCEL
32540 !   ---Types 2 and 3-----
32545 ! 
32550 MB_BUTTON_SET_ABORTRETRYIGNORE: ! 
32555     mat choice$(3)=("") !:
          let choice$(1)="Abort" !:
          let choice$(2)="Retry" !:
          let choice$(3)="Ignore" !:
          let mb_x=mb_abort ! on red x click or esc, behave as if abort is chosen. !:
          goto MB_BUTTON_SET_23_CONTINUE
32560 MB_BUTTON_SET_YESNOCANCEL: ! 
32565     mat choice$(3)=("") !:
          let choice$(1)="Yes" !:
          let choice$(2)="No" !:
          let choice$(3)="Cancel" !:
          let mb_x=mb_cancel ! on red x click or esc, behave as if cancel is chosen. !:
          goto MB_BUTTON_SET_23_CONTINUE
32570 MB_BUTTON_SET_23_CONTINUE: ! 
32575     let scol1=int(cols/2)-3 !:
          let int((80-cols)/2+(cols-cols1)/2) !:
          ! LET SCOL1=INT((80-COLS)/2+(COLS-COLS1*3)/2)-3
32580     let srow1=rows-rows1-1 ! Use Sub Window Instead of Full Screen
32585     let scol2=scol1+cols1+3
32590     let scol3=scol2+cols1+3
32595     mat form$(3)=("") !:
          let form$(1)=str$(srow1)&","&str$(scol1)&",cc "&str$(cols1)&",[W]SAE" !:
          let form$(2)=str$(srow1)&","&str$(scol2)&",cc "&str$(cols1)&",[W]SAE" !:
          let form$(3)=str$(srow1+1)&","&str$(scol1)&",cc "&str$(cols1)&",[W]SAE" !:
          let curfld(default+1)
32600 L32600: rinput #sub_message_window,select mat form$,attr '[L]': mat choice$: let choice=curfld
32605     if fkey>99 and fkey<200 then let curfld(curfld,fkey) !:
            goto L32600
32610     if fkey=200 then let choice=nxtfld
32615     if (cmdkey=99 or cmdkey=93) then let choice=udim(choice$)
32620     gosub MB_PRINT_CHOICES_DISABLED
32625     return  ! MB_BUTTON_SET_ABORTRETRYIGNORE, MB_BUTTON_SET_YESNOCANCEL
32630 MB_RETURN_ASSIGN: ! 
32635     if choice$(choice)="Abort" then let fnmessagebox_=3 else !:
            if choice$(choice)="Yes" then let fnmessagebox_=6 else !:
              if choice$(choice)="No" then let fnmessagebox_=7 else !:
                if choice$(choice)="OK" then let fnmessagebox_=1 else !:
                  if choice$(choice)="Cancel" then let fnmessagebox_=2 else !:
                    if choice$(choice)="Retry" then let fnmessagebox_=4 else !:
                      if choice$(choice)="Ignore" then let fnmessagebox_=5
32640 X_MB_RETURN_ASSIGN: !:
          return  ! goto MB_FINIS ! MB_RETURN_ASSIGN
32645 MB_PRINT_CHOICES_DISABLED: ! 
32650     print #sub_message_window,fields mat form$: mat choice$
32655     let sleep(.1)
32660     print #sub_message_window,fields srep$(form$(choice),"[W]SAE","[L]S"): choice$(choice)
32665     let sleep(.1)
32670     return  ! MB_PRINT_CHOICES_DISABLED
32675 MB_FINIS: ! 
32680     gosub MB_RETURN_ASSIGN
32685     close #sub_message_window: 
32690     close #message_window: 
32695   end if 
32700   if mb_orig_fkey<>fkey then let fkey(mb_orig_fkey_): let mb_orig_fkey_=0 ! Restore the FKEY Value for Messagebox
32705 L32705: fnend 
32710 ! ---------------------------FNDEC2BIN_$------------------------------
32712 def fndec2bin_$*1024(dec)
32714   dim bin$*1024
32716   let bin$=""
32718   for i=32 to 0 step -1
32720     if dec/(2**i) >=1 then !:
            let bin$(99:0)="1": let dec=dec-2**i else !:
            let bin$(99:0)="0"
32722   next i
32724   let fndec2bin_$=ltrm$(bin$,"0")
32726 fnend 
32728 ! -------------LIBRARY-------FNDEC2BIN$-------------------------------
32730 def library fndec2bin$*1024(dec)
32732   let fndec2bin$=fndec2bin_$(dec)
32734 fnend 
32740 ! ----------------------------FNBIN2DEC_------------------------------
32742 def fnbin2dec_(bin$*1024)
32744   let bin$=ltrm$(trim$(bin$),"0")
32746   let dec=0
32748   let l=len(bin$)
32750   for i=l to 1 step -1
32752     if bin$(i:i)="1" or bin$(i:i)="0" then !:
            let dec=dec+val(bin$(i:i))*(2**(l-i)) else !:
            let dec=-1: goto L32756
32754   next i
32756 L32756: let fnbin2dec_=dec
32758 fnend 
32760 ! -------------LIBRARY-------FNBIN2DEC--------------------------------
32762 def library fnbin2dec(bin$*1024)
32764   let fnbin2dec=fnbin2dec_(bin$)
32766 fnend 
32768 ! -----------------------------FNHEX2DEC_-----------------------------
32770 def fnhex2dec_(hh$*1024)
32772   let dec=-726 !:
        let dummy$=hex$(hh$) error L32786
32774   let hh$=uprc$(ltrm$(trim$(hh$),"0"))
32776   let dec=0
32778   let l=len(hh$)
32780   for i=l to 1 step -1
32782     if ord(hh$(i:i))<65 then let dec=dec+val(hh$(i:i))*(16**(l-i)) conv L32784 else !:
            let dec=dec+(ord(hh$(i:i))-55)*(16**(l-i))
32784 L32784: next i
32786 L32786: let fnhex2dec_=dec
32788 fnend 
32790 ! -------------LIBRARY-------FNHEX2DEC--------------------------------
32792 def library fnhex2dec(hh$*1024)
32794   let fnhex2dec=fnhex2dec_(hh$)
32796 fnend 
32800 ! ---------------------------FNDEC2HEX_$------------------------------
32802 def fndec2hex_$*1024(dec)
32804   dim hx$*1024
32806   let hx$=""
32808   for i=8 to 0 step -1
32810     let d=int(dec/(16**i))
32812     if d>9 then !:
            let hx$(99:0)=chr$(int(d)+55) else !:
            let hx$(99:0)=str$(int(d))
32814     let dec=dec-d*(16**i)
32816   next i
32818   let hx$=ltrm$(hx$,"0")
32820   if hx$="" then let fndec2hex_$="0" else let fndec2hex_$=hx$
32822 fnend 
32830 ! -------------LIBRARY-------FNDEC2HEX$-------------------------------
32832 def library fndec2hex$*1024(dec)
32834   let fndec2hex$=fndec2hex_$(dec)
32836 fnend 
32840 ! ---------------------------FNPASSWORD$--------------------------------
32842 def fnpassword$
32844   let fnpassword$=str$(int((serial+days(date))/date("d")))
32846 fnend 
32850 def library fnlaunch(external$*80)
32852   dim external$*80
32854   let scr_thaw: let fn_exe('-w',external$,'',str$(serial)&" "&fnpassword$)
32856 fnend 
32860 ! ---------------------------FNOPEN_$-----------------------------------
32862 def fnopen_$*256(def_file$*256;def_dir$*256)
32864   dim dir$*256,files_array$(1)*256,total_list$(1)*256,entry$*256,dir_array$(1)*256,sort_array(1),dir_temp$(1)*256,files_temp$(1)*256
32866   if trim$(def_file$)="" and trim$(def_dir$)="" then let def_file$="*.*"
32868   let fkey(0)
32870   on error system 
32872   if fnwin_gui then 
32874     let fnopen_$=fnwin_open$(def_file$,def_dir$)
32876   else 
32878     let fnopen_$=fnbr_open$(def_file$,def_dir$)
32880   end if 
32882 fnend 
32890 ! -------LIBRARY----------FNOPEN$--------------------------------------
32892 def library fnopen$*256(def_file$*256;def_dir$*256)
32894   let fnopen$=fnopen_$(def_file$,def_dir$)
32896 fnend 
32900 ! ---------------------------Fnbr_Open$-----------------------------------
32905 def fnbr_open$*256(filename$*256,path$*256)
32907   if trim$(filename$)<>"" and trim$(filename$(1:1))<>"*" then !:
          let filename$=fntruepath_$(fn_client_os_path$(filename$)) !:
          let filename$(1:3)=srep$(filename$(1:3),"@::","") !:
          let filename$=fn_client_os_path$(filename$)
32909   if trim$(path$)<>"" then !:
          let path$=os_filename$(fntruepath_$(fn_client_os_path$(path$))) !:
          let path$(1:3)=srep$(path$(1:3),"@::","") !:
          let path$=fn_client_os_path$(path$)
32913   if uprc$(env$("CLIENT_SERVER"))="YES" then 
32915     open #(twin_handle:=fngethandle_): "name=OPEN:@::"&path$&filename$&",recl=1,shr",display,input error RETRY_D_VER
32917     goto X_OPEN
32919 RETRY_D_VER: ! 
32921     if err=626 then 
32923       open #(twin_handle:=fngethandle_): "name=OPEN:"&path$&filename$&",recl=1,shr",display,input error X_FNBR_OPEN
32925     else 
32927       goto X_FNBR_OPEN
32929     end if 
32931   else 
32933     open #(twin_handle:=fngethandle_): "name=OPEN:"&path$&filename$&",recl=1,shr",display,input error RETRY_VER
32935     goto X_OPEN
32937 RETRY_VER: ! 
32938     if err=626 then 
32939       open #(twin_handle:=fngethandle_): "name=OPEN:@::"&path$&filename$&",recl=1,shr",display,input error X_FNBR_OPEN
32941     else 
32943       goto X_FNBR_OPEN
32945     end if 
32947   end if 
32949 X_OPEN: ! 
32951   let filename$=fnwbpath_$(srep$(file$(twin_handle),"@::",""))
32953   if uprc$(env$("CLIENT_SERVER"))="YES" then !:
          let filename$=fn_client_path$(filename$)
32955   close #twin_handle: 
32957 X_FNBR_OPEN: let fnbr_open$=filename$
32959 fnend 
33030 ! --------------------------fnWinScroll--------------------------------
33032 def library fnwinscroll(mat scroll_data$; default_start,scroll_title$*1024,scroll_border$*20,scroll_footer$*256,scroll_scol,scroll_srow,scroll_cols,scroll_rows,display_only,free,use_m2)
33034   gosub SETUP_LIBRARY
33036   gosub SETUP_CONSTANTS
33038   let fnwinscroll=fnwinscroll_(mat scroll_data$, default_start,scroll_title$,scroll_border$,scroll_footer$,scroll_scol,scroll_srow,scroll_cols,scroll_rows,display_only,free,use_m2)
33040 fnend 
33050 def fnwinscroll_(mat scroll_data$; default_start,scroll_title$*1024,scroll_border$*20,scroll_footer$*256,scroll_scol,scroll_srow,scroll_cols,scroll_rows,display_only,free,use_m2)
33055 ! if use_m2 and jbowman then
33060 !   let winscroll_return=fn_winscroll_m2(mat scroll_data$, default_start,scroll_title$,scroll_border$,scroll_footer$,scroll_scol,scroll_srow,scroll_cols,scroll_rows,display_only) ! todo: consider overriding fnwinscroll with fn_winscroll_m2  - works pretty darn well but it doesn't yet support filters or searching.
33065 !   if winscroll_return=-10099 or winscroll_return=-10093 then let fkey(99) : let winscroll_return=max(1,default_start)
33070 !   let fnwinscroll_=winscroll_return
33075 !   goto WINWCROLL_XIT
33080 ! end if  ! use_m2
33085   if ~xml_setup then gosub XML_SETUP
33090   gosub PARSE_TITLE !:
        if udim(mat scroll_data$)=0 and uprc$(env$("Developer"))="YES" then !:
          let fnmessagebox_("fnwinscroll called with mat scroll_Data$ of 0 items, please enhance the calling program to catch this situation.",48,"CLS Developer") !:
          mat scroll_data$(1) !:
        else if udim(mat scroll_data$)=0 then !:
          mat scroll_data$(1)
33095 if ~gridio_setup then gosub GRIDIO_SETUP
33100 if fnwin_gui and trim$(win_pop$)<>"OFF" and (env$("GUIMODE")="OFF" or trim$(scroll_border$)<>"NO POP") then !:
        let fnwinscroll_=fngrid(mat scroll_data$,default_start,grid_title$,scroll_border$,scroll_footer$,grid_heading$,grid_keys$,grid_labels$,scroll_scol,scroll_srow,scroll_cols,scroll_rows,free,display_only) !:
        goto L33530
33105 if env$("GUIMODE")="ON" then !:
        let fnwinscroll_=fngridio(mat scroll_data$,default_start,grid_title$,scroll_border$,scroll_footer$,grid_heading$,grid_keys$,grid_labels$,scroll_scol,scroll_srow,scroll_cols,scroll_rows,free,display_only) !:
        goto L33520 !:
        ! * Clear the Buttons if Appropriate
33110 let crit$=crit10$="" !:
      let crit2$=crit11$="*N/A*"
33115 if scroll_rows=0 and scroll_srow=0 then !:
        let scroll_rows=20 !:
        let scroll_srow=3
33120 if scroll_border$="" then let scroll_border$="S"
33125 if trim$(scroll_border$)="NO-BORDER" then let scroll_border$=""
33130 for scroll_counter=1 to udim(scroll_data$)
33135   let data_length=len(scroll_data$(scroll_counter)) !:
        if data_length>scroll_cols then let scroll_cols=data_length
33140 next scroll_counter
33145 if scroll_cols<len(trim$(scroll_title$)) then !:
        let scroll_cols=len(trim$(scroll_title$))
33150 if scroll_footer$="" then goto L33155
33155 L33155: if display_only=0 then goto L33160 else !:
        goto L33170
33160 L33160: if scroll_footer$<>"" or scroll_rows=udim(scroll_data$) then !:
        goto L33170
33165 if scroll_border$<>"" and scroll_cols>=20 then !:
        let scroll_footer2$="[F2/F10 TO SEARCH]" else !:
        if scroll_border$<>"" then !:
          let scroll_footer2$="[F2/F10]"(1:scroll_cols-1)
33170 L33170: if scroll_scol=0 then !:
        let scroll_scol=int((80-scroll_cols)/2)
33175 if scroll_scol<1 then let scroll_scol=1
33180 if trim$(scroll_border$)<>"" and scroll_scol=1 then let scroll_scol=2
33185 let max_colls=80 !:
      if trim$(scroll_border$)<>"" then let max_colls=79
33190 let max_colls=max_colls-scroll_scol+1 !:
      if scroll_cols>max_colls then let scroll_cols=max_colls
33195 ! ON ERROR GOTO 4090
33200 if scroll_srow=0 and scroll_rows<>0 then !:
        let scroll_srow=int((24-scroll_rows)/2)
33205 if scroll_rows=0 and scroll_srow<>0 then !:
        let scroll_srow=24-scroll_srow
33210 dim nbytes$*100, crit$*50, crit10$*50
33215 let mx=min(scroll_rows,udim(scroll_data$))
33220 dim scroll_form$(1)
33225 mat scroll_form$(mx)
33230 for z=1 to mx !:
        let scroll_form$(z)=str$(z)&",1,C "&str$(scroll_cols)&",[W]T" !:
      next z
33235 let scroll_form$(1)(999:0)="LX" !:
      let scroll_form$(mx)(999:0)="LX"
33240 let scroll_win=fngetwindow_(scroll_scol,scroll_srow,scroll_cols,mx,scroll_title$,scroll_border$,scroll_footer$)
33245 MAIN_WINSCROLL: let curfld(1) !:
      let d_start=default_start !:
      if d_start>udim(scroll_data$)-mx+1 then let curfld(d_start-(udim(scroll_data$)-mx+1)+1)
33250 L33250: if d_start<=1 then let d_start=1 else !:
        if d_start>udim(scroll_data$)-mx+1 then let d_start=udim(scroll_data$)-mx+1
33255 let d_end=min(udim(scroll_data$),d_start+mx-1)
33260 L33260: if display_only then !:
        print #scroll_win,fields mat scroll_form$: mat scroll_data$(d_start:d_end) !:
        goto L33530
33265 L33265: let t_col2=min(scroll_scol+scroll_cols-len(scroll_footer2$),80) !:
      if trim$(scroll_footer2$)<>"" then !:
        print fields str$(min(scroll_srow+mx,24))&","&str$(max(1,(t_col2)-1))&",C,[S]": scroll_footer2$
33270 rinput #scroll_win,select mat scroll_form$,attr '[L]': mat scroll_data$(d_start:d_end) !:
      if cmdkey=93 then let cmdkey(93)
33275 let real_nxtfld=nxtfld !:
      let sel=curfld+d_start-1 !:
      let orig_curfld=curfld
33280 if cmdkey<>2 then goto L33320
33285 WS_SEARCH_F2: if trim$(scroll_footer$)="" and trim$(scroll_border$)<>"" then !:
        print #scroll_win, border scroll_border$: scroll_title$
33290 let open_win2=fngetwindow_(1,24,80,1) !:
      print #open_win2, fields "1,2,c 23": "Enter Search Criteria: " !:
      rinput #open_win2, fields "1,26,c 50,[D]SAe",attr '[A]': crit$ !:
      let crit$=rtrm$(crit$) !:
      close #open_win2: !:
      ! LET LNGTH=LEN(CRIT$)
33295 if crit$="" or (cmdkey=99 or cmdkey=93) then let curfld(orig_curfld) !:
        goto L33260
33300 if crit$<>crit2$ then let n=1
33305 let find_first2=fnfindfirst(mat scroll_data$,crit$,n)
33310 if find_first2>0 then !:
        let default_start=find_first2 !:
        let n=default_start+1 !:
        let crit2$=crit$ else !:
        let n=default_start=udim(scroll_data$)
33315 goto MAIN_WINSCROLL
33320 L33320: if cmdkey<>10 then goto L33360
33325 if trim$(scroll_footer$)="" and trim$(scroll_border$)<>"" then !:
        print #scroll_win, border scroll_border$: scroll_title$
33330 let open_win3=fngetwindow_(1,24,80,1) !:
      print #open_win3, fields "1,2,c 23": "Enter Search Criteria: " !:
      rinput #open_win3, fields "1,26,c 50,[D]SAe",attr '[A]': crit10$ !:
      let crit10$=rtrm$(crit10$) !:
      close #open_win3: 
33335 if crit10$="" or (cmdkey=99 or cmdkey=93) then let curfld(orig_curfld) !:
        goto L33260
33340 if crit10$<>crit11$ then let n10=1
33345 let find_first_ext2=fnfindfirst_ext(mat scroll_data$,crit10$,n10)
33350 if find_first_ext2>0 then !:
        let default_start=find_first_ext2 !:
        let n10=default_start+1 !:
        let crit11$=crit10$ else !:
        let default_start=n10=udim(scroll_data$)
33355 goto MAIN_WINSCROLL
33360 L33360: if cmdkey=90 or (nxtfld=1 and fkey=200) then !:
        gosub PAGE_DOWN: let curfld(1) !:
        goto L33250 else !:
        if cmdkey=91 or (nxtfld=mx and fkey=200) then !:
          gosub PAGE_UP !:
          let curfld(mx) : goto L33250
33365 if fkey=112 then let d_start=1 !:
        let curfld(1) !:
        goto L33250
33370 if fkey=113 then let d_start=udim(scroll_data$)-mx+1 !:
        let curfld(mx) !:
        goto L33250
33375 if fkey=105 and curfld=1 then !:
        gosub DOWN : let curfld(1) : goto L33250 else !:
        if fkey=106 and curfld=mx then !:
          gosub UP : let curfld(mx): goto L33250
33380 if fkey=200 then let curfld(real_nxtfld) !:
        goto L33265
33385 let sel=curfld+d_start-1
33390 ! PAUSE
33395 if (fkey>=0 and fkey<=9) or (fkey>=11 and fkey<=19) then !:
        let fnwinscroll_=sel !:
        goto L33515
33400 if (cmdkey<>99 and cmdkey<>98) then !:
        let curfld(real_nxtfld) !:
        goto L33265 !:
        ! (cmdkey=99 or cmdkey=93) ESC !:
        ! CMDKEY=98 Menu Item Selected
33405 let fnwinscroll_=default_start : goto L33515
33410 PAGE_UP: let count=mx !:
      if fkey=200 then let count/=2
33415 do until (count-=1)<=0 or d_start>=udim(scroll_data$)-mx+1
33420   let d_start+=1
33425   if d_start<=1 then let d_start=1 else !:
          if d_start>udim(scroll_data$)-mx+1 then !:
            let d_start=udim(scroll_data$)-mx+1
33430   let d_end=d_start+mx-1
33435   print #scroll_win,fields mat scroll_form$: mat scroll_data$(d_start:d_end)
33440 loop 
33445 return 
33450 PAGE_DOWN: let count=mx !:
      if fkey=200 then let count/=2
33455 do until (count-=1)<=0 or d_start<=1
33460   let d_start-=1
33465   if d_start<=1 then let d_start=1 else !:
          if d_start>udim(scroll_data$)-mx+1 then let d_start=udim(scroll_data$)-mx+1
33470   let d_end=d_start+mx-1
33475   print #scroll_win,fields mat scroll_form$: mat scroll_data$(d_start:d_end)
33480 loop 
33485 return 
33490 DOWN: let d_start-=1
33495 return 
33500 UP: let d_start+=1
33505 return 
33510 ! LET FNMESSAGEBOX("Invalid Row or Column Specification",0,"Warning"): LET FNWINSCROLL_=0: GOTO 5001
33515 L33515: if free=0 then close #scroll_win: else close #scroll_win,free: 
33520 L33520: if trim$(grid_keys$)<>"" and trim$(grid_labels$)<>"" then !:
        display buttons "1,1,C 80": "" !:
        print fields "24,1,C 80,[W]": ""
33525 WINWCROLL_XIT: ! 
33530 L33530: fnend  ! fnwinscroll_
33540 ! --------------------------FNGETWINDOW_-------------------------------
33545 def fngetwindow_(_scol,_srow,_cols,_rows;title$*200,border$,footer$*120)
33550   let next_file_handle=200
33555   let title$=srep$(title$,",",".")
33560   if trim$(title$)<>"" then let title$=",Tab="&title$
33565 GW_NEXT_HANDLE: ! 
33570   let next_file_handle-=1
33575   if trim$(file$(next_file_handle))<>"" then goto GW_NEXT_HANDLE
33580   if border$<>"" then 
33585     open #next_file_handle: "SCol="&str$(_scol)&",SRow="&str$(_srow)&",cols="&str$(_cols)&",rows="&str$(_rows)&",border="&border$&title$,display,outin 
33590   else 
33595     open #next_file_handle: "SCol="&str$(_scol)&",SRow="&str$(_srow)&",cols="&str$(_cols)&",rows="&str$(_rows)&title$,display,outin 
33600   end if  ! border$<>""   /   else 
33605   let t_col=min(_scol+_cols-len(footer$),80)
33610   print fields str$(min(_srow+_rows,24))&","&str$(max(1,(t_col)))&",C,": footer$
33615   print #next_file_handle: newpage
33620   input #next_file_handle,select "1,1,C 1,g": dummy$
33625   goto GW_XIT
33630   let next_file_handle=0
33635 GW_XIT: ! 
33640   let fngetwindow_=next_file_handle
33645 fnend 
33650 ! -------LIBRARY------------FNGETWINDOW()------------------------------
33652 def library fngetwindow(_scol,_srow,_cols,_rows;title$*120,border$,footer$*120)
33654   let fngetwindow=fngetwindow_(_scol,_srow,_cols,_rows,title$,border$,footer$)
33656 fnend 
33660 ! --------------------------FNGETFORM_ARR()----------------------------
33665 def fngetformarr(filename$*80,mat data$,mat data,mat fieldsc$,mat fieldsn$,mat form$,mat form1$;mat desc_c$,mat desc_n$,mat f_seq$,mat f_valid$)
33670 !  This function will support NO MORE than 300 items in a SQL file!
33675   mat desc_c$(1)=("Unknown") !:
        mat desc_n$(1)=("Unkown")
33680   dim f_seq_unord$(1)*80, f_valid_unord$(1)*80
33685   if filename$='SCREEN7' then !:
          let form_file=fngetdisplay_(fn_screen7_sql$) !:
        else !:
          let form_file=fngetdisplay_(filename$&"/SQL")
33690   if form_file<=0 then !:
          print "WARNING FNGETFORM$ PASSED INVALID FILE:";filename$ !:
          let kstat$(1) !:
          goto L33900
33695   let k=0: let l=0
33700 ! LET PS=1
33705   let i=1
33710   let p=0: let p1=0
33715 L33715: linput #form_file: line$ eof L33865 !:
        if trim$(line$)="" then goto L33715
33720   if uprc$(trim$(line$(86:102)))="X" then goto L33715 !:
          !  ** X Spec is just filler (Ignore)
33725   let f$(i)=trim$(line$(1:29)) !:
        let f_name$(i)=trim$(line$(31:66)) !:
        let f_pos(i)=val(line$(68:74)) !:
        let f_len(i)=val(line$(77:83)) !:
        let f_type$(i)=trim$(line$(86:102))
33730   mat f_seq_unord$(i) !:
        let f_seq_unord$(i)=trim$(line$(106:108))
33735   mat f_valid_unord$(i) !:
        let f_valid_unord$(i)=trim$(line$(111:127))
33740   if len(f_valid_unord$(i)) = 0 then 
33745     if f_type$(i) = "C" then let f_valid_unord$(i) = "TEXT"
33750     if f_type$(i) = "N" then let f_valid_unord$(i) = "NUMBER"
33755     if f_type$(i)(1:1) = "B" then let f_valid_unord$(i) = "NUMBER"
33760     if pos(f_type$(i), "PIC(") > 0 then let f_valid_unord$(i) = f_type$(i)
33765     if f_type$(i) = "PD" then let f_valid_unord$(i) = "NUMBER"
33770     if len(f_valid_unord$(i)) = 0 then let f_valid_unord$(i) = "NUMBER"
33775   end if 
33780   if i=1 then !:
          let p=f_pos(i): let p1=f_pos(i): let ll=f_len(i): let ll1=f_len(i)
33785   if f_type$(i)(1:1)="C" then !:
          goto L33790 else !:
          if f_type$(i)="PIC(##/##/##)" or f_type$(i)="PIC(########)" or f_type$(i)="PIC(####/##/##)" then goto L33840 else goto L33850
33790 L33790: let k+=1
33795   mat fieldsc$(k)
33800   let fieldsc$(k)=f$(i)
33805   mat form$(k,3)
33810   mat desc_c$(k)
33815   let form$(k,1)=str$(f_pos(i))
33820   let form$(k,2)=f_type$(i)
33825   let form$(k,3)=str$(f_len(i))
33830   let desc_c$(k)=f_name$(i)
33835   goto L33855
33840 L33840: let k+=1 : mat fieldsc$(k): let fieldsc$(k)=f$(i) !:
        mat form$(k,3) !:
        mat desc_c$(k) !:
        let form$(k,1)=str$(f_pos(i)) !:
        let form$(k,2)=f_type$(i) !:
        let desc_c$(k)=f_name$(i)
33845   goto L33855
33850 L33850: let l+=1: mat fieldsn$(l): let fieldsn$(l)=f$(i) !:
        mat form1$(l,3) !:
        mat desc_n$(l) !:
        let form1$(l,1)=str$(f_pos(i)) !:
        let form1$(l,2)=f_type$(i) !:
        let form1$(l,3)=str$(f_len(i)) !:
        let desc_n$(l)=f_name$(i)
33855 L33855: if f_type$(i)(1:1)="C" then !:
          let p=f_pos(i): let ll=f_len(i) else !:
          if f_type$(i)="PIC(##/##/##)" or f_type$(i)="PIC(########)" then !:
            let p=f_pos(i): let ll=f_len(i) else !:
            let p1=f_pos(i): let ll1=int(f_len(i))
33860   let i+=1 : if i>999 then goto L33865 else goto L33715
33865 L33865: let n_selected=k: let n_selected1=l
33870   mat data$(n_selected) : mat data(n_selected1)
33875   mat f_seq_ord(udim(mat f_seq_unord$)) = aidx(f_seq_unord$) !:
        mat f_seq$(udim(mat f_seq_ord)) !:
        mat f_valid$(udim(mat f_seq_ord))
33880   for iter = 1 to udim(mat f_seq_ord)
33885     let f_seq$(iter) = f$(f_seq_ord(iter)) !:
          let f_valid$(iter) = f_valid_unord$(f_seq_ord(iter))
33890   next iter
33895   close #form_file: 
33900 L33900: fnend 
33910 ! ---------LIBRARY-----------FNGETFORM_ARR()---------------------------
33912 def library fnget_formarr(filename$*80,mat data$,mat data,mat fieldsc$,mat fieldsn$,mat form$,mat form1$;mat desc_c$,mat desc_n$,mat f_seq$,mat f_valid$)
33914   let fnget_formarr=fngetformarr(filename$,mat data$,mat data,mat fieldsc$,mat fieldsn$,mat form$,mat form1$,mat desc_c$,mat desc_n$,mat f_seq$,mat f_valid$)
33916 fnend 
33920 ! ---------LIBRARY--------FNSQL_DATATYPE$------------------------------
33922 def library fnsql_datatype$*80(field_name$*80, mat f_seq$, mat f_valid$)
33924   let mypos = srch(f_seq$, field_name$)
33926   if mypos < 0 then !:
          let fnsql_datatype$ = "UNDEF" !:
        else !:
          let fnsql_datatype$ = f_valid$(mypos)
33928 fnend 
33930 ! ---------LIBRARY--------FNSQL_REPORT---------------------------------
33935 def library fnsql_report$(&rep_var$,mat data$,mat data,mat _fc$,mat _fn$;filename$*10,&loc)
33940 ! ** Note: This is a very simply version of the "FNSQL_PRINT" command!:
        ! ** Formating is limited!:
        ! ** The purpose of this command is to be used in "Unformated Situations"
33945   dim rep_var$*80
33950   let rep_var$=srep$(srep$(uprc$(rep_var$),filename$&".",""),"\","")
33955 ! Pause
33960   if (lib_search:=srch(mat _fc$,rep_var$))>0 then !:
          let rep_var$=data$(lib_search) !:
          let fnsql_report$="C" !:
          goto L33965 else !:
          goto L33975
33965 L33965: if pos(trim$(_fc$(lib_search)),"DATE")>0 then !:
          let rep_var$=fnget_date10$(rep_var$) !:
          let fnsql_report$="D"
33970   goto L33985
33975 L33975: if (lib_search:=srch(mat _fn$,rep_var$))>0 then !:
          let rep_var$=str$(data(lib_search)) !:
          let fnsql_report$="N" !:
          goto L33985
33980   let fnsql_report$="" !:
        ! ** Unkown Variable Type
33985 L33985: let loc=lib_search
33990 fnend 
34000 ! -------------------------FNGET_RECORD---------------------------------
34005 ! 
34010 def fngetrecord(fileno,mat data$,mat data,&fformc$,&fformn$,which_rec$,skip_message)
34015   dim err_message$*512,err_variable$*80,err_file$*80
34020   let tab$=chr$(9)
34025   let get_record=err_err=0
34030   if which_rec$="" or which_rec$="NEXT" then !:
          read #fileno,using fformc$,next,release: mat data$ eof L34085 ioerr L34050 !:
          let get_record=1
34035   if which_rec$="SAME" then !:
          read #fileno,using fformc$,same,release: mat data$ eof L34085 ioerr L34050 !:
          let get_record=1
34040   if which_rec$="PRIOR" then !:
          read #fileno,using fformc$,prior,release: mat data$ eof L34085 ioerr L34050 !:
          let get_record=1
34045   reread #fileno,using fformn$,release: mat data ioerr L34050 !:
        goto L34090
34050 L34050: let err_variable$=variable$: let err_cnt=cnt !:
        let err_line=line: let err_err=err !:
        let err_message$="Error: "&str$(err_err)&" occurred reading Data File\n"&file$(fileno)&"\nREC="&str$(rec(fileno))&"\nCount="&str$(err_cnt)&"\nSyserr="&str$(syserr)&" "&syserr$ !:
        let nslash=pos(file$(fileno),"\",-1) !:
        let err_file$="" !:
        if nslash>0 then let err_file$=file$(fileno)(nslash+1:999)
34055   let io_headings=0 !:
        if ~exists("IOERROR.LOG") then !:
          let io_headings=1
34060   open #(iolog_handle:=fngethandle_): "NAME=IOERROR.LOG,USE,RECL=5000",display,output ioerr L34080 !:
        if io_headings then print #iolog_handle: "DATE";tab$;"TIME";tab$;"PROGRAM";tab$;"ERROR";tab$;"LINE";tab$;"HANDLE";tab$;"RECORD";tab$;"VARIABLE";tab$;"COUNT";tab$;"DATAFILE";tab$;"DATA$(1)";tab$;"WSID";tab$;"LOGIN NAME";tab$;"DESCRIPTION"
34065   print #iolog_handle: date$("MM/DD/CCYY");tab$;time$;tab$;program$;tab$;err_err;tab$;err_line;tab$;fileno;tab$;rec(fileno);tab$;err_variable$;tab$;err_cnt;tab$;file$(fileno);tab$;data$(1);tab$;wsid$;tab$;login_name$;tab$;err_message$
34070   close #iolog_handle: 
34075   if err_err=58 and pos(file$(fileno),"CLERKF")>0 then execute 'STATUS' !:
          print "ERROR 58 IN CLERK - CALL 1-800-435-7257" !:
          pause 
34080 L34080: if ~skip_message then !:
          let fnmessagebox_(err_message$,48,"Error Reading File") else !:
          print bell; !:
          let msg$("Err:"&str$(err_err)&" Line:"&str$(err_line)&" "&err_file$&" "&str$(rec(fileno))) !:
          print bell;
34085 L34085: let get_record=-err_err
34090 L34090: let fngetrecord=get_record
34095 fnend 
34100 ! ---------LIBRARY-------FNGETNEXT------------------------------------
34102 def library fnget_record(fileno,mat data$,mat data,&fformc$,&fformn$;which_rec$,skip_message)
34104   let fnget_record=fngetrecord(fileno,mat data$,mat data,fformc$,fformn$,which_rec$,skip_message)
34106 fnend 
34110 ! -------------------------FNGETSEARCH---------------------------------
34112 ! 
34114 def fngetsearch(fileno,key$*128,mat data$,mat data,&fformc$,&fformn$;search_operator$)
34116   let getsearch=0
34118   read #fileno,using fformc$,search>=key$,release: mat data$ ioerr L34122 ! rtrm$ changed from trim$ on 10/20/00 for venueidx srch !:
        let getsearch=1 !:
        ! ** Note: This was "RTRM$" of Key$ !:
        ! ** if RTRM is desired, then the calling program MUST trim it!:
        ! ** This was causing BH and other numeric searches to fail
34120   reread #fileno,using fformn$,release: mat data ioerr L34122 !:
        goto L34124
34122 L34122: let getsearch=-err
34124 L34124: let fngetsearch=getsearch
34126 fnend 
34130 ! ---------LIBRARY-------FNGETSEARCH----------------------------------
34132 def library fnget_search(fileno,key$*40,mat data$,mat data,&fformc$,&fformn$)
34134   let fnget_search=fngetsearch(fileno,key$,mat data$,mat data,fformc$,fformn$)
34136 fnend 
34140 ! ---------LIBRARY-------FNTRUE$---------------------------------------
34142 def library fntrue$(amt)
34144   if amt then !:
          let fntrue$="T" else !:
          let fntrue$="F"
34146 fnend 
34150 ! ---------LIBRARY---------FNYES$---------------------------------------
34152 def library fnyes$(amt)
34154   if amt then !:
          let fnyes$="Y" else !:
          let fnyes$="N"
34156 fnend 
34160 def fnabout_$(dummy$)
34162   dim about_message$*256
34164   let about_message$='Collection-Master for Windows'
34166   if trim$(env$("Server_Label"))<>"" then !:
          let about_message$=trim$(srep$(env$("Server_Label"),"_"," "))
34168   let fnmessagebox_("Copyright Commercial Legal Software"&chr$(10)&"Version: "&fnversion_$&chr$(10)&"Language:"&wbplatform$&" "&fnos$&" "&wbversion$&" - WSID:"&wsid$&chr$(10)&"Licensed to:"&userid$&chr$(10)&"Serial #:"&str$(serial)&chr$(10)&"                       ",64,about_message$)
34170 fnend 
34180 def library fnabout$(dummy$)
34182   let fnabout$=fnabout_$(dummy$)
34184 fnend 
34186 def library fnversion$
34188   let fnversion$=fnversion_$
34190 fnend 
34200 VERSION: def fnversion_$
34202   let fnversion_$="8.1I.010"
34204 fnend 
34210 ! -------LIBRARY------------FNIOERR-------------------------------------
34220 def library fnioerr(mat error$,mat error)
34230   mat error$(2) !:
        mat error(5)
34240   let error$(1)=program$ !:
        let error$(2)=variable$ !:
        let error(1)=err !:
        let error(2)=line !:
        let error(3)=cnt !:
        let error(4)=filenum
34250 fnend 
34260 ! -------------------FNLEFT_PAD$------------------------------------
34262 def library fnleft_pad$*512(str_original$*60,str_length,pad_with$)
34264   dim temp_pad$*512
34266   let temp_pad$=""
34268   for pad_count=1 to str_length-len(str_original$)
34270     let temp_pad$=pad_with$&temp_pad$
34272   next pad_count
34274   let fnleft_pad$=temp_pad$&str_original$
34276 fnend 
34280 ! ------------------FNGET_DIR-----------------------------------------
34282 def library fnget_dir(dir_path$*256,mat dirs$,mat files$,mat size,mat dait$;long$)
34284   gosub SETUP_CONSTANTS
34286   let fnget_dir=fngetdir(dir_path$,mat dirs$,mat files$,mat size,mat dait$,long$)
34288 fnend 
34290 def fngetdir(dir_path$*256,mat dirs$,mat files$,mat size,mat dait$,long$)
34295   dim gdir$(1)*128,gfile$*128,gdir$*128,gsize,gdait$*128
34300   mat dirs$=("") : mat files$=("")
34305   let fstart=1 : let fend=10 !:
        let fext1=11 : let fext2=13 !:
        let fstartl=46 : let fendl=999 !:
        if uprc$(long$)="Y" then !:
          let fstart=46: let fend=999 !:
          let fext1=100: let fext2=100
34310   if uprc$(trim$(long$))="B" then let minusbee=1 : let long$="Y" else let minusbee=0
34315   let nslash=pos(dir_path$,"\",-1)
34320   if nslash>0 and ~exists(dir_path$(1:nslash)) and uprc$(env$("Debug"))="YES" and env$("GUIMode")="ON" then 
34325 !   if debug then print 'fnget_dir: '&dir_path$&' is invalid.'
34330 !   if developer then pause
34335     goto GETDIR_FINIS
34340   end if  ! nslash>0 and ~exists(dir_path$(1:nslash)) and uprc$(env$("Debug"))="YES" and env$("GUIMode")="ON"
34345   execute '*dir "'&trim$(dir_path$)&'" -o >[Temp]DIR-[Session].TXT' ioerr GET_DIR_XIT
34350   let fnasci_('[Temp]DIR-[Session].TXT',mat gdir$)
34355   let fcount=dcount=0 !:
        for tgdir=2 to udim(gdir$) !:
          let gdir$(tgdir)=uprc$(gdir$(tgdir))
34360     if trim$(gdir$(tgdir))(1:1)="." or pos(uprc$(gdir$(tgdir)),"BYTES USED,")>0 or trim$(gdir$(tgdir))="" then goto NEXT_TGDIR
34365     if uprc$(long$)="Y" then !:
            let gfile$=trim$(gdir$(tgdir)(fstartl:fendl)) else !:
            if trim$(gdir$(tgdir)(fstart:fext2))="" then !:
              let gfile$=fngetshortname$(dir_path$,trim$(gdir$(tgdir)(fstartl:fendl))) else !:
              let gfile$=trim$(gdir$(tgdir)(fstart:fend))&"."&trim$(gdir$(tgdir)(fext1:fext2))
34370     let gdait$=gdir$(tgdir)(27:34) !:
          let gsize=0 !:
          let gsize=val(gdir$(tgdir)(14:22)) conv L34375 !:
          if uprc$(gdir$(tgdir))(24:25)="KB" then let gsize*=1024 else !:
            if uprc$(gdir$(tgdir))(24:25)="MB" then let gsize*=(1024*1000)
34375 L34375: if pos(uprc$(gdir$(tgdir)),"<DIR>")>0 then 
34380       mat dirs$(dcount+=1) !:
            let npos=pos(gfile$,".",-1) !:
            if npos<=0 then let npos=len(gfile$)+1
34385       if uprc$(long$)="Y" then !:
              let dirs$(dcount)=gfile$ !:
            else !:
              let dirs$(dcount)=rtrm$(rtrm$(gfile$),".") !:
              ! ** Short Name will have a ".", trim space and "." from the name
34390     else 
34395       mat files$(fcount+=1): mat size(fcount): mat dait$(fcount)
34400       let files$(fcount)=gfile$ !:
            let size(fcount)=gsize !:
            let dait$(fcount)=gdait$
34405     end if 
34410 NEXT_TGDIR: ! 
34415   next tgdir
34420 GETDIR_FINIS: ! 
34425   if minusbee then let fngetdir_minusbee(dir_path$,mat dirs$,mat files$,mat size,mat dait$)
34430   let fngetdir=fcount
34435 GET_DIR_XIT: ! 
34440   if udim(mat dirs$)=1 and trim$(dirs$(1))="" then mat dirs$(0)
34445   if udim(mat files$)=1 and trim$(files$(1))="" then mat files$(0)
34450   if udim(mat size)=1 and udim(mat files$)=0 and size(1)=0 then mat size(0)
34455   if udim(mat dait$)=1 and trim$(dait$(1))="" then mat dait$(0)
34460 fnend 
34470 !   [----------------- FNSETUPFEE -------------------------]
34472 def library fnsetup_fee(mat low,mat high,mat fees$,mat rates$,mat sher_rates$)
34474   let fnsetup_fee=fnsetup_fee_(mat low,mat high,mat fees$,mat rates$,mat sher_rates$)
34476 fnend 
34480 def fnsetup_fee_(mat low,mat high,mat fees$,mat rates$,mat sher_rates$)
34485   mat low(10) !:
        mat high(10) !:
        mat fees$(10) !:
        mat rates$(24) !:
        mat sher_rates$(10)
34490 L34490: let setupfee_handle=fngetdisplay_("SETUPFEE.INI//8") !:
        if setupfee_handle=0 then !:
          let fnmessagebox_("WARNING SETUPFEE.INI//8 NOT SETUP!\nSystem Will now Create Fee Scales",16,"SETUPFEE.INI//8") !:
          library "setupfee/prog2": fnsetupfee !:
          let fnsetupfee !:
          goto L34490
34495   let buff$="" !:
        linput #setupfee_handle: buff$ eof L34500 !:
        let fnlist_(buff$,mat fees$,chr$(9)) : mat fees$(10) !:
        for nloop=1 to 10: let low(nloop)=val(fees$(nloop)) conv L34500
34500 L34500: next nloop
34505   let buff$="" !:
        linput #setupfee_handle: buff$ eof L34510 !:
        let fnlist_(buff$,mat fees$,chr$(9)) : mat fees$(10) !:
        for nloop=1 to 10: let high(nloop)=val(fees$(nloop)) conv L34510
34510 L34510: next nloop
34515   mat fees$=("") !:
        for nloop=1 to 10
34520     if high(nloop)<9999999 and (low(nloop) <>0 or high(nloop)<>0) then !:
            let fees$(nloop)=cnvrt$('PIC($,$$$,$$$.##-)',low(nloop))&" - "&cnvrt$('PIC($,$$$,$$$.##-)',high(nloop))&":"
34525     if high(nloop)>=9999999 then !:
            let fees$(nloop)=cnvrt$('PIC($,$$$,$$$.##-)',low(nloop))&" &   Over       :"
34530   next nloop
34535 L34535: linput #setupfee_handle: buff$ eof L34555
34540   if buff$(1:10)="SHER_RATES" then let sher_rate_num=val(buff$(11:12)) conv L34535 !:
          let sher_rates$(sher_rate_num)=buff$(14:99)
34545   if buff$(1:5)="RATES" then let rate_num=val(buff$(6:7)) conv L34535 !:
          let rates$(rate_num)=buff$(9:99)
34550   goto L34535
34555 L34555: close #setupfee_handle: ioerr L34555
34560 fnend  ! fnsetup_fee_
34570 def library fnrewrite_fee(mat new_low,mat new_high,mat new_fees$,mat new_rates$,mat new_sher_rates$)
34575   open #(rewritefee_handle:=fngethandle_): "NAME=SETUPFEE.INI//8,recl=8000,replace",display,output 
34580   print #rewritefee_handle: "LOW:"; !:
        for z=1 to udim(new_low)-1 : print #rewritefee_handle: new_low(z);chr$(9);: next z !:
        print #rewritefee_handle: new_low(udim(new_low))
34585   let z=1
34590   print #rewritefee_handle: "HIGH:"; !:
        for z=1 to udim(new_low)-1 : print #rewritefee_handle: new_high(z);chr$(9);: next z !:
        print #rewritefee_handle: new_high(udim(new_low))
34595   let z=1
34600   for z=1 to 24
34605     print #rewritefee_handle: "RATES"&cnvrt$('PIC(##)',z)&":";new_rates$(z)
34610   next z
34615   for z=1 to 10
34620     print #rewritefee_handle: "SHER_RATES"&cnvrt$('PIC(##)',z)&":";new_sher_rates$(z)
34625   next z
34630   close #rewritefee_handle: 
34635 fnend  ! fnrewrite_fee
34640 def fn_mbx_size(&mbxs_message$,&mbxs_rows,&mbxs_cols) ! mbxs_
34645   dim mbxs_line$(1)*1024
34650   let str2mat(mbxs_message$,mat mbxs_line$) ! ,LF$ is not needed because STR2MAT checks all types or LF
34655   let mbxs_rows=udim(mat mbxs_line$)
34660   let mbxs_cols=0
34665   for mbxs_line_item=1 to mbxs_rows
34670     let mbxs_cols=max(mbxs_cols,len(mbxs_line$(mbxs_line_item)))
34675     let mbxs_cols+=fn_chr_count(mbxs_line$(mbxs_line_item),tab$)*4
34680   next mbxs_line_item
34685   if mbxs_cols>140 then 
34690     let mbxs_cols=ceil(mbxs_cols*.78)
34695   else if mbxs_cols>90 then 
34700     let mbxs_cols=ceil(mbxs_cols*.82)
34705   else if mbxs_cols>60 then 
34710     let mbxs_cols=ceil(mbxs_cols*.86)
34715   else if mbxs_cols>30 then 
34720     let mbxs_cols=ceil(mbxs_cols*.90)
34725 ! else 
34730 !   let mbxs_cols=ceil(mbxs_cols*1.0)
34735   end if 
34740   let mbxs_cols=max(mbxs_cols,10)
34745   let mbxs_cols+=13
34750 fnend  ! fn_mbx_size
34760 def fn_mbx_button_default(&mbx_type)
34765   if mbx_type>=mb_button3_default then 
34770     let mbx_type-=mb_button3_default
34775     let mbx_button_default=3
34780   else if mbx_type>=mb_button2_default then 
34785     let mbx_type-=mb_button2_default
34790     let mbx_button_default=2
34795   else 
34800     let mbx_button_default=1
34805   end if  ! mbx_type
34810   let fn_mbx_button_default=mbx_button_default
34815 fnend  ! fn_mbx_button_default
34820 def fn_mbx_icon$(&mbx_type)
34825   if mbx_type>=mb_information then 
34830     let mbx_type-=mb_information
34835     let mbx_icon$='information'
34840   else if mbx_type>=mb_exclamation then 
34845     let mbx_type-=mb_exclamation
34850     let mbx_icon$='exclamation'
34855   else if mbx_type>=mb_question then 
34860     let mbx_type-=mb_question
34865     let mbx_icon$='question'
34870   else if mbx_type>=mb_stop then 
34875     let mbx_type-=mb_stop
34880     let mbx_icon$='stop'
34885   else 
34890 !   if developer or debug then print bell;'no icon selected for messagegox - default of "information" will be used.'
34895 !   if developer then pause
34900     let mbx_icon$='information'
34905   end if 
34910   let fn_mbx_icon$=mbx_icon$
34915 fnend  ! fn_mbx_icon$
34920 def fn_mbx_button(&mbxb_type,&mbxb_button_text$,mat mbxb_button_return) ! mbxb_
34925   mat mbxb_button_return(1) : let mbxb_button_text$="?"&str$(mbxb_type): let mbxb_button_return(1)=mb_ok
34930   let mbxb_button_text$=''
34935   if mbxb_type>=mb_retrycancel then 
34940     let mbxb_type-=mb_retrycancel : let mbxb_button_text$='Retry;Cancel' !:
          mat mbxb_button_return(2) : let mbxb_button_return(1)=mb_retry !:
          let mbxb_button_return(2)=mb_cancel : let mb_x=mb_cancel
34945   else if mbxb_type>=mb_yesno then 
34950     let mbxb_type-=mb_yesno
34955     let mbxb_button_text$='Yes;No'
34960     mat mbxb_button_return(2) : let mbxb_button_return(1)=mb_yes !:
          let mbxb_button_return(2)=mb_no : let mb_x=mb_no
34965   else if mbxb_type>=mb_yesnocancel then 
34970     let mbxb_type-=mb_yesnocancel
34975     let mbxb_button_text$='Yes;No;Cancel'
34980     mat mbxb_button_return(3) : let mbxb_button_return(1)=mb_yes !:
          let mbxb_button_return(2)=mb_no : let mbxb_button_return(3)=mb_cancel !:
          let mb_x=mb_cancel
34985   else if mbxb_type>=mb_abortretryignore then 
34990     let mbxb_type-=mb_abortretryignore
34995     let mbxb_button_text$='Abort;Retry;Ignore'
35000     mat mbxb_button_return(3) : let mbxb_button_return(1)=mb_abort !:
          let mbxb_button_return(2)=mb_retry : let mbxb_button_return(3)=mb_ignore !:
          let mb_x=mb_abort
35005   else if mbxb_type>=mb_okcancel then 
35010     let mbxb_type-=mb_okcancel
35015     let mbxb_button_text$='OK;Cancel'
35020     mat mbxb_button_return(2) : let mbxb_button_return(1)=mb_ok !:
          let mbxb_button_return(2)=mb_cancel : let mb_x=mb_cancel
35025   else 
35030     mat mbxb_button_return(1) : let mbxb_button_return(1)=mb_ok
35035     let mbxb_type-=mb_okonly
35040     let mbxb_button_text$='OK' !:
          let mb_x=mb_ok
35045   end if 
35050   let fn_mbx_button=udim(mat mbxb_button_return)
35055 fnend  ! fn_mbx_button
35060 ! [-------------- Printer Utilities ---------------------]
35065 def library fnwin_printers(mat win_printers$)
35070   dim twin_printers$(1)*300,twin_buff$*300
35075   mat twin_printers$(1)=("") !:
        let twin_printers=0
35080   let no_win=printer_list(mat win_printers$) !:
        ! ** PRINTER_LIST is a WB Command that populates mat WIN_PRINTERS$ with the valid printers !:
        ! LET NO_WIN=UDIM(WIN_PRINTERS$) <<--- This is simply wrong
35085   for twin=1 to no_win
35090     let twin_at=pos(win_printers$(twin),"@") !:
          let twin_buff$="" !:
          if twin_at>0 then let twin_buff$=win_printers$(twin)(twin_at+1:999)
35095     if twin_buff$(1:2)="\\" then goto L35110
35100     if twin_buff$(1:3)="LPT" then goto L35110
35105     if trim$(twin_buff$)="LAN" or pos(twin_buff$,"FAX")>0 then let twin_buff$=""
35110 L35110: if len(twin_buff$)<=55 then goto L35130
35115     if pos(trim$(win_printers$(twin)(1:twin_at-1)(1:55))," ")<=0 then let twin_printers+=1 !:
            mat twin_printers$(twin_printers) !:
            let twin_printers$(twin_printers)="WIN:/"&win_printers$(twin)(1:twin_at-1)(1:55) !:
            goto L35135
35120     if len(twin_buff$)<=24 then let twin_printers+=1 !:
            mat twin_printers$(twin_printers) !:
            let twin_printers$(twin_printers)=":"&twin_buff$ !:
            goto L35135
35125     let twin_buff$=""
35130 L35130: if trim$(twin_buff$)<>"" then let twin_printers+=1 !:
            mat twin_printers$(twin_printers) !:
            let twin_printers$(twin_printers)="WIN:/"&twin_buff$
35135 L35135: next twin
35140   if twin_printers=0 then let twin_printers=1 !:
          let twin_printers$(1)=("WIN:/LPT1:")
35145   mat win_printers$(twin_printers)=twin_printers$
35150 fnend 
35155 def library fnsub_dir(mat sfiles$,def_dir$*80,dir_filter$*80)
35160   mat sfiles$(0)=("") !:
        let sfiles=0 !:
        let dir_filter$=srep$(dir_filter$,"*","")
35165   dim dirs$(1)*128,dir_queue$(1)*132,files$(1)*128,size(1),dait$(1)*10,cur_dir$*128,def_dir$*128,this_dir$*128
35170   let def_dir$=rtrm$(def_dir$) !:
        let def_dir$=rtrm$(def_dir$,"\") !:
        let nslash=pos(def_dir$,"\",-1)
35175   let dir_queue=1 !:
        mat dir_queue$(1) !:
        let dir_queue$(1)=""
35180 L35180: if dir_queue<=0 then goto L35255
35185   let this_dir$=dir_queue$(dir_queue) !:
        let dir_queue-=1 !:
        mat dir_queue$(dir_queue)
35190   let cur_dir$=this_dir$
35195   let msg$(cur_dir$)
35200   mat dirs$(0)=("") !:
        mat files$(0)=("")
35205   let ndir=fngetdir(def_dir$&cur_dir$&"\*.*",mat dirs$,mat files$,mat size,mat dait$,"Y")
35210   for n=1 to udim(dirs$)
35215     if dirs$(n)(1:1)="_" then goto L35225
35220     let dir_queue+=1 !:
          mat dir_queue$(dir_queue) !:
          let dir_queue$(dir_queue)=this_dir$&"\"&dirs$(n)
35225 L35225: next n
35230   for n=1 to udim(files$) !:
          let npos=pos(uprc$(files$(n)),".",-1) !:
          if npos<=0 then let npos=len(files$(n))+1
35235     if uprc$(files$(n)(npos:999))<>uprc$(trim$(dir_filter$)) then goto L35245
35240     let sfiles+=1 !:
          mat sfiles$(sfiles) !:
          let sfiles$(sfiles)=cur_dir$&"\"&files$(n)
35245 L35245: next n
35250   goto L35180
35255 L35255: let fnsub_dir=udim(sfiles$)
35260 fnend 
35270 def library fnlist_print_pause(mat lpp_handle; handle_current,lpp_button_retain,close_after_view,lpp_timeout,&lpp_mstart)
35272   gosub SETUP_LIBRARY
35274   gosub SETUP_CONSTANTS
35276   let fnlist_print_pause=fn_list_print_pause(mat lpp_handle, handle_current,lpp_button_retain,close_after_view,lpp_timeout,lpp_mstart)
35278 fnend 
35280 def fn_list_print_pause(mat lpp_handle; handle_current,lpp_button_retain,close_after_view,lpp_timeout,&lpp_mstart) ! lpp_
35285 ! mat lpp_handle - array of handles for fnList_Print windows
35290 ! Handle_Current - The fnList_Print window that should initially have focus
35295 ! lpp_Button_Retain - if 0 buttons will be overwritten and removed afterward, if 1 this function will leave your buttons alone.
35300 ! Close_After_View - will close all handles passed to the function after the pause
35305 ! lpp_timeout - if greater than 0 the pause will timeout and continue on after this amount of time, returning a FKey=101
35310 ! lpp_mstart - if greater than 0 the selected line will default to this line
35315   let tab_change=92
35320   for lpp_handle_item=udim(mat lpp_handle) to 1 step -1
35325     if lpp_handle(lpp_handle_item)=0 then 
35330       let fnremovearrayitem(mat lpp_handle,lpp_handle_item)
35335     end if  ! lpp_handle(lpp_handle_item)=0
35340   next lpp_handle_item
35345   if handle_current=0 and udim(mat lpp_handle)>0 then let handle_current=lpp_handle(1)
35350   if srch(mat lpp_handle,handle_current)<=0 and udim(mat lpp_handle)>0 then let handle_current=lpp_handle(1) ! if the call to the program was incorrect and they did not pass a real file number for the current_handle than use the first one instead.
35355   if file(handle_current)=-1 then goto XIT_FNLIST_PRINT_PAUSE
35360   if lpp_button_retain=0 then 
35365     gosub ERASE_BUTTONS
35370     let fngenerate_buttons_("0","OK",2,0,1)
35375   end if  ! ~lpp_Button_Retain
35380   if lpp_button_retain=2 then 
35385     gosub ERASE_BUTTONS
35390     let fngenerate_buttons_("0,99","OK,Cancel",2,0,1)
35395   end if  ! ~lpp_Button_Retain
35400   if udim(lpp_handle)=1 then 
35405     if trim$(keys$)="" then print fields "24,1,Cc 80,[S]": "Review Screen  [Enter] Continue"
35410   else 
35415     print fields "24,1,Cc 80,[S]": "[Ctrl+Tab] Next Tab  [Ctrl+Shift+Tab] Previous Tab  [Enter] Continue"
35420   end if 
35425   for lpp_handle_item=1 to udim(mat lpp_handle) ! flush any and all buffers
35430     let fn_list_print('',lpp_handle(lpp_handle_item))
35435   next lpp_handle_item
35440   if env$("GUIMODE")="OFF" then 
35445     let kstat$(1)
35450     goto XIT_FNLIST_PRINT_PAUSE
35455   end if  ! env$("GUIMODE")="OFF"
35460 LPPAUSE_ASK: ! 
35465   dim lpp_selected_row$(1)*256
35470   if handle_current>0 then mat lpp_selected_row$(listprint_column_count(handle_current)) else mat lpp_selected_row$(1)
35475   if lpp_mstart then let curfld(1,lpp_mstart)
35480   do 
35485     if lpp_timeout then 
35490       input #handle_current,fields fn_list_print_handle$(handle_current)&",Row,SelOne",wait=lpp_timeout: mat lpp_selected_row$ error XIT_FNLIST_PRINT_PAUSE timeout ignore
35495     else 
35500       input #handle_current,fields fn_list_print_handle$(handle_current)&",Row,SelOne": mat lpp_selected_row$ error XIT_FNLIST_PRINT_PAUSE
35505     end if  ! lpp_timeout   /   else 
35510   loop until fkey<>105 and fkey<>106
35511 ! let fkey(-1) ! Do not do this!  It breaks things - like the ability to change tabs on the dashboard.
35515 ! 
35520   let lpp_lpch_which=srch(mat list_print_choice_handle,handle_current)
35525   if lpp_lpch_which>0 then 
35530     let list_print_choice_sel$(lpp_lpch_which)=fn_array_to_list$(mat lpp_selected_row$,1,'')
35535     let list_print_choice_num(lpp_lpch_which)=currow
35540   else 
35545     let fn_add_one(mat list_print_choice_handle,handle_current)
35550     let fn_add_one$(mat list_print_choice_sel$,fn_array_to_list$(mat lpp_selected_row$,1,''))
35555     let fn_add_one(mat list_print_choice_num,currow)
35560     let lpp_lpch_which=udim(mat list_print_choice_handle)
35565   end if  ! lpp_lpch_which>0
35570 ! 
35575   if fkey=90 or fkey=91 then goto LPPAUSE_ASK
35580   if fkey>=101 and fkey<=114 then let curfld(curfld,fkey) : goto LPPAUSE_ASK
35585   if fkey=tab_change then 
35590     for handle_count=1 to udim(mat lpp_handle)
35595       if curtab(lpp_handle(handle_count))=lpp_handle(handle_count) then let handle_current=lpp_handle(handle_count) : goto LPPAUSE_ASK
35600     next handle_count
35605   end if 
35610 XIT_FNLIST_PRINT_PAUSE: ! 
35615   if ~lpp_button_retain then gosub ERASE_BUTTONS
35620   if close_after_view then 
35625     for handle_item=1 to udim(mat lpp_handle)
35630       close #lpp_handle(handle_item): ioerr ignore
35635       let lpp_handle(handle_item)=0
35640     next handle_item
35645   end if  ! Close_After_View
35650   let lpp_mstart=currow
35655 fnend 
35660 def library fnlist_print_choice$*256(lpc_handle)
35662 ! gosub SETUP_LIBRARY
35664 ! gosub SETUP_CONSTANTS
35666   let fnlist_print_choice$=fn_list_print_choice$(lpc_handle)
35668 fnend  ! fnlist_print_choice$
35670 def fn_list_print_choice$*256(lpc_handle)
35675   dim lpc_return$*256
35680   dim list_print_choice_handle(10),list_print_choice_sel$(10)*256,list_print_choice_num(10) ! these variables are shared locally with fn_list_print_pause
35685   let lpc_which=srch(mat list_print_choice_handle,lpc_handle)
35690   if lpc_which>0 then 
35695     let lpc_return$=list_print_choice_sel$(lpc_which)
35700   else 
35705     let lpc_return$='' ! pr 'lpc_return$=';lpc_return$ : pause
35710   end if  ! lpp_lpch_which>0
35715   let fn_list_print_choice$=lpc_return$
35720 fnend  ! fn_list_print_choice$
35730 def library fnlist_print_choice(lpc_handle)
35732 ! gosub SETUP_LIBRARY
35734 ! gosub SETUP_CONSTANTS
35736   let fnlist_print_choice=fn_list_print_choice(lpc_handle)
35738 fnend  ! fnlist_print_choice$
35740 def fn_list_print_choice(lpc_handle)
35745   let lpc_which=srch(mat list_print_choice_handle,lpc_handle)
35750   if lpc_which>0 then 
35755     let lpc_return=list_print_choice_num(lpc_which)
35760   else 
35765     let lpc_return=0
35770   end if  ! lpp_lpch_which>0
35775   let fn_list_print_choice=lpc_return
35780 fnend  ! fn_list_print_choice$
35790 ! Diary.int Suite - top
35792 def fn_setup_diaryint_suite
35794   if ~diaryint_suite_setup then 
35796     let diaryint_setup=1
35798     gosub SETUP_LIBRARY
35800     gosub SETUP_CONSTANTS
35802     let fn_setup_sql_dchanges
35804     let fn_setup_sql_diaryint
35806     gosub SETUP_SQL_ACTIVE
35808     if ~user_setup then let fnget_user ! Sets User - local User_ID variable.
35810   end if  ! ~diaryint_setup
35812 fnend  ! fn_setup_diaryint_suite
35820 def library fndiary_add(da_method$*20,da_diaryint_h,mat da_diaryint_data$,mat da_diaryint_data; mat da_active_data$,mat da_active_data)
35822   if ~diaryint_setup then let fn_setup_diaryint_suite
35824   let fndiary_add=fn_diary_add(da_method$,da_diaryint_h,mat da_diaryint_data$,mat da_diaryint_data, mat da_active_data$,mat da_active_data)
35826 fnend  ! fndiary_add(diaryint_h,mat diaryint_data$,mat diaryint_data; active_h,mat active_data$,mat active_data)
35830 def fn_diary_add(da_method$*20,da_diaryint_h,mat da_diaryint_data$,mat da_diaryint_data; mat da_active_data$,mat da_active_data)
35835   let da_return=0
35840   let da_diaryint_data$(diaryint_code_alpha)=lpad$(rtrm$(str$(da_diaryint_data(diaryint_code))),8)
35845   let da_diaryint_data$(diaryint_code_alpha)=lpad$(rtrm$(str$(da_diaryint_data(diaryint_code))),8)
35850   let da_diaryint_data$(diaryint_date)=fn_date_c8$(da_diaryint_data$(diaryint_date))
35851   if trim$(da_diaryint_data$(diaryint_date))="" then !:
          let da_diaryint_data$(diaryint_date)="18991230" ! A "Bad Date" very far in the past.
35855   if trim$(da_diaryint_data$(diaryint_time))='' or trim$(da_diaryint_data$(diaryint_time))=':' then let da_diaryint_data$(diaryint_time)='@@:@@'
35860   write #da_diaryint_h,using diaryint_formall$,release: mat da_diaryint_data$,mat da_diaryint_data ioerr DA_ERR
35865   if udim(mat da_active_data$)>0 then let da_active_passed=1 else let da_active_passed=0
35870   mat da_dchanges_data$=('')
35875   mat da_dchanges_data=(0)
35880   let fn_dchanges_add_entry('A',da_method$,da_diaryint_h,mat da_diaryint_data$,mat da_diaryint_data, mat da_active_data$,mat da_active_data)
35885   let da_return=1
35890   goto DA_XIT
35895 DA_ERR: ! 
35900   let da_return=-err
35905   if developer then pause 
35910   goto DA_XIT ! DA_ERR
35915 DA_XIT: ! 
35920   let fn_diary_add=da_return
35925 fnend  ! fn_diary_add
35930 def library fndiary_add_var(dav_method$*20,dav_h_diaryint,dav_fileno$*8,dav_dc0den,dav_dc0de$*8,dav_pdate$*8,dav_cmt$*20,dav_queue$*8,dav_time$*5,dav_priority$*3)
35932   if ~diaryint_setup then let fn_setup_diaryint_suite
35934   let fndiary_add_var=fn_diary_add_var(dav_method$,dav_h_diaryint,dav_fileno$,dav_dc0den,dav_dc0de$,dav_pdate$,dav_cmt$,dav_queue$,dav_time$,dav_priority$)
35936 fnend  ! fndiary_add_var
35940 def fn_diary_add_var(dav_method$*20,dav_h_diaryint,dav_fileno$*8,dav_dc0den,dav_dc0de$*8,dav_pdate$*8,dav_cmt$*20,dav_queue$*8,dav_time$*5,dav_priority$*3)
35942   let fn_diary_var_to_sql(dav_fileno$,dav_dc0den,dav_dc0de$,dav_pdate$,dav_cmt$,dav_queue$,dav_time$,dav_priority$,mat diaryint_data$,mat diaryint_data)
35944   let fn_diary_add_var=fn_diary_add(dav_method$,dav_h_diaryint,mat diaryint_data$,mat diaryint_data) ! ; mat da_active_data$,mat da_active_data)
35946 fnend  ! fn_diary_add_var
35950 def library fndiary_rewrite_var (drv_method$*20,drv_h_diaryint,drv_fileno$*8,drv_dc0den,drv_dc0de$*8,drv_pdate$*8,drv_cmt$*20,drv_queue$*8,drv_time$*5,drv_priority$*3) ! drv_
35952   if ~diaryint_setup then let fn_setup_diaryint_suite
35954   let fn_diary_var_to_sql(drv_fileno$,drv_dc0den,drv_dc0de$,drv_pdate$,drv_cmt$,drv_queue$,drv_time$,drv_priority$,mat diaryint_data$,mat diaryint_data)
35956   let fn_diary_rewrite(drv_method$,drv_h_diaryint,mat diaryint_data$,mat diaryint_data)
35958 fnend  ! fndiary_rewrite_var
35960 def library fndiary_rewrite(drw_method$*20,drw_h_diaryint,mat drw_diaryint_data$,mat drw_diaryint_data) ! drw_
35962   if ~diaryint_setup then let fn_setup_diaryint_suite
35964   let fndiary_rewrite=fn_diary_rewrite(drw_method$,drw_h_diaryint,mat drw_diaryint_data$,mat drw_diaryint_data)
35966 fnend  ! fndiary_rewrite
35970 def fn_diary_rewrite(drw_method$*20,drw_h_diaryint,mat drw_diaryint_data$,mat drw_diaryint_data) ! drw_
35975   let drw_return=0
35980   rewrite #drw_h_diaryint,using diaryint_formall$: mat drw_diaryint_data$,mat drw_diaryint_data ioerr DRW_REWRITE_ERR
35985   let fn_dchanges_add_entry('C',drw_method$,drw_h_diaryint,mat drw_diaryint_data$,mat drw_diaryint_data)
35995   let drw_return=1
36000   goto DRW_FINIS
36005 DRW_REWRITE_ERR: ! 
36010   let drw_return=-err
36015   goto DRW_FINIS ! drw_REWRITE_ERR
36020 DRW_FINIS: ! 
36025   let fn_diary_rewrite=drw_return
36030 fnend  ! fn_diary_rewrite
36040 def library fndiary_comment_rewrite(dcr_method$*20,dcr_h_diaryint,dcr_rec,dcr_comment_new$*20)
36042   if ~diaryint_setup then let fn_setup_diaryint_suite
36044   let fndiary_comment_rewrite=fn_diary_comment_rewrite(dcr_method$,dcr_h_diaryint,dcr_rec,dcr_comment_new$)
36046 fnend  ! fndiary_comment_rewrite
36050 def fn_diary_comment_rewrite(dcr_method$*20,dcr_h_diaryint,dcr_rec,dcr_comment_new$*20)
36055   let dcr_return=0
36060   read #dcr_h_diaryint,using diaryint_formall$,rec=dcr_rec: mat diaryint_data$,mat diaryint_data ioerr DCR_ERROR
36065   let diaryint_data$(diaryint_comment)=dcr_comment_new$
36070   let dcr_return=fn_diary_rewrite(dcr_method$,dcr_h_diaryint,mat diaryint_data$,mat diaryint_data)
36075   goto DCR_FINIS
36080 DCR_ERROR: ! 
36085   let dcr_return=-err
36090   goto DCR_FINIS
36095 DCR_FINIS: ! 
36100   let fn_diary_comment_rewrite=dcr_return
36105 fnend  ! fn_diary_comment_rewrite
36110 def fn_diary_var_to_sql(dvts_fileno$*8,dvts_dc0den,dvts_dc0de$*8,dvts_pdate$*8,dvts_cmt$*20,dvts_queue$*8,dvts_time$*5,dvts_priority$*3,mat dvts_diaryint_data$,mat dvts_diaryint_data) ! dvts_
36112   mat dvts_diaryint_data$=('')
36114   mat dvts_diaryint_data=(0)
36116   let dvts_diaryint_data$(diaryint_fileno)=dvts_fileno$
36118   let dvts_diaryint_data(diaryint_code)=dvts_dc0den
36120   let dvts_diaryint_data$(diaryint_code_alpha)=dvts_dc0de$ ! will be ignored and reset by fn_diary_add anyway
36122   let dvts_diaryint_data$(diaryint_date)=dvts_pdate$
36124   let dvts_diaryint_data$(diaryint_comment)=dvts_cmt$
36126   let dvts_diaryint_data$(diaryint_queue)=dvts_queue$
36128   let dvts_diaryint_data$(diaryint_time)=dvts_time$
36130   let dvts_diaryint_data(diaryint_priority)=fnval_(dvts_priority$)
36132 fnend  ! fn_diary_var_to_sql
36140 ! Diary.int Suite - end
36142 def library fnblank(p_l;attribute$): print fields str$(p_l)&",1,c 80"&attribute$: "" : fnend 
36144 def library fnopentempwp(twp_handle)
36146   let fnopentempwp=fnopentempwp_(twp_handle)
36148 fnend 
36150 def fnopentempwp_(twp_handle)
36155   let fnopentempwp_=1
36160   if ~cls_setup then let fnclssetup
36165   if file$(twp_handle)<>"" then goto BAILOUT ! file is already open
36170 RTWP: form pos 1,c 8,pos 41,c 8
36175 L36175: let twp_ok=1 !:
        open #twp_handle: "NAME=n:tempwp,kfname=n:tempwp.idx,SHR",internal,outin,keyed ioerr CHECK_DAMAGED_TEMPWP
36180   if rln(twp_handle)<830 then let twp_ok=0: goto CHECK_DAMAGED_TEMPWP
36185 L36185: if kps(twp_handle,1)<>1 or kps(twp_handle,2)<>41 then let twp_ok=0: goto CHECK_DAMAGED_TEMPWP
36190   if kln(twp_handle,1)<>8 or kln(twp_handle,2)<>8 then let twp_ok=0: goto CHECK_DAMAGED_TEMPWP
36195   read #twp_handle,using RTWP,rec=lrec(twp_handle),release: key$,key1$ norec BAILOUT eof BAILOUT !:
        let lastrec=rec(twp_handle)
36200   read #twp_handle,using RTWP,key=key$&uprc$(key1$),release: key_a$,key_a1$ nokey INSANE
36205   do until rec(twp_handle)=lastrec or key$&uprc$(key1$)<>key_a$&uprc$(key_a1$)
36210     read #twp_handle,using RTWP,release: key_a$,key_a1$ eof INSANE
36215   loop 
36220   if key$&uprc$(key1$)=key_a$&uprc$(key_a1$) then goto BAILOUT ! all is good
36225 CHECK_DAMAGED_TEMPWP: ! This routine is for damaged tempwp files
36230   if err=4152 then !:
          open #twp_handle: "Name=n:tempwp,kfname=n:tempwp.idx,recl=830,use,kps=1/41,kln=8/8U,shr",internal,outin,keyed ioerr INSANE !:
          goto L36185
36235   if err=4122 or err=4124 or twp_ok=0 then !:
          let fnmessagebox_("Warning WP file may be damaged, press OK to repair",16,"File May Be Damaged") !:
          goto INSANE
36240   if err=4148 then !:
          let fn_stat_locks("Another Workstation is using N:TEMPWP.\nPlease wait until merge completes","Sharing Error","N:TEMPWP") !:
          goto L36175
36245   let fnmessagebox_("Error in WP File (TEMPWP), press OK to repair",16,"Error in File") !:
        goto INSANE
36250 INSANE: !:
        close #twp_handle: ioerr L36260
36255   if wcm$(1:7)="HARVEST" then let wcm_$="Harvest" !:
        else let wcm_$="Collection-Master"
36260 L36260: execute "*protect n:tempwp reserve" ioerr TEMPWP_IN_USE !:
        if ~exists("N:TEMPWP") then goto L36290
36265   if exists("N:TWP-[SESSION].INT") then !:
          execute '*FREE N:TWP-[SESSION].INT'
36270   execute "*protect n:tempwp release" !:
        execute "*RENAME N:TEMPWP N:TWP-[SESSION].INT"
36275   execute "*COPY N:TWP-[SESSION].INT N:TEMPWP -830"
36280   execute "*index n:tempwp n:tempwp.idx 1/41 8/8u -[WRKDRV] dupkeys replace shr -n"
36285 ! EXECUTE "*protect n:tempwp release" !:
        ! ** Note: We Moved this to 53220 for netware bug (0 Byte /w protect)
36290 L36290: open #twp_handle: "Name=n:tempwp,kfname=n:tempwp.idx,recl=830,use,kps=1/41,kln=8/8U,shr",internal,outin,keyed  !:
        goto BAILOUT
36295 TEMPWP_IN_USE: let dummy=fnmessagebox_("WP file is in need of repair. Please exit any other copies of "&wcm_$,17,"Repair File")
36300   if dummy=1 then goto L36260 !:
        else !:
          open #twp_handle: "Name=n:tempwp,kfname=n:tempwp.idx,recl=830,use,kps=1/41,kln=8/8U,shr",internal,outin,keyed  !:
          let dummy=fnmessagebox_("File opened in an unstable condition. Please re-index automatic WP as soon as possible.",48,"File Unstable") !:
          let fnopentempwp_=0
36305 BAILOUT: ! 
36310 fnend 
36320 def library fnsrch_case_insensitive(mat srch_array$,srch_for$*256; srch_start_ele)
36322 ! if ~setup the let fn_setup
36324   let fnsrch_case_insensitive=fn_srch_case_insensitive(mat srch_array$,srch_for$, srch_start_ele)
36326 fnend  ! fnsrch_case_insensitive
36330 def fn_srch_case_insensitive(mat srch_array$,srch_for$*300; srch_start_ele)
36335   let srch_array_count=udim(mat srch_array$)
36340   let srch_return=0
36345   do 
36350     let srch_found=srch(mat srch_array$,'^'&srch_for$,srch_start_ele)
36355     if srch_found>0 and lwrc$(srch_for$)=lwrc$(srch_array$(srch_found)) then 
36360       let srch_return=srch_found
36365     else if srch_found>0 then 
36370       let srch_start_ele=srch_found+1
36375     else if srch_found<=0 then ! it's not there, anywhere - get outta here.
36380       let srch_start_ele=srch_array_count+1
36385     end if 
36390   loop until srch_start_ele>srch_array_count or srch_return
36395   let fn_srch_case_insensitive=srch_return
36400 fnend  ! fn_srch_case_insensitive
36410 def library fnstuffhelp$*2048(mat elements$)
36415   dim sh_buff$*2048
36420   let sh_buff$=""
36425   let max_elements=udim(elements$)
36430   let columns=int(max_elements/10)+1
36435   let r_max=max_elements !:
        if rem(r_max,columns) then let r_max=ceil(max_elements/columns)*columns
36440   for elements=1 to r_max/columns
36445     for column=1 to columns
36450       let item=elements+(column-1)*int(r_max/columns)
36455       if item<=max_elements then let sh_buff$(9999:0)=elements$(item)&"" !:
            else !:
              let sh_buff$(9999:0)="        "
36460     next column
36465     let sh_buff$=sh_buff$&"\n"
36470   next elements
36475   let show_len=len(sh_buff$) !:
        let sh_buff$(show_len-2:show_len)=";"
36480   let fnstuffhelp$=sh_buff$
36485 fnend 
36490 def library fnb7_inf_paper$(field$,data$*80,mat user$,inf_handle,inf_sel_handle,fileno$,user,act_handle;b7ip_append)
36495 ! function to write to b7, inf or paperless (in that order) if field exists in b7 ini or infmast//9
36500   if ~b7ip_setup then !:
          gosub SETUP_LIBRARY !:
          let fnb7_ini_init !:
          let b7ip_setup=1
36502   dim f7ip_temp_inf$*100
36510   let b7_field=srch(block7_field$,field$) !:
        if b7_field>0 then 
36515     if b7ip_append then !:
            let user$(b7_field)=user$(b7_field)&data$ !:
          else !:
            let user$(b7_field)=data$
36520     if field_type$(b7_field)(1:1)="N" then !:
            let user$(b7_field)=fnnumber_input_$(user$(b7_field),field_type$(b7_field)) !:
          else !:
            if pos(field_pos$(b7_field),"PIC(##/##/##)")>0 then !:
              let user$(b7_field)=fndate8_$(user$(b7_field)) !:
            else !:
              if pos(field_pos$(b7_field),"PIC(####/##/##)")>0 then !:
                let user$(b7_field)=fndate10_$(user$(b7_field))
36525     let fnb7_inf_paper$="B7:"&str$(b7_field)
36530     goto EXIT_FNB7_INF_PAPER
36535   end if 
36540   if b7ip_append then !:
          let fn_getinf$(inf_handle,rpad$(fileno$,8)&uprc$(rpad$(field$,8)),b7ip_temp_inf,b7ip_temp_inf$) !:
          let inf$=fnputinf_$(inf_handle,inf_sel_handle,fileno$,field$,user,trim$(b7ip_temp_inf$)&data$,0) !:
        else !:
          let inf$=fnputinf_$(inf_handle,inf_sel_handle,fileno$,field$,user,data$,0)
36545   on pos("DNICF",inf$) goto INF_DATE,INF_NUM,INF_INT,INF_CHAR,INF_FLIP none TO_PAPER
36550 INF_DATE: let fnb7_inf_paper$="INF:DATE" !:
        goto EXIT_FNB7_INF_PAPER
36555 INF_NUM: let fnb7_inf_paper$="INF:NUM" !:
        goto EXIT_FNB7_INF_PAPER
36560 INF_INT: let fnb7_inf_paper$="INF:INT" !:
        goto EXIT_FNB7_INF_PAPER
36565 INF_CHAR: let fnb7_inf_paper$="INF:CHAR" !:
        goto EXIT_FNB7_INF_PAPER
36570 INF_FLIP: let fnb7_inf_paper$="INF:FILP" !:
        goto EXIT_FNB7_INF_PAPER
36575 TO_PAPER: ! code not found in b7 or inf - write to paperless
36580   let fnpaper_$(data$,field$,fileno$,user,act_handle)
36585   let fnb7_inf_paper$="PAPER:"&field$ !:
        goto EXIT_FNB7_INF_PAPER
36590 EXIT_FNB7_INF_PAPER: ! end of func
36595 fnend 
36600 def fnb7_ini_init
36605   dim block7_line$*100,block7_field$(1)*24,block7_ord(1)
36610   let b7_ini=fngetdisplay_("BLOCK7.ini//8")
36612   if b7_ini>0 then 
36615     let block7_count=1
36620 ! LINPUT #92: BLOCK7_LINE$
36625     do while not eof
36630       linput #b7_ini: block7_line$ eof L36670
36635       let com_pos=pos(block7_line$,",")
36640       let block7_ord(block7_count)=val(block7_line$(1:com_pos-1))
36645       let block7_line$=block7_line$(com_pos+1:len(block7_line$))
36650       let block7_field$(block7_count)=trim$(block7_line$)
36655       let block7_count+=1
36660       mat block7_field$(block7_count) !:
            mat block7_ord(block7_count)
36665     loop 
36670 L36670: close #b7_ini: 
36675     gosub B7_FORM
36678   end if 
36680 fnend 
36690 B7_FORM: ! r: STARTUP USER DEFINED ROUTINE
36695 L36695: form pos 1,b 4,datar*v 32,datar*v 8,v 1024,v 1024
36700 dim field_pos$(1)*32,field_type$(1)*8,u$(1)*80,fhelp$*1024,nform$*30,tu$(1)*80,work$*80,twork$*80,formr$*1024,formo$*1024,u(1),u_cache$(1)*40
36705 let userdef=fngetfile("USERDEF.FIL//9")
36710 read #userdef,using L36695,rec=1: datar
36715 mat field_pos$(datar)=("") : mat field_type$(datar)=("") : mat u$(datar)=("") : mat tu$(datar)=("") !:
      mat u(datar)=(0)
36720 read #userdef,using L36695,rec=1: datar,mat field_pos$,mat field_type$,fhelp$,formr$
36725 close #userdef: 
36730 let dleno=8: let formo$="FORM POS 1,C 8" !:
      for z=1 to udim(field_type$) !:
        let work$=field_type$(z)(2:len(field_type$(z))) !:
        let formo$=formo$&",C "&str$(int(val(work$))) !:
        let dleno+=int(val(work$)) !:
      next z !:
      let datao=udim(field_type$)
36735 return ! /r
36740 def library fnnumber_input$*80(wdata$*80,nform$*80)
36742   let fnnumber_input$=fnnumber_input_$(wdata$,nform$)
36744 fnend  ! fnnumber_input$
36750 def fnnumber_input_$*80(wdata$*80,nform$*80)
36755   let wdata$=srep$(wdata$,'$','') ! LET WDATA$=SREP$(WDATA$,',','')
36760   let x1=pos(nform$,"."): let nsize=val(nform$(2:x1-1)): let ndig=val(nform$(x1+1:x1+1))
36765   let wdata$=trim$(wdata$): let x2=pos(wdata$,".")
36770   let x3=pos(wdata$," ") : if x3=0 then let x3=len(wdata$)
36775   if x2>x3 then let x2=0
36780   if x2=0 then let wdata$=rtrm$(wdata$(1:x3)): let x4=len(wdata$): let wdata$=wdata$(1:x4-ndig)&"."&wdata$(x4-ndig+1:x4) : let x2=pos(wdata$,".")
36785   let x3=pos(wdata$,"..") : if x3>0 then let wdata$=wdata$(1:x3) : let x2=x3
36790   if x2=0 then let wdata$=wdata$&"." : let x2=len(wdata$)
36795   let work$=wdata$(1:x2-1) : if ndig=0 then goto L36810
36800   let twork$=wdata$(x2+1:x2+1+ndig)
36805   let twork$(999:0)=rpt$("0",ndig-len(twork$)) : let work$(999:0)="."&twork$(1:ndig)
36810 L36810: let wdata$="": let x1=val(work$) conv L36815 !:
        let wdata$=lpad$(work$,nsize)
36815 L36815: let fnnumber_input_$=wdata$
36820 fnend  ! fnnumber_input_$
36830 def library fncheck_date$(olddate$,newdate$,date_desc$*80,change_type)
36835   let olddate$=fndate10_$(olddate$) !:
        let newdate$=fndate10_$(newdate$)
36840 ! change_type=1 = Today or past allowed, future rejected !:
        ! change_type=2 prompt for any change
36845   if olddate$=newdate$ then let fncheck_date$=newdate$ !:
          goto EXIT_CHECK_DATE
36850 ! if CHANGE_TYPE=1 THEN
36855   if fndate10_$(newdate$)>date$("CCYY/MM/DD") then !:
          let check_date=fnmessagebox_("The new "&trim$(date_desc$)&" "&fndate_dis10_$(newdate$)&" is in the future. Is this what you want?",292,"Future "&date_desc$) !:
        else goto L36875
36860   if check_date=6 then let fncheck_date$=newdate$ else let fncheck_date$=olddate$
36865   goto EXIT_CHECK_DATE
36870 ! end if
36875 L36875: if change_type=2 then 
36880     let check_date=fnmessagebox_("The "&trim$(date_desc$)&" has been changed from "&fndate_dis10_$(olddate$)&" to "&fndate_dis10_$(newdate$)&" Do you wish to make this change?",292,"Date Changed")
36885     if check_date=6 then let fncheck_date$=newdate$ else let fncheck_date$=olddate$
36890   else 
36895     let fncheck_date$=newdate$
36900   end if 
36905 EXIT_CHECK_DATE: fnend  ! fncheck_date$
36910 def fnbh_1_$(bh1_value)
36912   if bh1_value>255 then let fnbh_1_$=chr$(0) !:
        else !:
          let fnbh_1_$=cnvrt$("bh 2",bh1_value)(2:2)
36914 fnend  ! fnbh_1_$
36916 def library fnbh_1$(bh1_value)
36918   let fnbh_1$=fnbh_1_$(bh1_value)
36920 fnend  ! fnbh_1$
36922 def library fnledger_chk$(tc)
36924   if tc=2 then !:
          let fnledger_chk$=("C") else !:
          let fnledger_chk$=("T")
36926 fnend  ! fnledger_chk$
36930 def library fnmulti_int(docket$,int_base,int_start$,int_end$)
36935   if ~cls_setup then let fnclssetup
36940   let int_start$=fndate10_$(int_start$) !:
        let int_start$=date$(days(fndate10_(int_start$))+1,"CCYY/MM/DD") !:
        let int_end$=date$(days(fndate10_(int_end$))-0,"CCYY/MM/DD")
36945   if uprc$(trim$(docket$)(1:2))<>"DJ" and uprc$(trim$(docket$)(1:2))<>"DC" then !:
          mat int_date$(udim(int_date_nj1$))=int_date_nj1$ !:
          mat int_rate(udim(int_rate_nj1))=int_rate_nj1 else !:
          mat int_date$(udim(int_date_nj2$))=int_date_nj2$ !:
          mat int_rate(udim(int_rate_nj2))=int_rate_nj2
36950   let tot_int=0 !:
        let multi_date$=int_start$
36955 L36955: let fnmulti_search(multi_date$)
36960   if multi_end$>int_end$ then let multi_end$=int_end$
36965   let _days=days(fndate10_(multi_end$))-days(fndate10_(multi_date$))+1 !:
        let _rate=multi_rate/365 !:
        let new_int=int_base*_days*_rate/100 !:
        let tot_int+=new_int !:
        if uprc$(env$("DEBUG"))="YES" then !:
          print multi_date$;" ";multi_end$;" ";_days;" ";_rate;new_int;tot_int
36970   if multi_end$<int_end$ then !:
          let multi_date$=date$(days(fndate10_(multi_end$))+1,"CCYY/MM/DD") !:
          goto L36955
36975   let fnmulti_int=tot_int
36980 fnend  ! fnmulti_int
36990 def fnmulti_search(find_date$)
36995   let multi_search=0
37000   let multi_start$=date$ !:
        let multi_end$=fnhigh_date_$ !:
        let multi_rate=0
37005   for nmulti=udim(int_date$) to 1 step -1
37010     if fndate10_$(find_date$)>=int_date$(nmulti) then let multi_search=nmulti !:
            let nmulti=1
37015   next nmulti
37020   if multi_search<>0 and multi_search<udim(int_date$) then !:
          let multi_end$=int_date$(multi_search+1)
37025   if multi_search<>0 then !:
          let multi_start$=int_date$(multi_search) !:
          let multi_rate=int_rate(multi_search)
37030   let multi_end$=date$(days(fndate10_(multi_end$))-1,"CCYY/MM/DD")
37035 fnend  ! fnmulti_search
37040 def library fnmovewp(handle_from,user;mwp_auto_flag)
37042   if not cls_setup then let fnclssetup
37044   if merge_pool$<>"Y" then let fnmessagebox_("This feature is not activated. Please see your administrator or call CLS for help",16,"Feature Not Active") !:
          goto EXIT_MOVEWP
37046 RHF: form pos 1,c 830
37048 RWHT: form pos 806,bh 2,2*bh 4,pos 49,c 1
37050   if user=0 then let fnmessagebox_("Invalid user number passed to function."&chr$(10)&" ** Operation Aborted ** ",16,"Operation Aborted") !:
          goto EXIT_MOVEWP
37052   if handle_from=0 then let handle_from=fngethandle_
37054   close #handle_from: ioerr L37056
37056 L37056: open #handle_from: "name=n:tempwp,noshr",internal,outin,relative ioerr INUSE
37058   let twp_rln=830 !:
        open #handle_to:=fngethandle_: "name=tempwp."&fn_user_pic$(user)&"/WPPOOL,shr",internal,input,relative ioerr L37060 !:
        let twp_rln=rln(handle_to) !:
        close #handle_to: 
37060 L37060: open #handle_to:=fngethandle_: "name=tempwp."&fn_user_pic$(user)&"/WPPOOL,noshr,use,recl="&str$(twp_rln),internal,outin,relative ioerr CHECK_WPPOOL
37062 L37062: read #handle_from,using RHF: buff$ eof DONE_MOVEWP
37064 ! if RLN(HANDLE_FROM)>805 THEN REREAD #HANDLE_FROM,USING RRHF: BUFF1$
37066   write #handle_to,using RHF: buff$ ! usung wht <7.0
37068   if buff$(49:49)<>"!" and buff$(49:49)<>"D" then !:
          rewrite #handle_to,using RWHT,same: user,date,fnstime_(time$),"!" !:
          ! else !:
          ! REWRITE #HANDLE_TO,USING RWHTA,SAME: BUFF1$ ! keep original info
37070   goto L37062
37072 INUSE: let fnmessagebox_("Unable to transfer documents, file in use",16,"File in Use") !:
        goto EXIT_MOVEWP
37074 CHECK_WPPOOL: if err=4203 then execute "*mkdir wppool" !:
          goto L37060
37076   if err=4148 then execute "Stat Locks" !:
          let fnmessagebox_("Error:"&str$(err)&" Line:"&str$(line)&" moving data.\nThere is a sharing Problem with this operation",16,"File Sharing Error") !:
          goto EXIT_MOVEWP
37078   if exists("tempwp."&fn_user_pic$(user)&"/WPPOOL") then 
37080     open #h_temp:=fngethandle_: "name=tempwp."&fn_user_pic$(user)&"/WPPOOL",internal,input,relative 
37082     let temp_rln=rln(h_temp) !:
          close #h_temp: 
37084     if temp_rln<830 then 
37086       if exists("TWP-[SESSION].INT/wppool") then !:
              execute '*FREE TWP-[SESSION].INT/wppool'
37088       execute "*RENAME tempwp."&fn_user_pic$(user)&"/WPPOOL TWP-[SESSION].INT/wppool"
37090       execute "*COPY TWP-[SESSION].INT/wppool tempwp."&fn_user_pic$(user)&"/WPPOOL -830"
37092     end if 
37094   end if 
37096   let fnmessagebox_("Error:"&str$(err)&" Line:"&str$(line)&" moving data.\nCLSUTIL"&chr$(10)&" ** Operation Aborted ** ",16,"Operation Aborted") !:
        goto EXIT_MOVEWP
37098 DONE_MOVEWP: let fnmovewp=lrec(handle_to) !:
        if ~mwp_auto_flag and lrec(handle_from)>0 then !:
          let fnmessagebox_(str$(lrec(handle_from))&" Successfully moved to the Merge Pool",64,"Move Successful") ! move sucessful- close & drop source & del idx file !:
        else if ~mwp_auto_flag then !:
          let fnmessagebox_("No documents available to be moved to the Merge Pool",64,"No Documents")
37100 close #handle_from,drop: 
37102 if exists("n:tempwp.idx") then execute "free n:tempwp.idx -n"
37104 EXIT_MOVEWP: close #handle_to: ioerr L37106
37106 L37106: close #handle_from: ioerr L37108
37108 L37108: fnend  ! fnmovewp
37110 def library fnrestore_wp(handle_to,user;rwp_auto_flag)
37112   if not cls_setup then let fnclssetup
37114   if merge_pool$<>"Y" then let fnmessagebox_("This feature is not activated. Please see your administrator or call CLS for help",16,"Feature Not Active") !:
          goto EXIT_RESTORE_WP
37120   if user=0 then let fnmessagebox_("Invalid user number passed to function."&chr$(10)&" ** Operation Aborted ** ",16,"Operation Aborted") !:
          goto EXIT_RESTORE_WP
37124   close #handle_to: ioerr L37126
37126 L37126: let fnopentempwp_(handle_to) !:
        if rln(handle_to)<830 then print "PROBLEM" : goto DONE_RESTORE_WP
37127   if ~exists("tempwp."&fn_user_pic$(user)&"/WPPOOL") then goto DONE_RESTORE_WP
37130   open #handle_from:=fngethandle_: "name=tempwp."&fn_user_pic$(user)&"/WPPOOL,noshr",internal,outin,relative ioerr CHECK_RESTORE_WPPOOL
37132 L37132: read #handle_from,using RHF: buff$ eof DONE_RESTORE_WP
37134 ! if RLN(Handle_To)>805 THEN REREAD #Handle_To,USING RRHF: BUFF1$
37136   write #handle_to,using RHF: buff$ ! usung wht <7.0
37140   goto L37132
37142 INUSE_RESTORE_WP: let fnmessagebox_("Unable to transfer documents, file in use",16,"File in Use") !:
        goto EXIT_RESTORE_WP
37144 CHECK_RESTORE_WPPOOL: ! 
37146   if err=4148 then execute "Stat Locks" !:
          let fnmessagebox_("Error:"&str$(err)&" Line:"&str$(line)&" moving data.\nThere is a sharing Problem with this operation",16,"File Sharing Error") !:
          goto EXIT_RESTORE_WP
37166   let fnmessagebox_("Error:"&str$(err)&" Line:"&str$(line)&" moving data.\nCLSUTIL"&chr$(10)&" ** Operation Aborted ** ",16,"Operation Aborted") !:
        goto EXIT_RESTORE_WP
37168 DONE_RESTORE_WP: let fnrestore_wp=lrec(handle_to) !:
        if ~rwp_auto_flag and lrec(handle_from)>0 then !:
          let fnmessagebox_(str$(lrec(handle_from))&" Successfully restored from the Merge Pool",64,"Restore Successful") !:
        else if ~rwp_auto_flag then !:
          let fnmessagebox_("No documents available to be restored from the Merge Pool",64,"No Documents")
37170 close #handle_from,drop: 
37172 if ~exists("tempwp."&fn_user_pic$(user)&"/WPPOOL") then execute "free tempwp."&fn_user_pic$(user)&"/WPPOOL"
37174 EXIT_RESTORE_WP: close #handle_to: ioerr L37176
37176 L37176: close #handle_from: ioerr L37178
37178 L37178: fnend  ! FnRestore_wp
37220 def library fndiary_del(dide_method$*20,dide_diaryint_h,dide_record_number; mat dide_active_data$,mat dide_active_data) ! dide_
37222   if ~dide_setup then 
37224     let dide_setup=1
37226     gosub SETUP_LIBRARY
37228     gosub SETUP_CONSTANTS
37230     let fn_setup_sql_dchanges
37232     let fn_setup_sql_diaryint
37234     gosub SETUP_SQL_ACTIVE
37236     if ~user_setup then let fnget_user ! Sets User - local User_ID variable.
37238   end if  ! ~dide_setup
37240   let fndiary_del=fn_diary_del(dide_method$,dide_diaryint_h,dide_record_number, mat dide_active_data$,mat dide_active_data)
37242 fnend  ! fndiary_del
37250 def fn_diary_del(dide_method$*20,dide_diaryint_h,dide_record_number; mat dide_active_data$,mat dide_active_data) ! dide_
37255 !      if mat active_data$,mat active_data passed than use it for DChanges entry information.  if not figure it out.
37260 !      read rec= to get diaryint info
37265 !      use fndelrec to delete diaryint record.
37270   let dide_return=0
37275   read #dide_diaryint_h,using diaryint_formall$,rec=dide_record_number: mat diaryint_data$,mat diaryint_data ioerr DIDE_ERR
37280   let diaryint_data$(diaryint_code_alpha)=lpad$(rtrm$(str$(diaryint_data(diaryint_code))),8)
37285   let diaryint_data$(diaryint_code_alpha)=lpad$(rtrm$(str$(diaryint_data(diaryint_code))),8)
37290   let diaryint_data$(diaryint_date)=fn_date_c8$(diaryint_data$(diaryint_date))
37295   if trim$(diaryint_data$(diaryint_time))='' then let diaryint_data$(diaryint_date)='@@:@@'
37300   let dide_return=fndelrec(dide_diaryint_h,dide_record_number)
37305   if dide_return>0 then 
37310     let fn_dchanges_add_entry('D',dide_method$,dide_diaryint_h,mat diaryint_data$,mat diaryint_data, mat dide_active_data$,mat dide_active_data)
37315   end if  ! dide_return>0
37320   goto DIDE_XIT
37325 DIDE_ERR: ! 
37330   let dide_return=-err
37335   if serial=12906 then print 'error '&str$(dide_return)&' encountered on line '&str$(line)&' of fn_diary_del' : pause 
37340   goto DIDE_XIT ! DIDE_ERR
37345 DIDE_XIT: ! 
37350   let fn_diary_del=dide_return
37355 fnend  ! fn_diary_del
37360 def fn_h_dchanges(hd_h_diaryint) ! hd_
37365   if file$(hd_h_diaryint)(1:2)='H:' then ! closed
37370     let hd_oc$='Closed'
37375     if hd_h_dchanges_closed<=0 then 
37380       let hd_h_dchanges_closed=fnclosed_dchanges(mat unused)
37385     end if  ! hd_h_dchanges_closed<=0 then
37390     let hd_h_dchanges=hd_h_dchanges_closed
37395   else ! open
37400     let hd_oc$='Open'
37405     if hd_h_dchanges_open<=0 or file(hd_h_dchanges_open)=-1 then 
37410       let hd_h_dchanges_open=fnopen_dchanges(mat unused)
37415     end if  ! hd_h_dchanges_open<=0
37420     let hd_h_dchanges=hd_h_dchanges_open
37425   end if  ! file$(hd_h_diaryint)(1:2)='H:'   /   else 
37430   let fn_h_dchanges=hd_h_dchanges
37435 fnend  ! fn_h_dchanges
37440 def fn_dchanges_add_entry(dae_type_a_or_d$*1,dae_method$,dae_h_diaryint,mat dae_diaryint_data$,mat dae_diaryint_data; mat dae_active_data$,mat dae_active_data) ! dae_
37445   if udim(mat dae_active_data$)>0 then let dae_active_passed=1 else let dae_active_passed=0
37450   let dchanges_data$(dchanges_fileno)=dae_diaryint_data$(diaryint_fileno)
37455   let dchanges_data$(dchanges_type)=uprc$(dae_type_a_or_d$) ! Or "C" for Changed.
37460   let dchanges_data(dchanges_code)=dae_diaryint_data(diaryint_code)
37465   let dchanges_data$(dchanges_code_alpha)=dae_diaryint_data$(diaryint_code_alpha)
37470   let dchanges_data$(dchanges_date)=fn_date_c8$(dae_diaryint_data$(diaryint_date))
37475   let dchanges_data$(dchanges_comment)=dae_diaryint_data$(diaryint_comment)
37480   let dchanges_data$(dchanges_queue)=dae_diaryint_data$(diaryint_queue)
37485   let dchanges_data$(dchanges_time)=dae_diaryint_data$(diaryint_time)
37490   let dchanges_data(dchanges_priority)=dae_diaryint_data(diaryint_priority)
37495   if dae_active_passed then 
37500     let dchanges_data$(dchanges_trans_type)=dae_active_data$(active_type)
37505     let dchanges_data(dchanges_trans_date)=dae_active_data(active_trans_date)
37510     let dchanges_data(dchanges_trans_time)=dae_active_data(active_trans_time)
37515     let dchanges_data(dchanges_user_id)=dae_active_data(active_user_id)
37520   else 
37525     let dchanges_data$(dchanges_trans_type)="" !:
          let dchanges_data(dchanges_trans_date)=date('ccyymmdd') !:
          let dchanges_data(dchanges_trans_time)=fnstime_(time$) !:
          let dchanges_data(dchanges_user_id)=user
37530   end if 
37535   if dchanges_data(dchanges_trans_date)<=0 then let dchanges_data(dchanges_trans_date)=date('ccyymmdd')
37540   if dchanges_data(dchanges_trans_time)<=0 then let dchanges_data(dchanges_trans_time)=fnstime_(time$)
37545   let dchanges_data$(dchanges_user_init)=fnuserinit$
37550   if dae_active_passed then 
37555     let dchanges_data$(dchanges_llcode)
37560   end if 
37565   let dchanges_data$(dchanges_method)=dae_method$
37570   if dae_active_passed then 
37575     let dchanges_data(dchanges_recno)=dae_active_data(active_recno)
37580   end if 
37585   let dae_h_dchanges=fn_h_dchanges(dae_h_diaryint)
37590   write #dae_h_dchanges,using dchanges_formall$,release: mat dchanges_data$,mat dchanges_data ! ioerr DIDE_ERR
37595 fnend  ! fn_dchanges_add_entry
37600 def fnint_setup
37605   let i_setup=1
37610   dim i_index$(1)*110,i_sqlname$(1)*15,i_descrip$(1)*22,i_indexinfo$(1)*78,i_type$(1),i_openinfo$(1)*78
37615   let fnasci_("i_index.txt/sql",mat i_index$)
37620   mat i_sqlname$(udim(i_index$))=("") !:
        mat i_descrip$(udim(i_index$))=("") !:
        mat i_indexinfo$(udim(i_index$))=("") !:
        mat i_type$(udim(i_index$))=("")
37625   for count=1 to udim(i_index$)
37630     let i_sqlname$(count)=rtrm$(i_index$(count)(1:15)) !:
          let i_descrip$(count)=rtrm$(i_index$(count)(16:37)) !:
          let i_indexinfo$(count)="INDEX "&fntrim$(i_index$(count)(38:87))&" -[WRKDRV] DUPKEYS REPLACE -n" !:
          let i_type$(count)=rtrm$(i_index$(count)(106:108))
37635   next count
37640 fnend 
37650 def fntrim$*256(text$*256)
37655 L37655: let text$=trim$(text$)
37660   let xspace=pos(text$,"  ") !:
        if xspace>0 then let text$=srep$(text$,"    "," ") !:
          let text$=srep$(text$,"  "," ") !:
          goto L37655
37665   let fntrim$=text$
37670 fnend 
37680 def library fnint_index$(mat i_sql$,mat i_desc$,mat i_idxinf$,mat i_idxtype$;individual$)
37685   if ~i_setup then let fnint_setup
37690   dim i_idxinf$(1)*78
37695   mat i_sql$(udim(i_sqlname$))=i_sqlname$ !:
        mat i_desc$(udim(i_descrip$))=i_descrip$ !:
        mat i_idxinf$(udim(i_indexinfo$))=i_indexinfo$ !:
        mat i_idxtype$(udim(i_type$))=i_type$
37700   if individual$="" then goto L37735
37705   mat i_idxinf$(1)=("") !:
        mat i_desc$(1)=("") !:
        mat i_sql$(1)=("") !:
        mat i_idxtype$(1)=(""): let tot_found=0
37710 ! Individual Type Indexes
37715   let type_search=0
37720 L37720: let type_found=srch(mat i_idxtype$,individual$,type_search+1)
37725   if type_found>0 then let type_search=type_found : let tot_found+=1: mat i_idxinf$(tot_found) : mat i_desc$(tot_found) : mat i_sql$(tot_found) : mat i_idxtype$(tot_found) !:
          let i_idxinf$(tot_found)=rtrm$(i_indexinfo$(type_found)) !:
          let i_desc$(tot_found)=rtrm$(i_descrip$(type_found)) !:
          let i_sql$(tot_found)=rtrm$(i_sqlname$(type_found)) !:
          let i_idxtype$(tot_found)=rtrm$(i_type$(type_found)) : goto L37720
37730   goto L37735
37735 L37735: fnend 
37740 def fnint_open_setup
37745   let i_open_setup=1
37750   let fnasci_("i_index.txt/sql",mat i_index$)
37755   mat i_sqlname$(udim(i_index$))=("") !:
        mat i_descrip$(udim(i_index$))=("") !:
        mat i_openinfo$(udim(i_index$))=("") !:
        mat i_type$(udim(i_index$))=("")
37760   for count=1 to udim(i_index$)
37765     let i_sqlname$(count)=rtrm$(i_index$(count)(1:15)) !:
          let i_descrip$(count)=rtrm$(i_index$(count)(16:37)) !:
          let i_openinfo$(count)="NAME="&trim$(i_index$(count)(38:53))&",KFNAME="&trim$(i_index$(count)(54:71))&",shr" !:
          let i_type$(count)=rtrm$(i_index$(count)(106:108))
37770 ! PAUSE
37775   next count
37780 fnend 
37790 def library fnsetup_internal(mat internal_menu$,mat open_files$)
37792   dim internal_type$(1)*12,i_sql$(1)*20,i_desc$(1)*100,i_openinf$(1)*100,i_opentype$(1)*100
37794   let ifiles=fni_menu(mat internal_menu$,mat internal_type$)
37796   for nloop=1 to ifiles
37798     let imatch$="I"&cnvrt$('PIC(##)',nloop) !:
          let fnintopen(mat i_sql$,mat i_desc$,mat i_openinf$,mat i_opentype$,imatch$)
37800     let open_files$(nloop+109)=i_openinf$(1) !:
          ! ** This was 139, used to be 140 to 160 for internal data files, now 110 - ?? for internal data files
37802   next nloop
37804 fnend 
37810 def library fnint_open(mat i_sql$,mat i_desc$,mat i_openinf$,mat i_opentype$;ind_open$)
37812   let fnint_open=fnintopen(mat i_sql$,mat i_desc$,mat i_openinf$,mat i_opentype$,ind_open$)
37814 fnend 
37820 def fnintopen(mat i_sql$,mat i_desc$,mat i_openinf$,mat i_opentype$;ind_open$)
37825   if ~i_open_setup then let fnint_open_setup
37830   mat i_sql$(udim(i_sqlname$))=i_sqlname$ !:
        mat i_desc$(udim(i_descrip$))=i_descrip$ !:
        mat i_openinf$(udim(i_openinfo$))=i_openinfo$ !:
        mat i_opentype$(udim(i_type$))=i_type$
37835   if ind_open$="" then goto L37865
37840   let security_state=lrec(security_handle)
37845   mat i_sql$(1)=("") !:
        mat i_desc$(1)=("") !:
        mat i_openinf$(1)=("") !:
        mat i_opentype$(1)=("") : let tot_found=0
37850   let open_search=0
37855 L37855: let open_found=srch(mat i_type$,ind_open$,open_search+1)
37860   if open_found>0 then let open_search=open_found : let tot_found+=1: mat i_openinf$(tot_found): mat i_desc$(tot_found): mat i_sql$(tot_found): mat i_opentype$(tot_found) !:
          let i_openinf$(tot_found)=rtrm$(i_openinfo$(open_found)) !:
          let i_desc$(tot_found)=rtrm$(i_descrip$(open_found)) !:
          let i_sql$(tot_found)=rtrm$(i_sqlname$(open_found)) !:
          let i_opentype$(tot_found)=rtrm$(i_type$(open_found)): goto L37855
37865 L37865: fnend 
37870 ! ----------------- [LIBRARY FNSECURITY$]-----------------------
37872 def library fnsecurity(pk$*20;security_desc$*80,original_security_handle,user_init$,inquiry_only)
37874   let fnsecurity=fnsecurity_(pk$,security_desc$,original_security_handle,user_init$,inquiry_only)
37876 fnend 
37878 ! INQUIRY_ONLY !:
      ! Default = 0 Prompt User on Access Denied !:
      ! -1 Default to Password Required (Complex Password by default)
37880 def fnsecurity_(pk$*80;security_desc$*80,original_security_handle,user_init$,inquiry_only)
37885   let key$=hex$("434D4153544552") !:
        let pk$=rtrm$(pk$) !:
        let pk$=rtrm$(pk$,"-")(1:20) !:
        let user_init$=rpad$(user_init$,3)(1:3) !:
        let best_init$="" !:
        let master=0: mat master$(1)=("") !:
        if ~cls_setup then let fnclssetup
37890   dim master$(1)*25,password$*25,security_cache$(1)*31,best_master$*25,master$*25,master_password$*25,master_key$*25
37895   let security_failed=0 !:
        if original_security_handle then !:
          let security_handle=original_security_handle
37900   if srch(mat security_cache$,pk$)>0 then !:
          goto SECURITY_APPROVED
37901   if security_handle>0 and original_security_handle=0 and pos(uprc$(file$(security_handle)),"PERMISN")<=0 then !:
          let security_handle=0
37905   let security_state=-1 !:
        if security_handle>0 then !:
          let security_state=lrec(security_handle)
37910   if ~setup_security then let fnsetup_security
37915 L37915: if security_state<0 then !:
          let security_handle=fnindex_handle("Name=L:Permisn,KFName=L:Permisn.idx","OUTIN",permisn_record_prior) ! OPEN #SECURITY_HANDLE: "name=Permisn//8,kfname=Permisn.idx//8,SHR",INTERNAL,OUTIN,KEYED
37920   if security_handle<0 then 
37925     let security_choice=fnmessagebox_("Error: "&str$(security_handle)&" accessing "&os_filename$("L:Permisn")&"\nPlease resolve the conflict and select Retry, or Cancel to Shutdown",5+16,"Error Accessing Permissions") !:
          if security_choice=4 then !:
            goto L37915 else !:
            execute "SYSTEM"
37930   end if 
37935   if pk$="PASSWORD NEEDED" then goto L38000
37940   let best_init$=user_init$ !:
        read #security_handle,using SECURITY_FORM,key=user_init$&rpad$(pk$,20),release: sec_type$,sec_readyonly$,master$ nokey L37945 !:
        let master=1 !:
        let master$(1)=master$ !:
        goto CHECK_SECURITY !:
        ! ** Note - Users Specific Security Overrides all other rights
37945 L37945: let sec_type$="" !:
        let best_type$=best_readonly$=best_master$="" !:
        let best_init$="***" !:
        read #security_handle,using SECURITY_FORM,key="***"&rpad$(pk$,20),release: best_type$,best_readyonly$,best_master$ nokey L37955
37950   if best_type$="Y" then !:
          let sec_type$=best_type$ !:
          let sec_readonly$=best_readonly$: let master$="" !:
          goto SECURITY_APPROVED else !:
          if best_type$="P" then !:
            let sec_type$=best_type$ !:
            let sec_readonly$=best_readonly$: let master+=1: mat master$(master) !:
            let master$(master)=best_master$ else !:
            if trim$(sec_type$)="" then let sec_type$=best_type$ !:
              let sec_readonly$=best_readonly$: let master$=""
37955 L37955: for ngroup=1 to groups !:
          if groups$(ngroup)="***" then goto L37975
37960     read #security_handle,using SECURITY_FORM,key=groups$(ngroup)&rpad$(pk$,20),release: best_type$,best_readyonly$,best_master$ nokey L37975
37965     let best_init$=groups$(ngroup)
37970     if best_type$="Y" then let sec_type$=best_type$ !:
            let sec_readonly$=best_readonly$: let master$="" : let ngroup=999 else !:
            if best_type$="P" then let sec_type$=best_type$ !:
              ! let best_init$=groups$(ngroup) !:
              let sec_readonly$=best_readonly$: let master+=1: mat master$(master) !:
              let master$(master)=best_master$ else !:
              if trim$(sec_type$)="" then let sec_type$=best_type$ !:
                let sec_readonly$=best_readonly$: let master$=""
37975 L37975: next ngroup
37980   if inquiry_only=-1 and trim$(sec_type$)="" then !:
          let sec_type$="P" !:
          let key_date=days(date) !:
          let master_password$=str$(mod(key_date,7))&str$(date(key_date,"MM")+date(key_date,"DD")+mod(key_date,7))&date$("YY") !:
          let master_key$=unhex$(str$(date(key_date,"MM")+date(key_date,"DD")+mod(key_date,7))) ! DATE$(KEY_DATE,"MM/DD/CCYY")) !:
          let fnencryptdecrypt(master_password$,master_key$)
37985   if trim$(sec_type$)="" then !:
          let sec_type$="Y": let sec_readonly$="": let master$="" !:
          goto CHECK_SECURITY
37990 SECURITY_FORM: form pos 24,2*c 1,c 25
37995 CHECK_SECURITY: if sec_type$="Y" then goto SECURITY_CACHE else !:
          if sec_type$="N" then goto SECURITY_FAILED
38000 L38000: let security_window=fngetwindow_(14,8,51,7,"Password Required","DS") !:
        print #security_window: newpage !:
        print #security_window,fields '2,2,Cr 9,[W];2,12,38/C 80,[P]SP;3,2,Cr 9,[W];3,12,38/C 80,[P]SP;4,2,Cr 9,[W];4,12,38/C 80,[P]SP;6,2,Cr 9,[W];7,36,Cc 6,[P]S,B0;7,44,Cc 6,[P]S,B99': 'Policy:',pk$,'User:',user_init$,'Group:',best_init$,"Password:","OK","Cancel" !:
        if security_desc$<>'???' and security_desc$<>'' then !:
          print #security_window,fields '1,2,48/Cc ,[S]': trim$(security_desc$)
38005   if inquiry_only>0 and sec_type$="P" then print bell;
38010   if env$("GUIMODE")="ON" and inquiry_only>0 and sec_type$="P" then print "Policy ("&pk$&") is set to P, only Y and N are valid."
38015   if inquiry_only>0 and sec_type$="P" and debug then 
38020     print #security_window,fields '6,2,Cc 49,[S];7,3,Cc 47,[W]': 'DEBUG: Policy set to P, only Y and N are valid.','Press any key to continue.'
38025     input #security_window,fields '7,2,C 1,[W]AE': pause$
38030   end if  ! inquiry_only>0 and sec_type$="P" and debug
38035   if inquiry_only>0 then !:
          ! on inquiry,only see if security is enabled, skip passwords !:
          let fnsecurity_=0 ! 0 means Password !:
          close #security_window: !:
          goto L38155
38040   input #security_window,fields "6,12,38/Cu 25,[D]IA",attr '[A]I': password$ !:
        close #security_window: 
38045   let key_date=days(date) !:
        let master_password$=str$(mod(key_date,7))&str$(date(key_date,"MM")+date(key_date,"DD")+mod(key_date,7))&date$("YY") !:
        let master_key$=unhex$(str$(date(key_date,"MM")+date(key_date,"DD")+mod(key_date,7))) ! DATE$(KEY_DATE,"MM/DD/CCYY")) !:
        let fnencryptdecrypt(master_password$,master_key$)
38050   if trim$(password$)=unhex$(master_password$) then !:
          let password$=master$(1) !:
          let setenv("CLIPBOARD","") !:
          goto L38060
38055   let fnencryptdecrypt(password$,key$)
38060 L38060: let npassword=srch(mat master$,password$) !:
        if npassword<=0 then print bell; !:
          let security_failed+=1 !:
        else goto SECURITY_CACHE
38065   if fkey=93 or fkey=99 or (fkey=0 and password$='') then let fnsecurity_=-1 : goto L38155
38070   if security_failed<5 and cmdkey<>99 then 
38075     goto L38000
38080   else 
38085     if security_desc$='???' or security_desc$='' then let security_message_rejection$='' else let security_message_rejection$=security_desc$&'\n\n'
38090     let security_message_rejection$=security_message_rejection$&'Policy: '&tab$&pk$&'\n' !:
          let security_message_rejection$=security_message_rejection$&'User: '&tab$&user_init$&'\n' !:
          let security_message_rejection$=security_message_rejection$&'Group: '&tab$&best_init$&'\n\n' !:
          let security_message_rejection$=security_message_rejection$&"Access Denied - Invalid Password" !:
          let fnmessagebox_(security_message_rejection$,16,"Invalid Password") !:
          let fnsecurity_=-1 !:
          goto L38155
38095   end if  ! 
38100 SECURITY_FAILED: ! 
38105   if not inquiry_only then 
38110     dim security_message_rejection$*1024
38115     if security_desc$='???' or security_desc$='' then let security_message_rejection$='' else let security_message_rejection$=security_desc$&'\n\n'
38120     let security_message_rejection$=security_message_rejection$&'Policy: '&tab$&pk$&'\n' !:
          let security_message_rejection$=security_message_rejection$&'User: '&tab$&user_init$&'\n' !:
          let security_message_rejection$=security_message_rejection$&'Group: '&tab$&best_init$&'\n\n' !:
          let security_message_rejection$=security_message_rejection$&"This option is restricted by a policy.\nPlease check with your administrator." !:
          let fnmessagebox_(security_message_rejection$,16,"Access Denied to ["&trim$(trim$(user_init$&"/"&best_init$))&"]")
38125     let fnsecurity_=-1 !:
          goto L38155
38130   else 
38135     let fnsecurity_=-1 !:
          goto L38155
38140   end if  ! NOT INQUIRY_ONLY
38145 SECURITY_CACHE: let security_cache+=1 !:
        mat security_cache$(security_cache) !:
        let security_cache$(security_cache)=pk$
38150 SECURITY_APPROVED: let fnsecurity_=1
38155 L38155: ! if Security_State<=0 And Original_Security_Handle=0 And Permisn_Record_Prior=-1 THEN !:
        !  CLOSE #Security_Handle: !:
        !  LET Security_Handle=0 !:
        ! Permisn is opening too many times!
38160   if security_handle=original_security_handle then !:
          let security_handle=0 !:
          ! if Security_Handle was passed, do not keep this value for future use!
38165 fnend 
38170 def library fnarray_summary(mat source$,mat summary$)
38175   dim work(1),work$(1)*80
38180   mat summary$(1)=("") !:
        let tot_summary=0
38185   for nloop=1 to udim(source$)
38190     let nfound=srch(mat summary$,source$(nloop)) !:
          if nfound>0 or trim$(source$(nloop))="" then goto L38200
38195     let tot_summary+=1: mat summary$(tot_summary): let summary$(tot_summary)=source$(nloop)
38200 L38200: next nloop
38205   mat work(udim(summary$))=(0): mat work$(udim(summary$))=("") !:
        mat work=aidx(summary$)
38210   for nloop=1 to udim(work$): let work$(nloop)=summary$(work(nloop)): next nloop !:
        mat summary$=work$
38215   let fnarray_summary=udim(summary$)
38220 fnend 
38230 def fnsetup_security
38235   dim groups$(1)*3,groups_name$(1)*40,group_code$*3,group_name$*40
38240   let groups=0 !:
        mat groups$(1)=("")
38245   let user_init$=rpad$(user_init$,3)(1:3)
38250   let groups_handle=fngetfile("name=GROUPS//8,KFNAME=GROUPS.IDX//8,SHR","Input")
38255   let groupmem_handle=fngetfile("name=GROUPMEM//8,KFNAME=GROUPMEM.GRP//8,SHR","Input")
38256   if groups_handle=-4152 then goto L38290 ! GROUPS is Empty, Only Everyone used.
38260 L38260: read #groups_handle,using L38265,release: group_code$,group_name$ eof L38290
38265 L38265: form pos 1,c 3,c 40
38270   read #groupmem_handle,key=group_code$&user_init$,release: nokey L38260
38275   let groups+=1 !:
        mat groups$(groups) !:
        mat groups_name$(groups)
38280   let groups$(groups)=group_code$ !:
        let groups_name$(groups)=group_name$
38285   goto L38260
38290 L38290: if groups=0 then let groups+=1 !:
          mat groups$(1) !:
          let groups$(1)="***"
38295 ! mat GROUPS Contains a Complete list of Groups this user belongs to!
38300   close #groups_handle: ioerr ignore
38305   close #groupmem_handle: ioerr ignore
38310   let setup_security=1
38315 fnend 
38320 def fnuserinit$
38325   if trim$(user_init$)<>"" then goto L38380
38330   dim wp$*20
38335   let whoami_handle=fngetfile("n:WHOAMI","Input")
38340   if whoami_handle<=0 then let fnmessagebox_("Warning: \nError:"&str$(err)&"\nLine:"&str$(line)&"\nOpening N:WHOAMI",16,"I/O ERROR") !:
          goto L38385
38345   read #whoami_handle,using "FORM POS 1,C 20",release: wp$ ioerr L38350 !:
        let wp$=trim$(wp$)
38350 L38350: close #whoami_handle: 
38355   let userlist2_handle=fngetfile("NAME=USERLIST//8,KFNAME=USERLIST.NAM//8,SHR")
38360   if userlist2_handle<=0 then let fnmessagebox_("Warning: \nError:"&str$(err)&"\nLine:"&str$(line)&"\nOpening USERLIST//8",16,"I/O ERROR") !:
          goto L38385
38365   read #userlist2_handle,using L38370,key=rpad$(wp$,20),release: user_init$ ioerr L38370
38370 L38370: form pos 21,c 3
38375   close #userlist2_handle: 
38380 L38380: let fnuserinit$=user_init$
38385 L38385: fnend 
38390 def library fnuser_init$
38392   let fnuser_init$=fnuserinit$
38394 fnend 
38400 def library fnget_caption$*60(caption_handle,fileno$,caption_type$,debtor_no,line_no)
38402   dim caption_key$*12,caption_name$*60
38404   let fileno$=rpad$(fileno$,8)(1:8) !:
        let caption_type$=rpad$(caption_type$,1)(1:1)
38406   let caption_name$="" !:
        let caption_key$=fileno$&caption_type$&cnvrt$('BH 2',debtor_no)&cnvrt$('BH 1',line_no)
38408   read #caption_handle,using L38410,key=caption_key$,release: caption_name$ nokey L38410
38410 L38410: form pos 13,c 60
38412   let fnget_caption$=caption_name$
38414 fnend 
38420 def library fnput_caption(caption_handle,fileno$,caption_type$,debtor_no,line_no,old_caption$*60,caption_name$*60)
38422   let fileno$=rpad$(fileno$,8)(1:8) !:
        let caption_type$=rpad$(caption_type$,1)(1:1)
38424   if trim$(caption_name$)=trim$(old_caption$) then goto L38438
38426   let caption_key$=fileno$&caption_type$&cnvrt$('BH 2',debtor_no)&cnvrt$('BH 1',line_no)
38428   if trim$(caption_name$)="" then !:
          delete #caption_handle,key=caption_key$: nokey L38436
38430   rewrite #caption_handle,using L38410,key=caption_key$: caption_name$ nokey L38432 !:
        goto L38436
38432 L38432: write #caption_handle,using L38434: fileno$,"D",debtor_no,line_no,caption_name$ nokey L38432 !:
        goto L38436
38434 L38434: form pos 1,c 8,c 1,bh 2,bh 1,c 60
38436 L38436: ! 
38438 L38438: fnend 
38440 def library fnintini_parse(mat intini_parse$,mat intini_key$)
38445 ! INTINI_PARSE$ 5 Elements Per internal Data File!:
        ! (#,1)= NO - FIELD!:
        ! (#,2)= ACCT_NO - FIELD!:
        ! (#,3)= DEBTOR #!:
        ! (#,4)= TYPE!:
        ! (#,5)= RELATION!:
        ! intini_key$ - KEY=RELATION [2]+NUMBER [3]+TYPE [10]
38450   dim intini_parse$(1,5)*15,intini$(1)*80
38455   let fnasci_("INTERNAL.INI/SQL",mat intini$)
38460   mat work$(udim(intini$))=("")
38465   mat intini_parse$(udim(intini$),5) !:
        mat intini_key$(udim(intini$)) !:
        for intcount=1 to udim(intini$)
38470     let fnlist_(intini$(intcount),mat work$,chr$(9))
38475     let relation$=cnvrt$('N 2',val(intini$(intcount)(2:3)))
38480     let intini_parse$(intcount,5)=relation$
38485     for nloop=1 to 4
38490       let intini_parse$(intcount,nloop)=work$(nloop)
38495     next nloop
38500     let intini_key$(intcount)=lpad$(intini_parse$(intcount,5),2)&"-"&lpad$(intini_parse$(intcount,3),3)&"-"&uprc$(rpad$(intini_parse$(intcount,4),10))
38505   next intcount
38510   let fnintini_parse=udim(intini$)
38515 fnend 
38520 def library fnconvert_englishdate$(datetoconvert$*60)
38525   if ~cls_setup then let fnclssetup
38530 ! if the string passed in is 0 or an empty string then Exit Function
38535   let datetoconvert$ = srep$(datetoconvert$, " ", "/")
38540   let datetoconvert$ = srep$(datetoconvert$, ",", "/")
38545   let datetoconvert$ = srep$(datetoconvert$, "-", "/") !:
        let datetoconvert$ = srep$(datetoconvert$, ".", "/")
38550   let datetoconvert$ = srep$(datetoconvert$, "////","/") !:
        let datetoconvert$ = srep$(datetoconvert$, "///","/") !:
        let datetoconvert$ = uprc$(srep$(datetoconvert$, "//","/"))
38555   if len(trim$(trim$(trim$(datetoconvert$,"0"),"/"), " ")) = 0 then goto L38600
38560   for nyear = 1 to udim(mth$)
38565     let datetoconvert$ = srep$(datetoconvert$, uprc$(month$(nyear)), cnvrt$('PIC(##)',nyear))
38570     let datetoconvert$ = srep$(datetoconvert$, uprc$(mth$(nyear)), cnvrt$('PIC(##)',nyear))
38575   next nyear
38580   let lslash = pos(datetoconvert$, "/") !:
        let lslash2 = pos(datetoconvert$, "/", lslash+1)
38585   if lslash=0 and lslash2=0 then !:
          let datetoconvert$=fngetdate$(datetoconvert$,date_10$(2),"CCYY/MM/DD") !:
          let lslash = pos(datetoconvert$, "/") !:
          let lslash2 = pos(datetoconvert$, "/", lslash+1) !:
          ! ** Allow dates to be simple CCYYMMDD"
38590   if lslash=0 or lslash2=0 then goto L38600 ! --------Invalid Date-----
38595   let fnconvert_englishdate$ = fngetdate$(datetoconvert$, date_8$(2), "CCYY/MM/DD")
38600 L38600: ! Exit Function
38605 fnend 
38610 def library fngenerate_buttons_for_window(mat gbw_win_part$,gbw_h_window)
38612   gosub SETUP_CONSTANTS
38614 ! gosub SETUP_LIBRARY
38616   let fngenerate_buttons_for_window=fn_generate_buttons_for_window(mat gbw_win_part$,gbw_h_window)
38618 fnend  ! fngenerate_buttons_for_window
38620 def fn_generate_buttons_for_window(mat gbw_win_part$,gbw_h_window; gbw_noadd_keys,mat gbw_win_button_field$,mat gbw_win_button_text$) ! gbw_
38625 ! (f) is for Features - the top row of buttons is for program features, the bottom for of buttons is for navigation.
38630   dim gbw_field$(1)*40
38635   dim gbw_btn_text$(1)*80,gbw_btn_tmp_text$*80,gbw_btn_fkey$(1)
38640   if udim(mat gbw_win_button_field$)>0 then let gbw_win_button_pop=1 else let gbw_win_button_pop=0
38645   if gbw_win_button_pop then 
38650     mat gbw_win_button_field$(0)
38655     mat gbw_win_button_text$(0)
38660   end if  ! gbw_win_button_pop
38665   let gbw_height_mod=fn_window_button_rows(mat gbw_win_part$)
38670   let gbw_loop_start=1
38675   let gbw_loop_end=gbw_height_mod
38680   if gbw_height_mod=1 and pos(gbw_win_part$(pw_button_text),'(f)')<=0 then let gbw_loop_start=2 : let gbw_loop_end=2
38685   for mwb_button_row=gbw_loop_start to gbw_loop_end
38690 ! 
38695     let buttons_row=val(gbw_win_part$(pw_rows))-2+mwb_button_row
38700 ! 
38705     let str2mat(gbw_win_part$(pw_button_text),mat b_lab$,';')
38710     let str2mat(gbw_win_part$(pw_button_fkey),mat b_key$,';')
38715     let tot_keys=udim(b_key$)
38720     mat b_lab$(tot_keys)
38725     mat b_key(tot_keys)
38730     for ncount=1 to tot_keys ! build mat B_Key from mat B_Key$
38735       let b_key(ncount)=val(b_key$(ncount)) conv ignore
38740     next ncount
38745     let m_row$=str$(buttons_row)
38750     let status_string$=b_string$=""
38755     print #gbw_h_window,fields m_row$&",1,C "&gbw_win_part$(pw_cols)&",[W]": "" error ignore ! Delete Button Row
38760     mat gbw_btn_text$(0)
38765     mat gbw_btn_fkey$(0)
38770     for dev_j=udim(mat b_lab$) to 1, step -1
38775       let gbw_btn_tmp_text$=srep$(srep$(b_lab$(dev_j),'(f)',''),'(n)','')
38780       if (mwb_button_row=1 and pos(b_lab$(dev_j),'(f)')>0) or (mwb_button_row=2 and pos(b_lab$(dev_j),'(f)')<=0) then 
38785         if ~gbw_noadd_keys then 
38790 !         auto add fkey to label - top
38795           if b_key(dev_j)=99 and pos(lwrc$(gbw_btn_tmp_text$),"esc")<=0 then 
38800             let gbw_btn_tmp_text$="[Esc] "&trim$(gbw_btn_tmp_text$)
38805           else if b_key(dev_j)=90 and pos(lwrc$(gbw_btn_tmp_text$),"pgup")<=0 and pos(lwrc$(gbw_btn_tmp_text$),"pg up")<=0 then 
38810             let gbw_btn_tmp_text$="[PgUp] "&trim$(gbw_btn_tmp_text$)
38815           else if b_key(dev_j)=91 and pos(lwrc$(gbw_btn_tmp_text$),"pgdn")<=0 and pos(lwrc$(gbw_btn_tmp_text$),"pg down")<=0 and pos(lwrc$(gbw_btn_tmp_text$),"pg dn")<=0 then 
38820             let gbw_btn_tmp_text$="[PgDn] "&trim$(gbw_btn_tmp_text$)
38825           else if b_key(dev_j)=0 and pos(lwrc$(gbw_btn_tmp_text$),"enter")<=0 and trim$(gbw_btn_tmp_text$)<>"" then 
38830             let gbw_btn_tmp_text$="[Enter] "&trim$(gbw_btn_tmp_text$)
38835           else if b_key(dev_j)=>1 and b_key(dev_j)<=12 and pos(lwrc$(gbw_btn_tmp_text$),"[f"&str$(b_key(dev_j))&"]")<=0 then 
38840             let gbw_btn_tmp_text$="[F"&str$(b_key(dev_j))&"] "&trim$(gbw_btn_tmp_text$)
38845           end if  ! b_key(dev_j)=...
38850 !         auto add fkey to label - end
38855         end if  ! ~gbw_noadd_keys
38860         let fn_add_one$(mat gbw_btn_text$,gbw_btn_tmp_text$)
38865         let fn_add_one$(mat gbw_btn_fkey$,b_key$(dev_j))
38870       end if  ! (mwb_button_row=1 and pos(b_lab$(dev_j),'(f)')>0) or (mwb_button_row=2 and pos(b_lab$(dev_j),'(f)')<=0)
38875     next dev_j
38880     let fn_get_button_fields(mat gbw_btn_text$,val(gbw_win_part$(pw_cols)),val(m_row$),mat gbw_btn_fkey$,mat gbw_field$)
38885     if gbw_win_button_pop then 
38890       let fn_array_add$(mat gbw_win_button_field$,mat gbw_win_button_field$,mat gbw_field$)
38895       let fn_array_add$(mat gbw_win_button_text$,mat gbw_win_button_text$,mat gbw_btn_text$)
38900     else 
38905       print #gbw_h_window,fields mat gbw_field$: mat gbw_btn_text$ ioerr GBW_PRINT_ERR
38910     end if  ! gbw_win_button_pop   /   else 
38915     let auto_add_fkey_to_label=0
38920   next mwb_button_row
38925   goto GBW_XIT
38930 GBW_PRINT_ERR: ! 
38935   if developer then 
38940     for j=1 to udim(mat gbw_field$) : print 'gbw_field$('&str$(j)&')='&gbw_field$(j)&' - gbw_btn_text$('&str$(j)&')='&gbw_btn_text$(j) : next j
38945     print 'could not print buttons - probably because the window is too narrow.'
38950     pause 
38955   end if  ! developer
38960   continue  ! GBW_PRINT_ERR
38965 GBW_XIT: ! 
38970 fnend  ! fn_generate_buttons_for_window
38980 def library fnredefine_buttons_for_window(mat rdfw_win_part$,rdfw_text$*128,rdfw_fkey$*128; rdfw_help$*128)
38982   let fnredefine_buttons_for_window=fn_redefine_buttons_for_window(mat rdfw_win_part$,rdfw_text$,rdfw_fkey$, rdfw_help$)
38984 fnend  ! fnredefine_buttons_for_window
38990 def fn_redefine_buttons_for_window(mat rdfw_win_part$,rdfw_text$*128,rdfw_fkey$*128; rdfw_help$*128)
38995   let rdfw_win_part$(pw_button_text)=rdfw_text$
39000   let rdfw_win_part$(pw_button_fkey)=rdfw_fkey$
39005   let rdfw_win_part$(pw_button_help)=rdfw_help$
39010 fnend  ! fn_redefine_buttons_for_window
39020 XML_SETUP: ! r: todo: remove this section and combine it into SETUP_LIBRARY
39022 library "xmlio/library": fngrid,fnxml_io,fnopen_xml_writer,fnclose_xml_writer,fnopen_node,fnadd_node
39024 let xml_setup=1
39026 return  ! /r XML_SETUP
39030 GRIDIO_SETUP: ! r: todo: remove this section and combine it into SETUP_LIBRARY
39032 library "GRIDIO/library": fngridio
39034 let gridio_setup=1
39036 return  ! /r GRIDIO_SETUP
39040 PARSE_TITLE: ! r: Parse information from TITLE & Footer
39045 dim grid_title$*256,grid_heading$*256,grid_footer$*256,grid_keys$*256,grid_labels$*256
39050 let grid_title$="" !:
      let grid_heading$="" !:
      let grid_footer$="" !:
      let grid_keys$="" !:
      let grid_labels$=""
39055 let title_pos=pos(uprc$(scroll_title$),"TITLE=") !:
      let heading_pos=pos(uprc$(scroll_title$),"HEADING=")
39060 if title_pos<=0 and heading_pos<=0 then !:
        let grid_title$=scroll_title$ !:
        goto L39080
39065 if title_pos<=0 and heading_pos>0 then !:
        let grid_heading$=scroll_title$(heading_pos+8:9999) !:
        goto L39080
39070 if title_pos>0 and heading_pos<=0 then !:
        let grid_title$=scroll_title$(title_pos+6:9999) !:
        goto L39080
39075 let grid_title$=scroll_title$(title_pos+6:heading_pos-1) !:
      let grid_heading$=scroll_title$(heading_pos+8:99999) !:
      goto L39080
39080 L39080: let scroll_title$=grid_title$
39085 let footer_pos=pos(uprc$(scroll_footer$),"FOOTER=") !:
      let keys_pos=pos(uprc$(scroll_footer$),"KEYS=") !:
      let labels_pos=pos(uprc$(scroll_footer$),"LABELS=")
39090 ! NOTE -KEYS & LABELS MUST BOTH BE PRESENT!!!! !:
      ! NOTE -KEYS MUST BE BEFORE LABELS!
39095 if labels_pos=000 then let labels_pos=len(scroll_footer$)+1
39100 if footer_pos<=0 and keys_pos<=0 then !:
        let grid_footer$=scroll_footer$ !:
        goto L39120
39105 if footer_pos>0 and keys_pos<=0 then !:
        let grid_footer$=scroll_footer$(footer_pos+7:9999) !:
        goto L39120
39110 if footer_pos<=0 and keys_pos>=0 then !:
        let grid_keys$=trim$(scroll_footer$(keys_pos+5:labels_pos-1)) !:
        let grid_labels$=trim$(scroll_footer$(labels_pos+7:99999)) !:
        goto L39120
39115 let grid_footer$=scroll_footer$(footer_pos+7:keys_pos-1) !:
      let grid_keys$=trim$(scroll_footer$(keys_pos+5:labels_pos-1)) !:
      let grid_labels$=trim$(scroll_footer$(labels_pos+7:99999))
39120 L39120: let scroll_footer$=grid_footer$
39125 if env$("GUIMODE")="ON" or (fnwin_gui and trim$(win_pop$)<>"OFF") then goto L39140
39130 ! This section is for no-gui [Must add buttons to screen]
39135 if trim$(grid_keys$)<>"" and trim$(grid_labels$)<>"" then !:
        let fngenerate_buttons_(srep$(grid_keys$,";",","),srep$(grid_labels$,";",","),1,24)
39140 L39140: return  ! /r PARSE_TITLE
39150 def library fninfdesc$*709(fileno$,infinity_handle,mat inf_code$)
39155   dim set_fninfdesc$*709,infinity_field$*70
39160 ! DEF FNInfDesc$*709(FILENO$,H_INFINITY,Mat Inf_Code$) !:
        ! The function will return a string of all of the 70-charioteer description fields contained in the INF_CODES$ array. !:
        ! Each description s/b trimmed and space delimited.
39165   let set_fninfdesc$=''
39170   for inf_item=1 to udim(mat inf_code$)
39175     read #infinity_handle,using "Form Pos 27,V 70",key=rpad$(trim$(fileno$),kln(infinity_handle,1))&rpad$(trim$(inf_code$(inf_item)),kln(infinity_handle,2)),release: infinity_field$ nokey NOKEY_FNINFDESC
39180     let set_fninfdesc$=trim$(set_fninfdesc$&" "&trim$(infinity_field$))
39185 NEXT_INF_ITEM: ! 
39190   next inf_item
39195   goto XIT_FNINFDESC
39200 NOKEY_FNINFDESC: ! 
39205   goto NEXT_INF_ITEM
39210 XIT_FNINFDESC: ! 
39215   let fninfdesc$=set_fninfdesc$
39220 fnend 
39230 def library fnrange_sel$*128(rs_value$*128,rs_file$*256; rs_reset)
39232   if rs_file$<>rs_file_prior$ or rs_reset then 
39234     dim rs_file_line$(1)*256
39236     dim rs_file_prior$*256
39238     dim set_fnrange_sel$*128
39240     dim rs_range_low$(1)*128
39242     dim rs_range_high$(1)*128
39244     dim rs_range_return$(1)*128
39246     let fnasci_(rs_file$,mat rs_file_line$)
39248     let rs_file_line_count=udim(mat rs_file_line$)
39250     mat rs_range_low$(0) : mat rs_range_high$(0) : mat rs_range_return$(0)
39252     for rs_file_line_item=1 to rs_file_line_count
39254       let fnparse_csv_(rs_file_line$(rs_file_line_item),mat rs_file_line_field$, chr$(9))
39256       if udim(mat rs_file_line_field$)<3 then mat rs_file_line_field$(3)
39258       let fn_add_one$(mat rs_range_low$,rs_file_line_field$(1))
39260       let fn_add_one$(mat rs_range_high$,rs_file_line_field$(2))
39262       let fn_add_one$(mat rs_range_return$,rs_file_line_field$(3))
39264     next rs_file_line_item
39266     let rs_file_prior$=rs_file$
39268   end if  ! RS_File$<>RS_File_Prior$ or RS_Reset
39270 ! 
39272   let set_fnrange_sel$="~*$%^no match^%$*~"
39274   let rs_item=0
39276   do 
39278     let rs_item+=1
39280     if rs_value$=>rs_range_low$(rs_item) and rs_value$<=rs_range_high$(rs_item) then let set_fnrange_sel$=rs_range_return$(rs_item)
39282   loop until rs_item=>rs_file_line_count or set_fnrange_sel$<>"~*$%^no match^%$*~"
39284   if set_fnrange_sel$="~*$%^no match^%$*~" then let set_fnrange_sel$=""
39286   let fnrange_sel$=set_fnrange_sel$
39288 fnend 
39290 def library fnrange_sel(rs_value,rs_file$*256; rs_reset)
39292   if rs_file$<>rs_file_prior$ or rs_reset then 
39294     dim rs_file_line$(1)*256
39296     dim rs_file_prior$*256
39298     dim rs_range_low(1)
39300     dim rs_range_high(1)
39302     dim rs_range_return(1)
39304     let fnasci_(rs_file$,mat rs_file_line$)
39306     let rs_file_line_count=udim(mat rs_file_line$)
39308     mat rs_range_low(0) : mat rs_range_high(0) : mat rs_range_return(0)
39310     for rs_file_line_item=1 to rs_file_line_count
39312       let fnparse_csv_(rs_file_line$(rs_file_line_item),mat rs_file_line_field$, chr$(9))
39314       if udim(mat rs_file_line_field$)<3 then mat rs_file_line_field$(3)
39316       let fn_add_one(mat rs_range_low,fnval_(rs_file_line_field$(1)))
39318       let fn_add_one(mat rs_range_high,fnval_(rs_file_line_field$(2)))
39320       let fn_add_one(mat rs_range_return,fnval_(rs_file_line_field$(3)))
39322     next rs_file_line_item
39324     let rs_file_prior$=rs_file$
39326   end if  ! RS_File$<>RS_File_Prior$ or RS_Reset
39328 ! 
39330   let set_fnrange_sel=-2020202.02
39332   let rs_item=0
39334   do 
39336     let rs_item+=1
39338     if rs_value=>rs_range_low(rs_item) and rs_value<=rs_range_high(rs_item) then let set_fnrange_sel=rs_range_return(rs_item)
39340   loop until rs_item=>rs_file_line_count or set_fnrange_sel<>-2020202.02
39342   if set_fnrange_sel=-2020202.02 then let set_fnrange_sel=-1
39344   let fnrange_sel=set_fnrange_sel
39346 fnend 
39350 def library fncomm_rate$(comm$*20)
39352   let com_rate=val(comm$) conv L39392 !:
        if com_rate>100 then let com_rate/=100 !:
          let comm$=str$(com_rate)
39354   if len(comm$)=5 and comm$(3:3)="." then !:
          let comm$(3:3)="" !:
          goto L39392
39356   if comm$(1:6)="33.333" then let comm$="1/3!" !:
          goto L39392
39358   if comm$(1:6)="16.166" then let comm$="1/6!" !:
          goto L39392
39360   if comm$(1:6)="14.285" then let comm$="1/7!" !:
          goto L39392
39362   if comm$(1:6)="28.571" then let comm$="2/7!" !:
          goto L39392
39364   if comm$(1:6)="42.857" then let comm$="3/7!" !:
          goto L39392
39366   if comm$(1:6)="11.111" then let comm$="1/9!" !:
          goto L39392
39368   if comm$(1:6)="22.222" then let comm$="2/9!" !:
          goto L39392
39370   if comm$(1:6)="44.444" then let comm$="4/9!" !:
          goto L39392
39372   if comm$(1:6)="9.0909" then let comm$="1/11!" !:
          goto L39392
39374   if comm$(1:6)="18.181" then let comm$="2/11!" !:
          goto L39392
39376   if comm$(1:6)="27.272" then let comm$="3/11!" !:
          goto L39392
39378   if comm$(1:6)="36.363" then let comm$="4/11!" !:
          goto L39392
39380   if comm$(1:6)="45.454" then let comm$="5/11!" !:
          goto L39392
39382   if comm$(1:6)="8.3333" then let comm$="1/12!" !:
          goto L39392
39384   if comm$(1:6)="41.666" then let comm$="5/12!" !:
          goto L39392
39386   if comm$(1:6)="7.6923" then let comm$="1/13!" !:
          goto L39392
39388   if comm$(1:6)="15.384" then let comm$="2/13!" !:
          goto L39392
39390   if comm$(1:6)="30.769" then let comm$="4/13!" !:
          goto L39392
39392 L39392: let fncomm_rate$=comm$
39394 fnend 
39400 def fn_winscroll_m2(mat wsm2_option$; wsm2_default_start,wsm2_title$*1024,scroll_border$*20,scroll_footer$*256,scroll_scol,scroll_srow,scroll_cols,scroll_rows,display_only) ! wsm2_
39405   dim scroll_title$*1024
39410   dim grid_title$*256,grid_heading$*256,grid_footer$*256,grid_keys$*256,grid_labels$*256
39415   dim wsm2_title_only$*256
39420   dim wsm2_footer$*256
39425   dim wsm2_button_fkey_list$*256
39430   dim wsm2_button_text_list$*256
39435   dim wsm2_default_selection$*256
39440 ! 
39445   let wsm2_default_selection$=''
39450   let wsm2_button_0_text$='OK'
39455   let wsm2_button_2_text$='Seek'
39460   let wsm2_button_10_text$='Find'
39465   let wsm2_button_99_text$='Cancel'
39470 ! 
39475   let scroll_title$=wsm2_title$
39480   gosub PARSE_TITLE
39485   let wsm2_footer$=grid_footer$
39490   let wsm2_title_only$=grid_title$
39495 ! 
39500 !  remove fkey 0 and fkey 99 from first line and use the text from them for the second line buttons.
39505   let wsm2_button_fkey_list$=srep$(grid_keys$,';',',')
39510   let fnparse_csv_(wsm2_button_fkey_list$,mat wsm2_button_fkey$)
39515   let wsm2_button_text_list$=srep$(grid_labels$,';',',')
39520   let fnparse_csv_(wsm2_button_text_list$,mat wsm2_button_text$)
39525   let fn_wsm2_button_update(mat wsm2_button_fkey$,mat wsm2_button_text$,00,wsm2_button_0_text$)
39530   let fn_wsm2_button_update(mat wsm2_button_fkey$,mat wsm2_button_text$,02,wsm2_button_2_text$)
39535   let fn_wsm2_button_update(mat wsm2_button_fkey$,mat wsm2_button_text$,10,wsm2_button_10_text$)
39540   let fn_wsm2_button_update(mat wsm2_button_fkey$,mat wsm2_button_text$,99,wsm2_button_99_text$)
39545   let wsm2_button_fkey_list$=fn_array_to_csv$(mat wsm2_button_fkey$)
39550   let wsm2_button_text_list$=fn_array_to_csv$(mat wsm2_button_text$)
39555 ! 
39560   let fngenerate_buttons_(wsm2_button_fkey_list$,wsm2_button_text_list$,1,0,1)
39565   let fngenerate_buttons_("99,10,9012,2,0",wsm2_button_99_text$&','&wsm2_button_10_text$&',Print,'&wsm2_button_2_text$&','&wsm2_button_0_text$,2,0,1)
39570 ! 
39575 ! "OK, Cancel, Find, Print, Seek"
39580 ! 
39585 ! fnwinscroll(mat wsm2_option$, wsm2_default_start,scroll_title$,scroll_border$,scroll_footer$,scroll_scol,scroll_srow,scroll_cols,scroll_rows,display_only)
39590   if wsm2_default_start>0 then let wsm2_default_selection$=wsm2_option$(wsm2_default_start)
39595 ! 
39600   let wsm2_menu2_return=fnmenu2(wsm2_title_only$,cap$,pk$,mat wsm2_option$,wsm2_default_selection$,'',0,wsm2_footer$,2)
39605   if fkey=9012 then let fn_wsm2_print(mat wsm2_option$) ! pause  !
39610 ! fnmenu2(m2_title$*80,m2_cap$*80,&m2_pk$,mat m2_option$; m2_default_selection$*256, m2_trust$*80,m2_timeout,m2_footer$*80,m2_preserve_backgroud)
39615   let fn_winscroll_m2=wsm2_menu2_return
39620 fnend  ! fnwinscroll_m2
39625 def fn_wsm2_button_update(mat wsm2bu_button_fkey$,mat wsm2bu_button_text$,wsm2bu_fkey,&wsm2bu_fkey_text_default$) ! wsm2bu_
39630   let wsm2bu_button_which=srch(mat wsm2bu_button_fkey$,str$(wsm2bu_fkey))
39635   if wsm2bu_button_which>0 then 
39640     let wsm2bu_fkey_text_default$=wsm2bu_button_text$(wsm2bu_button_which)
39645     let fnremovearrayitem$(mat wsm2bu_button_fkey$,wsm2bu_button_which)
39650     let fnremovearrayitem$(mat wsm2bu_button_text$,wsm2bu_button_which)
39655   end if  ! wsm2bu_button_which>0
39660 fnend  ! fn_wsm2_button_update
39665 def fn_array_to_csv$*2048(mat atc_array$; atc_delimiter$)
39670   dim atc_return$*2048
39675   let atc_return$=''
39680   if atc_delimiter$='' then let atc_delimiter$=','
39685   let mat2str(mat atc_array$,atc_return$,atc_delimiter$)
39690   let fn_array_to_csv$=atc_return$
39695 fnend  ! fn_array_to_csv$
39700 def fn_wsm2_print(mat wsm2p_line$)
39705   dim wsm2p_buff$*256
39710   let fnsel(report_width, "",wsm2p_printer_handle:=fngethandle_,"Cancel")
39715   print #wsm2p_printer_handle: "[BOX10CPI]"
39720   for wsm2p_array_ele = 1 to udim(mat wsm2p_line$)
39725     let wsm2p_buff$=wsm2p_line$(wsm2p_array_ele)
39730     let wsm2p_buff$=srep$(wsm2p_buff$, "","[ROWMiddle]")
39735     let wsm2p_buff$="[Row_String]"&wsm2p_buff$&"[/ROW]"
39740     print #wsm2p_printer_handle: wsm2p_buff$
39745   next wsm2p_array_ele
39750   print #wsm2p_printer_handle: "[/BOX]"
39755   let fnclose(wsm2p_printer_handle)
39760 fnend 
39765 def fn_get_button_fields(mat gbf_label$,gbf_win_width,gbf_row,mat gbf_fkey$,mat gbf_field$)
39770 ! todo: add button needs to auto move to correct position.  (far left i think)
39775 ! todo: add variable spacers between buttons,
39780 ! todo: right align buttons
39785   let gbf_count=udim(mat gbf_label$)
39790   let gbf_len_max=0
39795   for gbf_i=1 to gbf_count
39800     let gbf_label$(gbf_i)=trim$(gbf_label$(gbf_i))
39805     let gbf_len_max=max(gbf_len_max,len(gbf_label$(gbf_i)))
39810   next gbf_i
39815   if gbf_count>0 then 
39820     if gbf_len_max<=int(gbf_win_width/gbf_count) then 
39825       if gbf_count<5 and gbf_len_max*5<gbf_win_width then 
39830         let gbf_len_button=int(gbf_win_width/5)
39835       else 
39840         let gbf_len_button=gbf_len_max
39845       end if  ! gbf_count<5 and gbf_len_max*5<gbf_win_width   /   else 
39850     else 
39855       let gbf_len_button=int(gbf_win_width/gbf_count)
39860     end if 
39865   end if  ! gbf_count>0 then
39870   mat gbf_field$(gbf_count)
39875   for gbf_i=1 to gbf_count
39880     let gbf_col=gbf_win_width-(gbf_len_button+1)+1 : let gbf_win_width-=(gbf_len_button+1)
39885     if env$("GUIMODE")="ON" then !:
            let gbf_field$(gbf_i)=(str$(gbf_row)&','&str$(gbf_col)&','&str$(gbf_len_button)&'/Cc '&str$(gbf_len_max)&',[Button]S,B'&gbf_fkey$(gbf_i)) else !:
            let gbf_field$(gbf_i)=(str$(gbf_row)&','&str$(gbf_col)&','&str$(gbf_len_button)&'/Cc '&str$(gbf_len_max)&',[Button_CUI]S,B'&gbf_fkey$(gbf_i))
39890   next gbf_i
39895 fnend  ! fn_get_button_fields
39900 def library fnalldebtors(fileno$,h_debtor,mat alldebtors$,mat alldebtors)
39901   if ~setup_alldebtors then 
39902     if not setup_sql then gosub SETUP_SQL
39903     library "Phonelib.wb/Library": fnread_debtor,fnsearch_debtor
39904     let setup_alldebtors=1
39905   end if  ! Setup_AllDebtors
39910   let _debtorsc=udim(debtor_fieldsc$) !:
        let _debtorsn=udim(debtor_fieldsn$) !:
        mat alldebtors$(0,_debtorsc) !:
        mat alldebtors(0,_debtorsn) !:
        let _d=0
39915   let search_debtor_err=fnsearch_debtor(h_debtor,fileno$,mat debtor_data$,mat debtor_data,"Release") !:
        if search_debtor_err=-4270 or search_debtor_err=-4272 then goto X_FNALLDEBTORS
39920   do while fileno$=debtor_data$(1)
39925     mat alldebtors$(_d+=1,_debtorsc) !:
          mat alldebtors(_d,_debtorsn)
39930     for dj=1 to _debtorsc
39935       let alldebtors$(_d,dj)=debtor_data$(dj)
39940     next dj
39945     for dj=1 to _debtorsn
39950       let alldebtors(_d,dj)=debtor_data(dj)
39955     next dj
39960     let read_debtor_err=fnread_debtor(h_debtor,"",mat debtor_data$,mat debtor_data,"Release") !:
          if search_debtor_err=-4270 or search_debtor_err=-4272 then goto X_FNALLDEBTORS
39965   loop 
39970   let fnalldebtors=_d
39975 X_FNALLDEBTORS: !:
      fnend 
39980 def library fnalldiary(fil_key,fileno$,&mat dc,&mat dd$,&mat dcom$,&mat dqueue$,&mat drec)
39982   let fnalldiary=fnalldiary_(fil_key,fileno$,mat dc,mat dd$,mat dcom$,mat dqueue$,mat drec)
39984 fnend 
39990 def fnalldiary_(fil_key,fileno$,&mat dc,&mat dd$,&mat dcom$,&mat dqueue$,&mat drec)
39995 ! FILENO$ = File Claim Number !:
        ! mat DC = Contains all Diary Codes for Claim !:
        ! mat DD$ = Contains all Diary Dates for the Claim !:
        ! mat COM$ = contains all Diary Comments !:
        ! mat DQUEUE$ = Contains all Diary Queues for the Claim !:
        ! mat DREC = Contains relative records of each Diary record on claim
40000 ! PAUSE
40005 ! Clear all variables and initialize them to 1
40010   mat dc(0)=(0) : mat dd$(0)=("") !:
        mat dcom$(0)=("") : mat dqueue$(0)=("") !:
        mat drec(0)=(0) !:
        let lcount=0
40015   dim readno$,readcode,readcode$,readdate$,readcomm$*20,readque$,readtime$,readpri$,drelrec, open_diafile
40020 L40020: form pos 1,c 8,x 1,b 3,2*c 8,c 20,c 8,c 5,cr 3
40025   if file(fil_key)<0 then !:
          let open_diafile=1 !:
          open #fil_key: "NAME=DIARY.INT//6,KFNAME=DIARY.FIL//6,SHR",internal,input,keyed 
40030   read #fil_key, using L40020,search>=rpad$(fileno$,8),release: readno$,readcode,readcode$,readdate$,readcomm$,readque$,readtime$,readpri$ nokey GET_RESULT
40035 L40035: if trim$(readno$)<>trim$(fileno$) then goto GET_RESULT
40040   let drelrec=rec(fil_key)
40045   let lcount+=1
40050   mat dc(lcount) : mat dd$(lcount) !:
        mat dcom$(lcount) : mat dqueue$(lcount) : mat drec(lcount)
40055 ! PAUSE
40060   let dc(lcount)=readcode !:
        let dd$(lcount)=readdate$ !:
        let dcom$(lcount)=readcomm$ !:
        let dqueue$(lcount)=readque$ !:
        let drec(lcount)=drelrec
40065 NEXT_READ_DIARY: !:
        read #fil_key,using L40020,release: readno$,readcode,readcode$,readdate$,readcomm$,readque$,readtime$,readpri$ eof GET_RESULT
40070   goto L40035
40075 GET_RESULT: let fnalldiary_=lcount
40080   if open_diafile=1 then close #fil_key: 
40085   goto EXIT_FNALLDIARY
40090 EXIT_FNALLDIARY: fnend 
40100 def library fnfind_diary(fil_key,fileno$,mat dc; mat dqueue$,mat fdi_date_range,&fdi_dc_found,&fdi_q_found$)
40105 ! gosub SETUP_LIBRARY
40110 ! fil_key = open file handle for "Name=Diary.Int//6,KFName=Diary.Fil//6,Shr", if 0 the fn will open and close the file itself
40115 ! FILENO$ = File Claim Number !:
        ! mat DC = Contains all Diary Codes to check for !:
        ! mat DQUEUE$ = Contains all Diary Queues to check for
40120 ! fdi_date_range(1)=ccyymmdd starting date filter
40125 ! fdi_date_range(2)=ccyymmdd ending date filter
40130 ! PAUSE
40135 ! Clear all variables and initialize them to 1
40140   let lcount=is_there=0
40145   if udim(mat fdi_date_range)>=2 then let fdi_date_range_filter_enabled=1 else let fdi_date_range_filter_enabled=0
40150 L40150: form pos 1,c 8,x 1,b 3,2*c 8,c 20,c 8,c 5,cr 3
40155   if file(fil_key)<0 then !:
          let open_diafile=1 !:
          open #fil_key: "NAME=DIARY.INT//6,KFNAME=DIARY.FIL//6,SHR",internal,outin,keyed  ! todo: consider implementing fnindex_handle instead  (w/ prior_rec to flag closing (below))
40160   read #fil_key, using L40150,search>=rpad$(fileno$,8),release: readno$,readcode,readcode$,readdate$,readcomm$,readque$,readtime$,readpri$ nokey EXIT_FIND_DIARY
40165   do while trim$(readno$)=trim$(fileno$) ! if trim$(readno$)<>trim$(fileno$) then goto EXIT_FIND_DIARY
40170     let fdi_date_range_filter_passed=0
40175     if fdi_date_range_filter_enabled then 
40180       let readdate_inp10=fndate10_(fndate_inp10_$(readdate$))
40185       let fdi_date_range_filter_passed=fn_is_num_within_range(readdate_inp10,fdi_date_range(1),fdi_date_range(2))
40190     end if  ! fdi_date_range_filter_enabled
40195     let is_there=srch(dc,readcode) !:
          if is_there>0 and (~fdi_date_range_filter_enabled or fdi_date_range_filter_passed) then goto EXIT_FIND_DIARY
40200     let is_there=srch(dqueue$,readque$) !:
          if is_there>0 and (~fdi_date_range_filter_enabled or fdi_date_range_filter_passed) then goto EXIT_FIND_DIARY !:
          else !:
            let is_there=srch(dqueue$,rtrm$(readque$)) !:
            if is_there>0 and (~fdi_date_range_filter_enabled or fdi_date_range_filter_passed) then goto EXIT_FIND_DIARY
40205     read #fil_key,using L40150,release: readno$,readcode,readcode$,readdate$,readcomm$,readque$,readtime$,readpri$ eof EXIT_FIND_DIARY
40210   loop  ! goto 62690
40215 EXIT_FIND_DIARY: !:
        if is_there>0 and (~fdi_date_range_filter_enabled or fdi_date_range_filter_passed) then !:
          let fnfind_diary=1 !:
          let fdi_dc_found=readcode !:
          let fdi_q_found$=readque$ !:
        else !:
          let fnfind_diary=0
40220   if open_diafile=1 then close #fil_key: 
40225 fnend  ! fnfind_diary
40230 def library fnis_num_within_range(diwr_date_test,diwr_date_low,diwr_date_high) ! diwr_
40232   let fnis_num_within_range=fn_is_num_within_range(diwr_date_test,diwr_date_low,diwr_date_high)
40234 fnend  ! fnis_num_within_range
40240 def fn_is_num_within_range(diwr_date_test,diwr_date_low,diwr_date_high) ! diwr_
40242   if diwr_date_test=>diwr_date_low and diwr_date_test<=diwr_date_high then 
40244     let diwr_return=1
40246   else 
40248     let diwr_return=0
40250   end if  ! diwr_date_test=>diwr_date_low and diwr_date_test<=diwr_date_high   /   else 
40252   let fn_is_num_within_range=diwr_return
40254 fnend  ! fn_is_num_within_range
40260 def library fnlast_paper(fileno$,active_handle,mat user_initials$,mat lp_code_filter$,lp_matches,mat l_code$,mat l_paper$,mat l_date$; single_line_note_format)
40262   let fnlast_paper=fnlastpaper(fileno$,active_handle,mat user_initials$,mat lp_code_filter$,lp_matches,mat l_code$,mat l_paper$,mat l_date$, single_line_note_format)
40264 fnend 
40270 def fnlastpaper(fileno$,active_handle,mat user_initials$,mat lp_code_filter$,lp_matches,mat l_code$,mat l_paper$,mat l_date$; single_line_note_format)
40275 ! outside this funtion you should    Dim L_Code$(1)*60,L_Paper$(1)*1024
40280 ! This function returns something based on LP_Matches (See below)
40285 ! mat User_Initials$ - contains array of qualifiying user initials - Dim to 0 to not use
40290 ! mat LP_Code_Filter$ - contains array of qualifiying Codes - Dim to 0 to not use
40295 ! mat L_Code$ - contains the Paperless Codes (replace '' with leading code).
40300 ! mat L_Paper$ - contains the Papeless Notes. Replace Categs and letters. See lines 2180 and 2250 of Prog2\Status.wb
40305 ! mat L_Date$ - contains the Paperless Transaction Dates
40310 ! LP_Matches - will be passed to this function
40315 !           if the number of notes is less than LP_Matches, but greater than 0 than the funciton will return a -1
40320 !           if the no matching notes are found, the function will return 0
40325 !           the function stops searching when LP_Matches is reached  and the function returns 1
40330 ! Single_Line_Note_Format - if 1 than combine the notes for each matched entry into 1 array item each.
40335   if ~l2p_setup then 
40340     dim active_current_code$(1)*8,active_current_paperless_cmt1$(1)*28,active_current_paperless_cmt2$(1)*20,active_current_l_date$(1)*8
40345     gosub SETUP_SQL_ACTIVE
40350     let active_code_ditto$="  ''    "
40355     let true=1 : let false=0
40360   end if 
40365   let lp_matches_encountered=0
40370   mat l_code$(0) : mat l_paper$(0) : mat l_date$(0)
40375   gosub L2P_CURRENT_RESET
40380   let fileno$=rpad$(fileno$,8)
40385   let user_initial_count=udim(mat user_initials$)
40390   let lp_code_filter_count=udim(mat lp_code_filter$)
40395   if lp_code_filter_count>0 then let fn_add_one$(mat lp_code_filter$,trim$(active_code_ditto$)) : let lp_code_filter_count+=1
40400   let key_after$=fnkeyafter$(fileno$,active_handle)
40405   read #active_handle,using active_formall$,key>=key_after$: mat active_data$,mat active_data nokey L2P_NOKEY
40410   read #active_handle,using active_formall$,prior,release: mat active_data$,mat active_data eof L2P_ACTIVE_EOF
40415 L2P_DO_LOOP: ! 
40420   do until lp_matches_encountered>=lp_matches or active_data$(active_fileno)<>fileno$
40425     let active_user_initials$=trim$(fninit_$(active_data(active_user_id)))
40430     let active_code$=uprc$(trim$(active_data$(active_code)))
40435     if user_initial_count=0 then let initial_match=999999 else let initial_match=srch(mat user_initials$,active_user_initials$)
40440     if lp_code_filter_count=0 then let code_match=999999 else let code_match=srch(mat lp_code_filter$,active_code$)
40445     if initial_match>0 and code_match>0 then ! it needs to be added
40450       if active_data$(active_code)=active_code_ditto$ then ! Is a part of Next Read Note
40455         let last_add_was_a_ditto=1
40460         gosub L2P_CURRENT_ADD
40465       else ! Is NOT a part of Next Read Note
40470         let last_add_was_a_ditto=0
40475         gosub L2P_CURRENT_ADD
40480         let fnl2p_add_note(mat l_code$,mat l_paper$,mat l_date$,mat active_current_code$,mat active_current_paperless_cmt1$,mat active_current_paperless_cmt2$, mat active_current_l_date$)
40485         let lp_matches_encountered+=1
40490         gosub L2P_CURRENT_RESET
40495       end if  ! Active_Data$(Active_CODE)=Active_Code_Ditto$
40500     else ! don't add it, and if necessary remove the last batch of the previously added ditto records
40505       if last_add_was_a_ditto then gosub L2P_REMOVE_PRIOR_DITTO_ADDS
40510     end if  ! Initial_Match>0 and CODE_MATCH>0
40515     read #active_handle,using active_formall$,prior,release: mat active_data$,mat active_data eof L2P_ACTIVE_EOF
40520   loop 
40525   goto XIT_FNLASTPAPER
40530 L2P_ACTIVE_EOF: ! 
40535   goto XIT_FNLASTPAPER
40540 L2P_NOKEY: ! 
40545   restore #active_handle,last: 
40550   goto L2P_DO_LOOP
40555 L2P_CURRENT_ADD: ! 
40560   let fn_add_one$(mat active_current_code$,active_data$(active_code))
40565   let fn_add_one$(mat active_current_paperless_cmt1$,active_data$(active_paperless_cmt1))
40570   let fn_add_one$(mat active_current_paperless_cmt2$,fnstriptime$(active_data$(active_paperless_cmt2)))
40575   let fn_add_one$(mat active_current_l_date$,str$(active_data(active_trans_date)))
40580   return 
40585 L2P_REMOVE_PRIOR_DITTO_ADDS: ! 
40590   let active_current_code_item=udim(mat active_current_code$)+1
40595   do while (active_current_code_item-=1)>0 and active_current_code$(active_current_code_item)=active_code_ditto$
40600     mat active_current_code$(active_current_code_item-1)
40605     mat active_current_paperless_cmt1$(active_current_code_item-1)
40610     mat active_current_paperless_cmt2$(active_current_code_item-1)
40615     mat active_current_l_date$(active_current_code_item-1)
40620   loop 
40625   return  ! L2P_REMOVE_PRIOR_DITTO_ADDS
40630 L2P_CURRENT_RESET: ! 
40635   mat active_current_code$(0) : mat active_current_paperless_cmt1$(0) : mat active_current_paperless_cmt2$(0) : mat active_current_l_date$(0)
40640   return 
40645 XIT_FNLASTPAPER: ! 
40650 ! 
40655   let lp_slnf_item=udim(mat l_code$)
40660   if single_line_note_format and lp_slnf_item>0 then 
40665     do 
40670       if l_code$(lp_slnf_item)=active_code_ditto$ then 
40675         let l_paper$(lp_slnf_item-1)=trim$(l_paper$(lp_slnf_item-1))&" "&trim$(l_paper$(lp_slnf_item))
40680         let fnremovearrayitem$(mat l_code$,lp_slnf_item)
40685         let fnremovearrayitem$(mat l_paper$,lp_slnf_item)
40690         let fnremovearrayitem$(mat l_date$,lp_slnf_item)
40695       end if  ! L_Code$(LP_SLNF_Item)=Active_Code_Ditto$
40700       let lp_slnf_item-=1
40705     loop until lp_slnf_item<=1
40710 ! 
40715   end if  ! Single_Line_Note_Format
40720   if single_line_note_format and udim(l_paper$)<lp_matches then 
40725     mat l_paper$(lp_matches) : mat l_code$(lp_matches) : mat l_date$(lp_matches)
40730   end if 
40735 ! 
40740   if lp_matches_encountered=lp_matches then 
40745     let set_fnlastpaper=1
40750   else if lp_matches_encountered=0 then 
40755     let set_fnlastpaper=0
40760   else if lp_matches_encountered>0 then 
40765     let set_fnlastpaper=-1
40770   end if  ! LP_Matches_Encountered=LP_Matches   /   LP_Matches_Encountered=0   /   LP_Matches_Encountered>0
40775 ! 
40780   let fnlastpaper=set_fnlastpaper
40785 fnend 
40790 def fnl2p_add_note(mat l_code$,mat l_paper$,mat l_date$,mat code_add$,mat active_current_paperless_cmt1$,mat active_current_paperless_cmt2$,mat date_add$)
40795   dim l_code_reversed$(1)*80,l_paper_reversed$(1)*80,l_date_reversed$(1)*8
40800   dim l_code_before$(1)*80,l_paper_before$(1)*80,l_date_before$(1)*8
40805   dim paper_add$(1)*80
40810   let l_paper_udim=udim(code_add$)
40815   mat paper_add$(l_paper_udim)
40820   for x_item=1 to l_paper_udim
40825     let paper_add$(x_item)=fnactive_cmt_combine_$(active_current_paperless_cmt1$(x_item),active_current_paperless_cmt2$(x_item),code_add$(x_item))
40830   next x_item
40835   mat l_code_before$(udim(l_code$)) : mat l_code_before$=l_code$
40840   mat l_paper_before$(udim(l_code$)) : mat l_paper_before$=l_paper$
40845   mat l_date_before$(udim(l_code$)) : mat l_date_before$=l_date$
40850   let fnarrayreverse$(mat paper_add$,mat l_paper_reversed$)
40855   let fnarrayreverse$(mat code_add$,mat l_code_reversed$)
40860   let fnarrayreverse$(mat date_add$,mat l_date_reversed$)
40865   let fn_array_add$(mat l_code$,mat l_code_reversed$,mat l_code_before$)
40870   let fn_array_add$(mat l_paper$,mat l_paper_reversed$,mat l_paper_before$)
40875   let fn_array_add$(mat l_date$,mat l_date_reversed$,mat l_date_before$)
40880 fnend 
40890 def library fnactive_cmt_combine$*68(active_paperless_cmt1$*28,active_paperless_cmt2$*28,active_code$*8)
40892   let fnactive_cmt_combine$=fnactive_cmt_combine_$(active_paperless_cmt1$,active_paperless_cmt2$,active_code$)
40894 fnend 
40900 def fnactive_cmt_combine_$*68(active_paperless_cmt1$*28,active_paperless_cmt2$*28,active_code$*8)
40905   if acc_setup=0 then 
40910 !    library "Library\CLSUtil": fnCateg2_$, fnReadLetter_Desc,fnVal_
40915     dim temp_desc$*40,letters_desc$*27,temp_desc_2$*40
40920     let acc_setup=true=1
40925   end if 
40930   let temp_desc$=active_paperless_cmt2$
40935   let temp_desc_2$=fncateg2_$(fnval_(active_code$))
40940   if temp_desc_2$<>"" then 
40945     let temp_desc$=temp_desc_2$
40950   else 
40955     if fnreadletter_desc(active_code$,letters_desc$)=1 then let temp_desc$=letters_desc$&" "
40960   end if 
40965   let fnactive_cmt_combine_$=temp_desc$&active_paperless_cmt1$
40970 fnend 
40980 def library fnstrip_time$*48(acmt$*48)
40982   let fnstrip_time$=fnstriptime$(acmt$)
40984 fnend 
40990 def fnstriptime$*48(acmt$*48)
40995   let tyme=val(acmt$(1:2)) conv X_STRIP_TIME
41000   if acmt$(3:3)=":" then let acmt$=ltrm$(acmt$(6:99))
41005 X_STRIP_TIME: ! 
41010   let fnstriptime$=acmt$
41015 fnend 
41020 def library fnarray_add$(mat array_combined$,mat array_part_one$,mat array_part_two$)
41022   let fnarray_add$=fn_array_add$(mat array_combined$,mat array_part_one$,mat array_part_two$)
41024 fnend 
41030 def fn_array_add$(mat array_combined$,mat array_part_one$,mat array_part_two$)
41035   let array_part_one_udim=udim(array_part_one$)
41040   let array_part_two_udim=udim(array_part_two$)
41045   let array_combined_udim=array_part_one_udim+array_part_two_udim
41050   mat array_combined$(array_combined_udim)
41055   if array_part_one_udim=0 then 
41060     mat array_combined$=array_part_two$
41065   else if array_part_two_udim=0 then 
41070     mat array_combined$=array_part_one$
41075   else if array_part_one_udim>0 and array_part_two_udim>0 then 
41080     mat array_combined$(1:array_part_one_udim)=array_part_one$(1:array_part_one_udim)
41085     mat array_combined$(array_part_one_udim+1:array_combined_udim)=array_part_two$(1:array_part_two_udim)
41090   end if 
41095 fnend 
41100 def library fnarray_add(mat array_combined,mat array_part_one,mat array_part_two)
41102   let fnarray_add=fn_array_add(mat array_combined,mat array_part_one,mat array_part_two)
41104 fnend 
41110 def fn_array_add(mat array_combined,mat array_part_one,mat array_part_two)
41115   let array_part_one_udim=udim(array_part_one)
41120   let array_part_two_udim=udim(array_part_two)
41125   let array_combined_udim=array_part_one_udim+array_part_two_udim
41130   mat array_combined(array_combined_udim)
41135   if array_part_one_udim=0 then 
41140     mat array_combined=array_part_two
41145   else if array_part_two_udim=0 then 
41150     mat array_combined=array_part_one
41155   else if array_part_one_udim>0 and array_part_two_udim>0 then 
41160     mat array_combined(1:array_part_one_udim)=array_part_one(1:array_part_one_udim)
41165     mat array_combined(array_part_one_udim+1:array_combined_udim)=array_part_two(1:array_part_two_udim)
41170   end if 
41175 fnend 
41180 def library fnarray_reverse$(mat in$,mat out$)
41182   let fnarray_reverse$=fnarrayreverse$(mat in$,mat out$)
41184 fnend 
41190 def fnarrayreverse$(mat in$,mat out$)
41195   let in_udim=udim(in$)
41200   mat out$(in_udim)
41205   for in_item=1 to in_udim
41210     let out$(in_udim-in_item+1)=in$(in_item)
41215   next in_item
41220 fnend 
41230 def library fnarrary_val(mat av_source$,mat av_destination)
41232   let fnarrary_val=fnarraryval(mat av_source$,mat av_destination)
41234 fnend  ! fnArrary_Val
41240 def fnarraryval(mat av_source$,mat av_destination)
41245   let av_source_count=udim(mat av_source$)
41250   mat av_destination(av_source_count)
41255   for _av_source=1 to av_source_count
41260     let av_destination(_av_source)=fnval_(av_source$(_av_source))
41265   next _av_source
41270 fnend  ! fnArraryVal
41280 def library fnkey_after$*128(key$*128,file_handle)
41282   let fnkey_after$=fnkeyafter$(key$,file_handle)
41284 fnend 
41290 def fnkeyafter$*128(key$*128,file_handle)
41295   let key$=rpad$(key$,kln(file_handle))
41300   let key_len=len(key$)
41305   let fnkeyafter$=key$(1:key_len-1)&chr$(ord(key$(key_len:key_len))+1)
41310 fnend 
41320 def library fnmask$*60(mask$*512;mask_len)
41322   let fnmask$=fn_mask$(mask$,mask_len)
41324 fnend 
41330 def fn_mask$*60(mask$*512;mask_len)
41335   if mask_len=0 then let mask_len=-4
41340   let mask$=rtrm$(mask$)
41345   if mask_len<0 then let mask_base$=mask$(len(mask$)+mask_len+1:512) !:
          let fn_mask$=fn_mask_it$(mask$(1:len(mask$)+mask_len))&mask_base$ !:
        else !:
          let mask_base$=mask$(1:mask_len) !:
          let fn_mask$=mask_base$&fn_mask_it$(mask$(mask_len+1:512))
41350 fnend  ! fn_mask$
41360 def fn_mask_it$*1024(mask_string$*1024)
41365   for _chr=ord('0') to ord('9')
41370     let mask_string$=srep$(mask_string$,chr$(_chr),'*')
41375   next _chr
41380   for _chr=ord('A') to ord('Z')
41385     let mask_string$=srep$(mask_string$,chr$(_chr),'*')
41390   next _chr
41395   for _chr=ord('a') to ord('z')
41400     let mask_string$=srep$(mask_string$,chr$(_chr),'*')
41405   next _chr
41410   let fn_mask_it$=mask_string$
41415 fnend  ! fn_mask_it$
41420 def fn_mask_cc$*80(mc_in$*80)
41425 ! The first 6 characters AND the last 4 characters should be displayed.
41430   dim mc_return$*80
41435   let mc_return$=mc_in$
41440   let mc_in_len=len(rtrm$(mc_in$))
41445   if mc_in_len>10 then 
41450     let mc_return$(7:mc_in_len-4)=fn_mask_it$(mc_return$(7:mc_in_len-4))
41455   end if  ! mc_in_len>10
41460   let fn_mask_cc$=mc_return$
41465 fnend  ! fn_mask_cc$
41470 def fnread_matrix(matrix_type$,llcode$,edimatrix_handle)
41472   let tllcode$=tmatrix$=tforw$=edi_code$="" !:
        mat action$=("") !:
        let llcode$=uprc$(rpad$(llcode$(1:8),8)) !:
        let matrix_llcode$=llcode$ !:
        ! todo: fix "Skip"&Str$(fow) when 5-digit fow
41474 READ_MATRIX: read #edimatrix_handle,using L41482,key=llcode$&matrix_type$(1:8)&rpad$(str$(fow),5),release: tllcode$,tmatrix$,tforw$,edi_code$,mat action$ nokey L41476 !:
        goto L41482
41476 L41476: read #edimatrix_handle,using L41482,key=llcode$&matrix_type$(1:8)&rpad$(sort$,5),release: tllcode$,tmatrix$,tforw$,edi_code$,mat action$ nokey L41478 !:
        goto L41482
41478 L41478: read #edimatrix_handle,using L41482,key=llcode$&matrix_type$(1:8)&"     ",release: tllcode$,tmatrix$,tforw$,edi_code$,mat action$ nokey CHECK_MATRIX_SUBCODE !:
        goto L41482
41479 CHECK_MATRIX_SUBCODE: !:
        let matrix_llcode=val(matrix_llcode$) conv NO_MATRIX !:
        if matrix_llcode<>int(matrix_llcode) then !:
          let matrix_llcode$=rpad$(str$(int(matrix_llcode)),8) !:
          goto READ_MATRIX
41480 NO_MATRIX: let fnread_matrix=0 !:
        goto L41486
41482 L41482: form pos 1,c 8,c 8,pos 109,c 5,pos 21,c 8,10*(c 8)
41484   let fnread_matrix=1
41486 L41486: fnend 
41490 def library fnedi_today(fow,fileno$,fow_handle,activ_handle,edimatrix_handle,tempwp_handle,edi_matrix_handle2)
41495   dim extra$*50,cmt$*50
41500 F20: form c 8,bh 4,bh 4,c 28,c 20,c 8,c 1
41505 R17: form pos 1,c 8,pos 41,c 8
41510 RFOW: form pos 152,c 4,pos 667,c 10
41515   let todays_code=0
41520   read #fow_handle,using RFOW,rec=fow,release: sort$,edi_type$ norec AUTO_PASS
41525   if trim$(edi_type$)="" then goto AUTO_PASS !:
        else !:
          let edi_type$=srep$(edi_type$,"C_CON ","CC_F2C") !:
          let edi_type$=srep$(edi_type$,"SFGAG   ","SHERFINL")
41530   read #edi_matrix_handle2,using L41482,key=edi_type$(1:8),release: tllcode$,tmatrix$ nokey AUTO_PASS
41535   if trim$(tmatrix$)<>trim$(edi_type$(1:8)) then goto AUTO_PASS !:
          ! DEFAULT is not the only entry
41540   let skip_this_fow=fnread_matrix(edi_type$,"SKIP"&str$(fow),edimatrix_handle) !:
        if skip_this_fow then goto AUTO_PASS
41545   let search$=fileno$
41550   let ored=ord(fileno$(8:8))
41555   let search$(8:8)=chr$(ored+1)
41560   read #activ_handle,using F20,search>=search$,release: afileno$,numdat,time,cmt$,extra$,llcode$ nokey ET_ACTIVE_CHK
41565   read #activ_handle,using F20,prior,release: afileno$,numdat,time,cmt$,extra$,llcode$,type$ norec ET_ACTIVE_CHK eof ET_ACTIVE_CHK
41570   do while numdat=date('ccyymmdd') and afileno$=fileno$
41575 ! PRINT AFILENO$,NUMDAT,LLCODE1$ : PAUSE
41580     let todays_code=fnread_matrix(edi_type$,llcode$,edimatrix_handle) !:
          if todays_code then exit do 
41585     read #activ_handle,using F20,prior,release: afileno$,numdat,time,cmt$,extra$,llcode$,type$ norec ET_ACTIVE_CHK eof ET_ACTIVE_CHK
41590   loop 
41595 ET_ACTIVE_CHK: !:
        if not todays_code then goto CHECK_TEMPWP
41600 AUTO_PASS: let fnedi_today=1 !:
        ! either not a edi fow or has matrix entry today !:
        goto EXIT_EDI
41605 CHECK_TEMPWP: let wpfileno$="" !:
        read #tempwp_handle,using R17,search>=fileno$,release: wpfileno$,llcode$ nokey EXIT_EDI
41610   do while wpfileno$=fileno$
41615     let todays_code=fnread_matrix(edi_type$,llcode$,edimatrix_handle) !:
          if todays_code then exit do 
41620     read #tempwp_handle,using R17,release: wpfileno$,llcode$ eof EXIT_EDI
41625   loop 
41630   if todays_code then goto AUTO_PASS
41635 EXIT_EDI: fnend 
41640 def library fngetuser ! returns User_ID
41642   if ~user_setup then let fnget_user
41644   let fngetuser=user
41646 fnend 
41650 def fnget_user
41655   open #userlist:=fngethandle_: "NAME=USERLIST//8,KFNAME=USERLIST.NAM//8,SHR",internal,outin,keyed ioerr EXIT_GETUSER !:
        open #whoami:=fngethandle_: "namE=N:WHOAMI,SHR",internal,outin,relative ioerr EXIT_GETUSER
41660   read #whoami,using "FORM POS 1,C 20",release: wp$
41665   let user_setup=1 !:
        let user_queue$="" !:
        let user=0 !:
        read #userlist,using "FORM pos 21,c 3,POS 84,C 8,pos 94,c 2,POS 102,2*C 3",key=wp$,release: user_init$,user_queue$,use_mini$,mystartup$,mystatus$ nokey L41670 !:
        let user=rec(userlist) !:
        let fnget_user=user
41670 L41670: close #userlist: ioerr L41675
41675 L41675: close #whoami: ioerr EXIT_GETUSER
41679 EXIT_GETUSER: fnend 
41680 def library fnget_user_queue$
41681   if ~user_setup then 
41682     open #userlist:=fngethandle_: "NAME=USERLIST//8,KFNAME=USERLIST.NAM//8,SHR",internal,outin,keyed ioerr EXIT_GETUSER_QUEUE !:
          open #whoami:=fngethandle_: "namE=N:WHOAMI,SHR",internal,outin,relative ioerr EXIT_GETUSER_QUEUE
41683     read #whoami,using "FORM POS 1,C 20",release: wp$ eof GETUSER_QUEUE_XIT
41684     let user_setup=1 !:
          let user_queue$="" !:
          let user=0 !:
          read #userlist,using "FORM pos 21,c 3,POS 84,C 8,pos 94,c 2,POS 102,2*C 3",key=wp$,release: user_init$,user_queue$,use_mini$,mystartup$,mystatus$ nokey L41686 !:
          let user=rec(userlist)
41685 GETUSER_QUEUE_XIT: ! 
41686 L41686: close #userlist: ioerr L41687
41687 L41687: close #whoami: ioerr EXIT_GETUSER_QUEUE
41688   end if  ! if ~User_Setup
41689 EXIT_GETUSER_QUEUE: !:
        let fnget_user_queue$=user_queue$ !:
      fnend 
41690 def library fnget_user_init$
41695   open #userlist:=fngethandle_: "NAME=USERLIST//8,KFNAME=USERLIST.NAM//8,SHR",internal,outin,keyed ioerr EXIT_GETUSER_INIT !:
        open #whoami:=fngethandle_: "namE=N:WHOAMI,SHR",internal,outin,relative ioerr EXIT_GETUSER_INIT
41700   read #whoami,using "FORM POS 1,C 20",release: wp$ eof GETUSER_XIT
41705   let user_setup=1 !:
        let user_queue$="" !:
        let user=0 !:
        read #userlist,using "FORM pos 21,c 3,POS 84,C 8,pos 94,c 2,POS 102,2*C 3",key=wp$,release: user_init$,user_queue$,use_mini$,mystartup$,mystatus$ nokey L41715 !:
        let user=rec(userlist) !:
        let fnget_user_init$=user_init$
41710 GETUSER_XIT: ! 
41715 L41715: close #userlist: ioerr L41720
41720 L41720: close #whoami: ioerr EXIT_GETUSER_INIT
41725 EXIT_GETUSER_INIT: fnend 
41730 def library fnd_relation(debtor_handle,f$,mat d_rel$)
41735   mat d_rel$(0)
41740   read #debtor_handle,using FDEBTOR,search>=f$,release: fileno$,d_rel$ nokey EXIT_D_REL
41745   do while fileno$=f$
41750     let ele=udim(d_rel$)+1 !:
          mat d_rel$(ele) !:
          let d_rel$(ele)=trim$(d_rel$)
41755     read #debtor_handle,using FDEBTOR,release: fileno$,d_rel$ eof EXIT_D_REL
41760   loop 
41765 FDEBTOR: form c 8,pos 12,c 10
41770 EXIT_D_REL: let fnd_relation=ele !:
      fnend 
41780 def library fnstretch(mat array$)
41782   let fnstretch=fnstretch_(mat array$)
41784 fnend 
41790 def fnstretch_(mat array$)
41792   let xele=udim(array$) !:
        let xele+=1 !:
        mat array$(xele) !:
        let fnstretch_=xele
41794 fnend 
41800 def library fnstretch_n(mat array)
41802   let fnstretch_n=fnstretch_n_(mat array)
41804 fnend 
41810 def fnstretch_n_(mat array)
41812   let xele=udim(array) !:
        let xele+=1 !:
        mat array(xele) !:
        let fnstretch_n_=xele
41814 fnend 
41820 def library fnwp_delim$(delim$)
41825   if delim$="<CRLF>" then !:
          let delim$=chr$(13)&chr$(10) !:
          goto EXIT_WP_DELIM
41830   if delim$="<COMMA>" then !:
          let delim$=chr$(44)&" " !:
          goto EXIT_WP_DELIM
41835   if delim$="<SEMI-COLON>" then !:
          let delim$=chr$(59)&" " !:
          goto EXIT_WP_DELIM
41840   if delim$="<TAB>" then !:
          let delim$=chr$(9) !:
          goto EXIT_WP_DELIM
41845   let delim$=chr$(32) !:
        ! if delim$="<SPACE>" or anything else assign space as default
41850 EXIT_WP_DELIM: !:
        let fnwp_delim$=delim$
41855 fnend 
41860 def library fndiaryselect(mat l_diary,mat h_diary,mat l_diary$,mat h_diary$,mat l_master,mat h_master,mat l_master$,mat h_master$,mat mast_filtersn$,mat mast_filtersc$,mat dia_filtersn$,mat dia_filtersc$,mat adv_filters$; nnp,auto_flag,mat auto_fieldsc$,mat auto_fieldsn$,mat auto_datac$,mat auto_datan,btn_r1_fkeys$*50,btn_r1_captions$*100,btn_r2_fkeys$*50,btn_r2_captions$*100,ds_pk$*50,ds_help_fkey,new_stuff$*4096,callingprogramtitle$*1000)
41870   if ~setup then let fn_setup
41880   let fndiaryselect_(mat l_diary,mat h_diary,mat l_diary$,mat h_diary$,mat l_master,mat h_master,mat l_master$,mat h_master$,mat mast_filtersn$,mat mast_filtersc$,mat dia_filtersn$,mat dia_filtersc$,mat adv_filters$, nnp,auto_flag,mat auto_fieldsc$,mat auto_fieldsn$,mat auto_datac$,mat auto_datan,btn_r1_fkeys$,btn_r1_captions$,btn_r2_fkeys$,btn_r2_captions$,ds_pk$,ds_help_fkey,new_stuff$,callingprogramtitle$)
41900 fnend  ! fndiaryselect
41910 def fndiaryselect_(mat l_diary,mat h_diary,mat l_diary$,mat h_diary$,mat l_master,mat h_master,mat l_master$,mat h_master$,mat mast_filtersn$,mat mast_filtersc$,mat dia_filtersn$,mat dia_filtersc$,mat adv_filters$; nnp,auto_flag,mat auto_fieldsc$,mat auto_fieldsn$,mat auto_datac$,mat auto_datan,btn_r1_fkeys$*50,btn_r1_captions$*100,btn_r2_fkeys$*50,btn_r2_captions$*100,ds_pk$*50,ds_help_fkey,new_stuff$*4096,callingprogramtitle$*1000)
41920 !  if ~Setup THEN GOTO FN_SETUP
41922 ! if New_Stuff$='' THEN
41930   let fnfilterselect(mat l_diary,mat h_diary,mat l_diary$,mat h_diary$,mat l_master,mat h_master,mat l_master$,mat h_master$,mat mast_filtersn$,mat mast_filtersc$,mat dia_filtersn$,mat dia_filtersc$,mat adv_filters$, nnp,auto_flag,mat auto_fieldsc$,mat auto_fieldsn$,mat auto_datac$,mat auto_datan,btn_r1_fkeys$,btn_r1_captions$,btn_r2_fkeys$,btn_r2_captions$,ds_pk$,ds_help_fkey,callingprogramtitle$)
41932 ! else 
41934 !  LET Fnfilterselect2(Mat L_Diary,Mat H_Diary,Mat L_Diary$,Mat H_Diary$,Mat L_Master,Mat H_Master,Mat L_Master$,Mat H_Master$,Mat Mast_Filtersn$,Mat Mast_Filtersc$,Mat Dia_Filtersn$,Mat Dia_Filtersc$,Mat Adv_Filters$, Nnp,Auto_Flag,Mat Auto_Fieldsc$,Mat Auto_Fieldsn$,Mat Auto_Datac$,Mat Auto_Datan,Btn_R1_Fkeys$,Btn_R1_Captions$,Btn_R2_Fkeys$,Btn_R2_Captions$,Ds_Pk$,Ds_Help_Fkey,New_Stuff$)
41938 ! end if
41940 fnend 
42780 def fntest(dait$)
42782   dim dait
42784   let result=1
42786   let dait=val(srep$(dait$,"/","")) conv L42790
42788   if days(dait) then let result=0 !:
          goto L42790
42790 L42790: let fntest=result
42792 fnend 
42800 def library fngetdefault_diarydates(&start$,&end$)
42802   let fngetdefault_diarydates_(start$,end$)
42804 fnend 
42810 def fngetdefault_diarydates_(&start$,&end$)
42815   let diary_handle=fngethandle_
42820   open #diary_handle: "name=diary.int//6,kfname=diary.dat//6,shr",internal,input,keyed 
42825 L42825: read #diary_handle,using DIARY_FORM,release: start$ eof L42835
42830   if fntest(start$) then goto L42825
42835 L42835: close #diary_handle: 
42840   let start$=fndate10_$(start$)
42845 DIARY_FORM: form pos 21,c 8
42850   let end$=date$("CCYY/MM/DD")
42855   if end$<start$ then let end$=start$
42860 fnend 
42870 def library fngetdefault_queues(&lqueue$,&hqueue$)
42872   let fngetdefault_queues_(lqueue$,hqueue$)
42874 fnend 
42880 def fngetdefault_queues_(&lqueue$,&hqueue$)
42885 D_FORM: form pos 49,c 8
42890 ! 
42895   let d_handle=fngethandle_
42900   open #d_handle: "name=diary.int//6,kfname=diary.que//6,shr",internal,input,keyed 
42905   let nqlen=kln(d_handle,1)
42910   read #d_handle,using D_FORM,first,release: lqueue$ eof ignore
42915   read #d_handle,using D_FORM,last,release: hqueue$ eof ignore
42920   close #d_handle: 
42925   let lqueue$=uprc$(rpad$(lqueue$(1:nqlen),nqlen)) !:
        let hqueue$=uprc$(rpad$(hqueue$(1:nqlen),nqlen))
42930 fnend 
42940 def library fnsql_filter(sql_filenum,fileno$*23,&last_fileno$,mat sql_data$,mat sql_data,mat sql_fieldsc$,mat sql_fieldsn$,&sql_formc$,&sql_formn$,mat sql_fc$,mat sql_fn$,filename$,mat low_sql,mat high_sql,mat low_sql$,mat high_sql$,mat sql_filtersc$,mat sql_filtersn$)
42945   dim filter_field$*80,sql_value$*80
42950   let sql_filter=1 !:
        ! 1=TRUE OR PASSES FILTER TEST!
42955   if trim$(sql_filtersc$(1))="" and trim$(sql_filtersn$(1))="" then goto SQL_FILTER_XIT
42960   gosub SQL_READ
42965   if trim$(sql_filtersc$(1))="" then goto SQL_FILTER_NUM
42970 SQL_FILTER_CHAR: for nchar=1 to udim(sql_filtersc$)
42975     let filter_field$=sql_filtersc$(nchar) !:
          let sql_type$=fn_sql_type$(filter_field$,mat sql_fieldsc$,mat sql_fieldsn$,filename$,sql_loc) !:
          let sql_value$="??"&filter_field$&"??"
42980     if trim$(sql_type$)(1:1)="C" then let sql_value$=sql_data$(sql_loc) else !:
            if trim$(sql_type$)="N" then let sql_value$=str$(sql_data(sql_loc)) else !:
              if trim$(sql_type$)="ND" then let sql_value$=fndate10_$(str$(sql_data(sql_soc))) !:
                goto SQL_REPORT_ND else !:
                if trim$(sql_type$)="D" then let sql_value$=fndate10_$(sql_data$(sql_loc))
42985     if sqlvalue$="??"&filter_field$&"??" then goto L42995 !:
            ! ** if the field does not exist, then simply ignore it!!!
42990     if sql_value$>=low_sql$(nchar) and sql_value$<=high_sql$(nchar) then !:
            let this_filter=1 else !:
            let this_filter=sql_filter=0 !:
            let nchar=udim(sql_filtersc$)+1
42995 L42995: next nchar
43000 SQL_FILTER_NUM: if sql_filter=0 then goto SQL_FILTER_XIT
43005   if trim$(sql_filtersn$(1))="" then goto SQL_FILTER_XIT
43010   for nvalue=1 to udim(sql_filtersn$)
43015     let filter_field$=sql_filtersn$(nvalue) !:
          let sql_type$=fn_sql_type$(filter_field$,mat sql_fieldsc$,mat sql_fieldsn$,filename$,sql_loc) !:
          let sql_value=-202020202
43020     if trim$(sql_type$)(1:1)="C" then let sql_value=fnval_(sql_datac(sql_loc)) else !:
            if trim$(sql_type$)="N" then let sql_value=sql_data(sql_loc) else !:
              if trim$(sql_type$)="ND" then let sql_value=fndate10_(sql_data(sql_soc)) !:
                goto SQL_REPORT_ND else !:
                if trim$(sql_type$)="D" then let sql_value=fndate10_(sql_data(sql_loc))
43025     if sqlvalue=-202020202 then goto L43035 !:
            ! ** if the field does not exist, then simply ignore it!!!
43030     if sql_value>=low_sql(nvalue) and sql_value<=high_sql(nvalue) then !:
            let this_filter=1 else !:
            let this_filter=sql_filter=0 !:
            let nvalue=udim(sql_filtersn$)+1
43035 L43035: next nvalue
43040 SQL_FILTER_XIT: ! 
43045   let fnsql_filter=sql_filter
43050 fnend  ! FnSql_Filter
43060 ! Status Suite - top
43070 def fn_setup_status
43072   if ~setup_status then 
43074     let setup_status=1
43076     if ~setup then let fn_setup
43078     if ~setup_sql_status then let fn_setup_sql_status
43080     let setup_status=1
43082     dim status_desc$(1)*60,status_code$(1)*3,status_option$(1)*64,status_desc$*60
43084     mat status_desc$(0) : mat status_code$(0) : mat status_option$(0)
43086     let status_count=0
43088     let super_handle=fnsuperopen((mfile$:="Status.Int//9"),vrec,chunk,rpos,file_size,trec,head)
43090     let status_record_count=(file_size-head)/vrec
43092     mat status_desc$(status_record_count) : mat status_code$(status_record_count) : mat status_option$(status_record_count)
43094     if rpos>chunk then goto SETUP_STATUS_FINIS
43096     do 
43098       read #super_handle,using EXT_CHUNK,pos=rpos,release: ext_buff$
43100       for vpos=1 to chunk step vrec
43102         reread #super_handle,using SETUP_STATUS_EXT_FORM: deleted$,mat status_data$
43104         let buff$=ext_buff$(vpos+1:vpos+trec)
43106         let nstatus+=1
43108 SETUP_STATUS_EXT_FORM: form pos vpos,c 1,c 3,c 60
43110         if trim$(deleted$)="" and trim$(buff$(1:50))<>"" then ! And Nstatus<=999   ! TODO: Remove this uneeded line
43112           let status_count+=1
43114           let status_desc$(status_count)=status_data$(status_description)
43116           let status_code$(status_count)=status_data$(status_code)
43118           let status_option$(status_count)=status_data$(status_code)&bar$&status_data$(status_description)
43120         end if  ! trim$(deleted$)="" and trim$(buff$(1:50))<>"" and nstatus<=999
43122       next vpos
43124 ! if Nstatus>999 THEN GOTO SETUP_STATUS_FINIS ! TODO: Remove this uneeded line
43126       let rpos+=chunk
43128       if rpos>=file_size-chunk then 
43130         if rpos>=file_size then goto SETUP_STATUS_FINIS
43132         let chunk=file_size-rpos
43134         close #super_handle: 
43136         open #super_handle: "Name="&trim$(mfile$)&",RecL="&str$(chunk)&",Shr",external,outin,relative 
43138       end if  ! rpos>=file_size-chunk
43140     loop 
43150 SETUP_STATUS_FINIS: ! 
43152     close #super_handle: ioerr ignore
43154     mat status_desc$(status_count) : mat status_code$(status_count) : mat status_option$(status_count)
43156     dim status_tmp_desc$(1)*60,status_tmp_code$(1)*3,status_tmp_option$(1)*64
43158     mat status_tmp_desc$(udim(mat status_desc$))=status_desc$
43160     mat status_tmp_code$(udim(mat status_code$))=status_code$
43162     mat status_tmp_option$(udim(mat status_option$))=status_option$
43164     mat status_sequence
43166     mat status_sequence(udim(mat status_tmp_option$))=aidx(status_tmp_option$)
43168     for status_sequence_item=1 to udim(mat status_sequence)
43170       let status_option$(status_sequence_item)=status_tmp_option$(status_sequence(status_sequence_item))
43172       let status_code$(status_sequence_item)=status_tmp_code$(status_sequence(status_sequence_item))
43174       let status_desc$(status_sequence_item)=status_tmp_desc$(status_sequence(status_sequence_item))
43176     next status_sequence_item
43178   end if  ! ~setup_status
43180 fnend  ! fn_setup_status
43190 def library fnstatus_code$*3(stc_code$*3) ! stc_
43192   if ~setup_status then let fn_setup_status
43194   let fnstatus_code$=fn_status_code$(stc_code$)
43196 fnend  ! fnstatus_code$(stc_Code$)
43200 def fn_status_code$*3(stc_code$*3) ! stc_
43202   let stc_code_val=val(stc_code$) conv STC_CHAR
43204   if trim$(stc_code$)<>'' then let stc_code$=cnvrt$('N 3',stc_code_val)
43206   goto STC_XIT
43208 STC_CHAR: ! Is Char
43210   let stc_code$=lpad$(trim$(stc_code$),3)
43212 STC_XIT: ! 
43214   let fn_status_code$=uprc$(stc_code$)
43216 fnend  ! fn_status_code$
43220 def library fnstatus_desc$*60(sd_status_code$*3) ! sd_
43222   let status_desc$="" !:
        let sd_status_code$=fn_status_code$(sd_status_code$)
43224   if ~setup_status then let fn_setup_status
43226   if trim$(sd_status_code$)<>"" then 
43228     let sd_which=srch(mat status_code$,fn_status_code$(sd_status_code$))
43230     if sd_which>0 then let status_desc$=status_desc$(sd_which) else !:
            let status_desc$="Status - "&sd_status_code$
43232     let fnstatus_desc$=status_desc$
43234   end if  ! if trim$(sd_status_code$)<>"" THEN
43236 fnend  ! fnstatus_desc$
43240 def library fnpick_status$(stp_default$*3; stp_cache_reset) ! stp_
43242   if stp_cache_reset then let setup_status=0
43244   if ~setup_status then let fn_setup_status
43246   let stp_default$=fn_status_code$(stp_default$)
43248   let stp_winscroll_default_start=srch(mat status_code$,stp_default$)
43250   let stp_winscroll_default_start=max(1,stp_winscroll_default_start)
43252   let stp_winscroll=fnwinscroll_(mat status_option$,stp_winscroll_default_start,"TITLE=Select Desired status Code HEADING=Status;Description")
43254   if fkey<>93 and fkey<>99 and stp_winscroll>0 and stp_winscroll<=udim(mat status_code$) then 
43256     let stp_return$=status_code$(stp_winscroll)
43258   else 
43260     let stp_return$=stp_default$
43262   end if 
43264   let fnpick_status$=stp_return$
43270 fnend  ! FNPick_Status$
43280 ! Status Suite - end
43290 def library fnask_file2(mat af2_data_file$,af2_cap$*80; af2_pk$*80,mat af2_prompt$,mat af2_default_filter$,mat af2_fhelp$)
43292   if ~setup_af2 then 
43294     let setup_af2=1
43296     gosub SETUP_LIBRARY
43298     gosub SETUP_CONSTANTS
43300     gosub SETUP_SQL_HLPLNK1
43302     gosub SETUP_SQL_HLPLNK2
43304   end if  ! ~setup_af2
43306   let fnask_file2=fn_ask_file2(mat af2_data_file$,af2_cap$,af2_pk$,mat af2_prompt$,mat af2_default_filter$,mat af2_fhelp$)
43308 fnend  ! fnask_file2
43310 def fn_ask_file2(mat af2_data_file$,af2_cap$*80; af2_pk$*80,mat af2_prompt$,mat af2_default_filter$,mat af2_fhelp$)
43315   dim af2_save_data$(1)*128, af2_dumpstr$*80, af2_helpchk$*80, af2_presshelp
43320   dim af2_askfile_data$(1)*128, af2_fhelplist$*1024,af2_fhelpbutton$*1024, af2_fkey_extra$*80
43325   let af2_height=udim(af2_data_file$)*2+2 : let af2_iconpos=52 : let af2_entries = udim(af2_data_file$)
43330   if af2_height > 20 then 
43335     let fnmessagebox_("Too many files: \n"&str$(udim(af2_data_file$))&" lines \n Exceeds screen height ability.", mb_exclamation+mb_okonly,"Screen Limits Exceeded")
43340     goto AF2_XIT
43345   end if 
43350   mat af2_save_data$(af2_entries)
43355   if ~af2_ask_file2_setup then 
43360     dim af2_data_fil_prior$*128
43365     let af2_ask_file2_setup=1
43370   end if 
43375   let af2_data_fil_prior$=data_fil2$
43380   let af2_set_fn_ask_file2=0
43385   let af2_data_fil$=''
43390   let af2_rin_pos=len(af2_prompt$(1))+3 : let af2_rin_len=50 : let af2_button_browse_pos=af2_rin_pos+af2_rin_len+2 : let af2_button_browse_len=3
43395   let af2_button_cancel_len=8 : let af2_button_cancel_pos=af2_button_browse_pos+af2_button_browse_len-af2_button_cancel_len
43400   let af2_win_width=af2_button_cancel_pos+af2_button_cancel_len+2
43405   open #af2_win:=fngethandle_: fn_open_parent$('Caption='&af2_cap$&',Parent=None,Center,Rows='&str$(af2_height)&',Cols='&str$(af2_win_width)&',Name=AskFile2-'&str$(af2_height)&'x'&str$(af2_win_width)&',Border=S[N],Button.Text=(f)Reset;(f)Search;OK;Cancel,Button.FKey=4;5;0;99',mat af2_askfile_data$),display,output 
43410   print #af2_win: newpage
43415   if len(af2_pk$)>0 then 
43420     if env$('GUIMode')='ON' then 
43425       open #af2_toolbar_win:=fngethandle_: 'SRow=1,SCol=1,Parent='&str$(af2_win)&',Rows=1,Cols='&str$(af2_win_width)&',Picture=Icons\Toolbar.gif',display,output 
43430       print #af2_toolbar_win,fields '1,'&str$(af2_win_width-3)&',P 1/2,[Button],B1', help "3a;Help;": 'Icons\Help.png:Isotropic' ioerr ignore
43435     else 
43440       print #af2_win,fields '1,'&str$(af2_win_width-3)&',C 1,[Button],B1', help "3a;Help;": '...' ioerr ignore
43445     end if 
43450   end if 
43455   let fn_generate_buttons_for_window(mat af2_askfile_data$,af2_win)
43460   dim af2_field$(1)*20
43465   mat af2_field$(udim(mat af2_data_file$))
43470   for af2_item=1 to udim(mat af2_data_file$)
43475     let af2_field$(af2_item)=str$(1+af2_item*2)&',15,36/C 128,[D]ST'
43480     if trim$(af2_default_filter$(af2_item))="" then let af2_default_filter$(af2_item)="N:*.*"
43485     if trim$(af2_prompt$(af2_item))="" then let af2_prompt$(af2_item)="File Name " & str$(af2_item)&":"
43490   next af2_item
43495   if len(trim$(af2_data_file$(1)))>0 then mat af2_save_data$=af2_data_file$
43500   if len(trim$(af2_data_file$(1)))<=0 then mat af2_save_data$=af2_default_filter$ ! : pause
43505   let af2_helpchk$="1A 2A 3A 1B 2B 3B 1L 2L 3L 1R 2R 3R" : let af2_presshelp=0 ! not pressed
43510   mat af2_fhelp$(udim(mat af2_data_file$))
43515   for af2_fhelp_item=1 to udim(mat af2_data_file$)
43520     let af2_dumpstr$=af2_fhelp$(af2_fhelp_item) ! : pause
43525     if pos(af2_helpchk$,uprc$(af2_dumpstr$(1:2)))>0 then 
43530       let af2_fhelplist$=af2_fhelplist$&af2_fhelp$(af2_fhelp_item)&","
43535     else 
43540       let af2_fhelplist$=af2_fhelplist$&"3B,"&af2_fhelp$(af2_fhelp_item)&","
43545     end if 
43550   next af2_fhelp_item
43555   mat buttonhelp$(udim(mat af2_data_file$)) : let af2_fhelp_item = 1
43560   for af2_fhelp_item=1 to udim(mat af2_data_file$)
43565     let af2_dumpstr$=af2_prompt$(af2_fhelp_item) : let af2_lefthelp = len(af2_prompt$(af2_fhelp_item)) ! : pause
43570     if af2_dumpstr$(af2_lefthelp:af2_lefthelp)=":" then let af2_dumpstr$=af2_dumpstr$(1:af2_lefthelp-1) ! (999:0)=""
43575     if pos(af2_helpchk$,uprc$(af2_dumpstr$(1:2)))>0 then 
43580       let af2_fhelpbutton$ = af2_fhelpbutton$&"Click here to find " & af2_dumpstr$&"," ! Af2_Prompt$(af2_fhelp_item)&","
43585     else 
43590       let af2_fhelpbutton$ = af2_fhelpbutton$&"3B,"&"Click here to find " & af2_dumpstr$&"," ! & Af2_Prompt$(af2_fhelp_item)&","
43595     end if 
43600   next af2_fhelp_item
43605   gosub AF2_GET_NEW_BOXES
43610   do 
43615     rinput #af2_win,fields mat af2_field$,attr '[a]', help af2_fhelplist$: mat af2_data_file$
43620     let af2_save_cur=curfld
43625     if fkey=1 then 
43630       let fn_help(af2_pk$,af2_cap$)
43635       let af2_presshelp=1
43640     else if fkey=4 then 
43645       mat af2_data_file$=af2_save_data$ : goto AF2_DO_LOOP
43650     else if fkey=5 or (fkey>1000 and fkey <1100) then 
43655       print af2_save_cur : print af2_curpos : print fkey : print af2_data_file$(af2_save_cur) ! : pause
43660       if fkey>1000 and fkey <1100 then let af2_save_cur=fkey-1000 else let af2_save_cur=curfld
43665       if (trim$(af2_data_file$(af2_save_cur))((len(trim$(af2_data_file$(af2_save_cur)))):len(trim$(af2_data_file$(af2_save_cur)))))="\" then let af2_data_file$(af2_save_cur)=trim$(af2_data_file$(af2_save_cur))&"*.*"
43670       if exists(af2_data_file$(af2_save_cur))=1 then let af2_data_file$(af2_save_cur)=trim$(af2_data_file$(af2_save_cur))&"\*.*"
43675       let af2_data_file$(af2_save_cur)=fnopen_$(af2_data_file$(af2_save_cur))
43680       if len(af2_data_file$(af2_save_cur))<=0 then let af2_data_file$(af2_save_cur) = af2_save_data$(af2_save_cur) : goto AF2_GET_NEXT_FILE2
43685       if len(af2_data_file$(af2_save_cur))>0 then 
43690         if ~exists(af2_data_file$(af2_save_cur)) then 
43695           let fnmessagebox_("The file you specified does not exist.\n"&af2_data_file$(af2_save_cur), mb_exclamation+mb_okonly,af2_cap$)
43700           goto AF2_GET_NEXT_FILE
43705         end if 
43710       end if 
43715       goto AF2_GET_NEXT_FILE2
43720     else if fkey=0 and af2_presshelp=0 then 
43725       let af2_exit=0 : let af2_nextchk=1 : let af2_all_good=af2_entries : let af2_save_cur=curfld
43730       for af2_nextchk=1 to af2_entries
43735         let af2_exit=af2_exit+len(trim$(af2_data_file$(af2_nextchk)))
43740         if len(trim$(af2_data_file$(af2_nextchk)))>0 and exists(trim$(af2_data_file$(af2_nextchk)))>1 then let af2_all_good=af2_all_good-1
43745       next af2_nextchk
43750       if af2_exit <= 0 or af2_all_good=0 then 
43755         let fkey(99) : goto AF2_XIT
43760       end if 
43765       if (trim$(af2_data_file$(af2_save_cur))((len(trim$(af2_data_file$(af2_save_cur)))):len(trim$(af2_data_file$(af2_save_cur)))))="\" then let af2_data_file$(af2_save_cur)=trim$(af2_data_file$(af2_save_cur))&"*.*"
43770       if exists(af2_data_file$(af2_save_cur))=1 then let af2_data_file$(af2_save_cur)=trim$(af2_data_file$(af2_save_cur))&"\*.*"
43775       if af2_exit > 0 then ! this loops checks and verifies that all entries have valid files before exiting
43780         if len(trim$(af2_data_file$(af2_save_cur)))>0 then 
43785           if pos(af2_data_file$(af2_save_cur),"?")>0 or pos(af2_data_file$(af2_save_cur),"*") >0 then 
43790             let af2_data_file$(af2_save_cur)=fnopen_$(af2_data_file$(af2_save_cur))
43795             if len(af2_data_file$(af2_save_cur))<=0 then let af2_data_file$(af2_save_cur)=af2_save_data$(af2_save_cur) : goto AF2_GET_NEXT_FILE2
43800             goto AF2_CHKZERO
43805           end if 
43810           if pos(af2_data_file$(af2_save_cur),"?")<=0 and pos(af2_data_file$(af2_save_cur),"*")<=0 then 
43815             let af2_data_file$(af2_save_cur)=trim$(af2_data_file$(af2_save_cur)) : goto AF2_CHKZERO
43820           end if 
43825         end if 
43830         let af2_data_file$(af2_save_cur)=fnopen_$(af2_data_file$(af2_save_cur))
43835         if len(af2_data_file$(af2_save_cur))<=0 then let af2_data_file$(af2_save_cur)=af2_save_data$(af2_save_cur) : goto AF2_GET_NEXT_FILE2
43840         if len(trim$(af2_data_file$(af2_save_cur))) > 0 and ~exists(trim$(af2_data_file$(af2_save_cur))) then 
43845           let fnmessagebox_("The file you specified: \n"&trim$(af2_data_file$(af2_save_cur))&" does not exist.",mb_okonly+mb_exclamation,af2_cap$)
43850           goto AF2_GET_NEXT_FILE
43855         end if 
43860 AF2_CHKZERO: ! they typed something into the box...maybe a * or ?
43865         if len(af2_data_file$(af2_save_cur)) > 0 and ~exists(af2_data_file$(af2_save_cur)) then 
43870           let fnmessagebox_("The file you specified does not exist.\n"&af2_data_file$(af2_save_cur), mb_exclamation+mb_okonly,af2_cap$)
43875           goto AF2_GET_NEXT_FILE
43880         end if 
43885         goto AF2_GET_NEXT_FILE2
43890         let af2_data_file$(af2_save_cur)=af2_save_data$(af2_save_cur)
43895       end if  ! af2_xit
43900     end if 
43905     if af2_presshelp=1 then goto AF2_GET_NEXT_FILE
43910     if fkey=99 or fkey=9 or fkey=93 then let af2_set_fn_ask_file2=99 : goto AF2_XIT
43915 AF2_GET_NEXT_FILE2: ! 
43920     if af2_save_cur < af2_entries then let curfld(af2_save_cur+1) : goto AF2_DO_LOOP
43925     if af2_save_cur >= af2_entries then let curfld(1) : goto AF2_DO_LOOP
43930 AF2_GET_NEXT_FILE: ! 
43935     let curfld(af2_save_cur) : let af2_presshelp=0 : let af2_data_file$(af2_save_cur)=af2_save_data$(af2_save_cur)
43940 AF2_DO_LOOP: ! 
43945   loop until fkey=9 or fkey=99 or fkey=93
43950 AF2_GET_NEW_BOXES: ! 
43955   let af2_nextkey=1000
43960   dim af2_screen_form$(1)*100,af2_screen_buttons$(1)*100,af2_open_icons$(1)*32
43965   if len(af2_data_file$(1))<=0 then mat af2_data_file$=af2_default_filter$
43970   mat af2_screen_form$(af2_entries) ! mat af2_screen_form$(Af2_Entries*2)
43975   mat af2_screen_buttons$(af2_entries) ! mat af2_screen_buttons$(Af2_Entries*2)
43980   if env$('GUIMode')='ON' then 
43985     mat af2_open_icons$(af2_entries)=("Icons\Open.gif:isotropic")
43990   else 
43995     mat af2_open_icons$(af2_entries)=("...")
44000   end if  ! env$('GUIMode')='ON'   /   else 
44005   for af2_numboxes=1 to af2_entries
44010     let af2_prompt$(af2_numboxes)=trim$(af2_prompt$(af2_numboxes))
44015     let af2_prompt_len=len(af2_prompt$(af2_numboxes))
44020     if af2_prompt$(af2_numboxes)(af2_prompt_len:af2_prompt_len)<>":" then let af2_prompt$(af2_numboxes)(999:0)=":"
44025     let af2_screen_form$(af2_numboxes)=str$(1+af2_numboxes*2)&",1,14/CR,[W]"
44030     if env$('GUIMode')='ON' then 
44035       let af2_screen_buttons$(af2_numboxes)=str$(1+af2_numboxes*2)&","&str$(af2_iconpos)&",P 1/2,[Button],"&str$(af2_nextkey+=1)
44040     else 
44045       let af2_screen_buttons$(af2_numboxes)=str$(1+af2_numboxes*2)&","&str$(af2_iconpos)&",C 3,[Button],"&str$(af2_nextkey+=1)
44050     end if  ! env$('GUIMode')='ON'   /   else 
44055   next af2_numboxes
44060   print #af2_win,fields mat af2_screen_form$: mat af2_prompt$ ! HELP fHelpLabel$: mat Af2_Prompt$ ! ,Mat af2_open_icons$
44065   print #af2_win,fields mat af2_screen_buttons$, help af2_fhelpbutton$: mat af2_open_icons$
44070   return  ! AF2_GET_NEW_BOXES
44075 AF2_XIT: ! 
44080   let af2_prompt$=""
44085   close #af2_win: 
44090   let fn_ask_file2=af2_set_fn_ask_file2
44095 fnend  ! fn_ask_file2
44100 def library fnlog(log_file$*256,log_entry$*800)
44102   let fnlog=fn_log(log_file$,log_entry$)
44104 fnend  ! fnLog
44110 def fn_log(log_file$*256,log_entry$*1024)
44112   dim log_file_prior$*256
44118   open #log_handle_fnlog:=fngethandle_: 'Name='&log_file$&',RecL=1024,Use',display,output ioerr IOERR_FN_LOG
44124   print #log_handle_fnlog: env$("UserName")&chr$(9)&session$&chr$(9)&date$("MM/DD/CCYY")&chr$(9)&time$&chr$(9)&log_entry$
44126   let log_file_prior$=log_file$
44128   close #log_handle_fnlog: 
44129   let log_handle_fnlog=0
44130   goto XIT_FN_LOG
44132 IOERR_FN_LOG: ! 
44134   if uprc$(env$("debug"))="YES" then 
44136     print '  --  fn_Log  --'
44138     print "LOG_FILE$=";log_file$
44140     print "Error=";err
44142     print program$&"'s Line=";line
44144     print '  --  '
44146     if uprc$(env$("Developer"))="YES" then pause 
44148   end if  ! UPRC$(env$("debug"))="YES" then
44150   goto XIT_FN_LOG
44152 XIT_FN_LOG: ! 
44154 fnend  ! fn_Log
44160 def library fnfixed_fee_setup(mat ffs_ffc$) !:
        let fnfixed_fee_setup=fnfixedfee_setup(mat ffs_ffc$) !:
      fnend 
44170 def fnfixedfee_setup(mat fixed_fee_code_section$) ! this function shares the local mat Fixed_Fee_Code$ with fnFixedFee
44175   if ~setup_fnfixedfee_setup then 
44180 !    library "Library\CLSUtil": FNASCI_,fn_add_one$
44185     dim ffs_line$(1)*256,fixed_fee_setup_file$*256
44190     let tab$=chr$(9)
44195     let fixed_fee_setup_file$="Custom\Fees.ini"
44200     let setup_fnfixedfee_setup=true=1
44205   end if  ! ~Setup_fnFixedFee_Setup
44210   mat fixed_fee_code$(0) : mat fixed_fee_code_section$(0)
44215   if exists(fixed_fee_setup_file$) then 
44220     let fnasci_(fixed_fee_setup_file$,mat ffs_line$)
44225     for ffs_line_item=1 to udim (mat ffs_line$)
44230       if trim$(ffs_line$(ffs_line_item))(1:1)<>"!" and trim$(srep$(ffs_line$(ffs_line_item),tab$,""))<>"" then 
44235         if trim$(ffs_line$(ffs_line_item))(1:2)="||" then 
44240           let fn_add_one$(mat fixed_fee_code_section$,trim$(srep$(uprc$(ffs_line$(ffs_line_item)),"||FIXED:","")))
44245         end if  ! TRIM$(FFS_LINE$(FFS_LINE_ITEM))(1:2)="||"
44250         let ffs_pos_tab=pos(ffs_line$(ffs_line_item),tab$)
44255         if ffs_pos_tab<=0 then let ffs_pos_parse_end=len(ffs_line$(ffs_line_item)) else let ffs_pos_parse_end=ffs_pos_tab-1
44260         let fn_add_one$(mat fixed_fee_code$,ffs_line$(ffs_line_item)(1:ffs_pos_parse_end))
44265       end if  ! Trim$(FFS_Line$(FFS_Line_Item))(1:1)<>"!" and Trim$(SRep$(FFS_Line$(FFS_Line_Item),Tab$,""))<>""
44270     next ffs_line_item
44275   end if  ! exists(Fixed_Fee_Setup_File$)
44280   let fnfixedfee_setup=udim(fixed_fee_code_section$)
44285 fnend 
44290 def library fnfixed_fee(ff_bpj$,ff_section2$,mat ff_buckets_category,mat ff_buckets_amount) !:
        let fnfixed_fee=fnfixedfee(ff_bpj$,ff_section2$,mat ff_buckets_category,mat ff_buckets_amount) !:
      fnend 
44300 def fnfixedfee(ff_bpj$,ff_section2$*80,mat ff_buckets_category,mat ff_buckets_amount)
44305 ! every time initialization
44310   mat fixed_fee_code_multiplier(0) : mat fixed_fee_code_category(0) !:
        mat fixed_fee_code_bpj$(0) !:
        mat fixed_fee_code_amount(0)
44315   let set_fnfixedfee=0
44320   if udim(mat ff_buckets_category)<>udim(mat ff_buckets_amount) then print "UDim(Mat FF_Buckets_Category) must match UDim(Mat FF_Buckets_Amount)" : pause 
44325   let fixed_fee_code_item=srch(mat fixed_fee_code$,"||FIXED:"&uprc$(trim$(ff_section2$)))
44330   if fixed_fee_code_item<=0 then goto L44465 ! if someone passes an invalid Code to this function, simply return 0
44335 ! Set Arrays (for use):  mat Fixed_Fee_Code_Multiplier, mat Fixed_Fee_Code_Category, mat Fixed_Fee_Code_Amount!:
        ! Filtey by FF_BPJ$ & FF_SECTION2$
44340   do until (fixed_fee_code_item+=1)>udim(mat fixed_fee_code$) or fixed_fee_code$(fixed_fee_code_item)(1:2)="||"
44345     let ff_pos_equal=pos(fixed_fee_code$(fixed_fee_code_item),"=")
44350     if fixed_fee_code$(fixed_fee_code_item)(2:2)=":" then 
44355       let fixed_fee_code_bpj$=uprc$(fixed_fee_code$(fixed_fee_code_item)(1:1))
44360       let fixed_fee_code_category=fnval_(fixed_fee_code$(fixed_fee_code_item)(3:ff_pos_equal-1))
44365     else 
44370       let fixed_fee_code_bpj$=""
44375       let fixed_fee_code_category=fnval_(fixed_fee_code$(fixed_fee_code_item)(1:ff_pos_equal-1))
44380     end if  ! Fixed_Fee_Code$(Fixed_Fee_Code_Item)(2:2)=":"
44385     if trim$(fixed_fee_code_bpj$)="" or trim$(uprc$(ff_bpj$))=trim$(fixed_fee_code_bpj$) then 
44390       let fixed_fee_code_multiplier$=fixed_fee_code$(fixed_fee_code_item)(ff_pos_equal+1:99) !:
            let fixed_fee_code_multiplier$=srep$(fixed_fee_code_multiplier$,"%","") !:
            let ff_pos_slash=pos(fixed_fee_code_multiplier$,"/")
44395       if ff_pos_slash>0 then !:
              let ff_numerator=fnval_(fixed_fee_code_multiplier$(1:ff_pos_slash-1)) !:
              let ff_denomerator=fnval_(fixed_fee_code_multiplier$(ff_pos_slash+1:99)) !:
              let fixed_fee_code_multiplier=ff_numerator/ff_denomerator !:
            else !:
              let fixed_fee_code_multiplier=fnval_(fixed_fee_code_multiplier$)/100
44400       let fn_add_one(mat fixed_fee_code_multiplier,fixed_fee_code_multiplier) !:
            let fn_add_one(mat fixed_fee_code_category,fixed_fee_code_category) !:
            let fn_add_one$(mat fixed_fee_code_bpj$,fixed_fee_code_bpj$)
44405     end if  ! TRIM$(FIXED_FEE_CODE_BPJ$)="" OR TRIM$(LWRCH(FF_BPJ$))=TRIM$(FIXED_FEE_CODE_BPJ$)
44410   loop 
44415   mat fixed_fee_code_amount(udim(fixed_fee_code_category))=(0)
44420 ! 
44425 ! USE Arrays
44430   for fixed_fee_code_item=1 to udim(mat ff_buckets_category)
44435     let ff_buckets_category_match=srch(mat fixed_fee_code_category,ff_buckets_category(fixed_fee_code_item))
44440     if ff_buckets_category_match>0 then 
44445       let fixed_fee_code_amount=fixed_fee_code_multiplier(ff_buckets_category_match)*ff_buckets_amount(fixed_fee_code_item)
44450       let fixed_fee_code_amount(ff_buckets_category_match)=fixed_fee_code_amount !:
            let set_fnfixedfee+=fixed_fee_code_amount
44455     end if  ! FF_Buckets_Category_Match>0
44460   next fixed_fee_code_item
44465 L44465: let fnfixedfee=set_fnfixedfee
44470 fnend 
44472 def library fngetdefault_masterdates(&m_start$,&m_end$)
44474   let fngetdefault_masterdates = fngetdefault_masterdates_(m_start$,m_end$)
44476 fnend 
44480 def fngetdefault_masterdates_(&m_start$,&m_end$)
44485   let master_handle=fngethandle_
44490   open #master_handle: "NAME=MASTER//6,KFNAME=DATEIDXB//6,SHR",internal,input,keyed 
44495   let m_start$=""
44500   read #master_handle,using MASTER_FORM,search>=fn_date_c8$(fnlow_date_$),release: f$,m_start$ nokey ignore
44505   do while fntest(m_start$)
44510     read #master_handle,using MASTER_FORM,release: f$,m_start$ eof L44520
44515   loop  !  FNtest(M_start$)
44520 L44520: close #master_handle: 
44525   let m_start$=fndate10_$(m_start$)
44530 MASTER_FORM: form pos 1,2*c 8
44535   let m_end$=date$("CCYY/MM/DD")
44540   if m_end$<m_start$ then let m_end$=m_start$
44545 fnend 
44550 def library fnprogram_top(cap$*80,&pk$,&m_pk$; pk_default$*80)
44552   if ~cls_setup then let fnclssetup
44554   let fnprogram_top=fnprogramtop(cap$,pk$,m_pk$, pk_default$)
44556 fnend  ! fnprogram_top
44560 def fnprogramtop(cap$*80,&pk$,&m_pk$; pk_default$*80) ! Dim Cap$*80,PK$*80,M_PK$*80    outside of this function
44570 ! Cap$ - Program Caption !:
        ! PK$ - Program's Menu Path !:
        ! M_PK$ - This variable stores the original PK$ as it was passed to this program (trimmed of -s only) !:
        ! PK_Default$ - if there is no PK$, than use the default specified with this parameter
44580   let pk$=trim$(trim$(pk$),"-")
44590   if pk$="" then let pk$=pk_default$
44600   let m_pk$=pk$
44610   let fndisplaytop(cap$,pk$)
44620 fnend 
44630 def library fndisplay_top(cap$*80; pk$*80, dt_cap_left_align,dt_trust$*80,dt_screen_handle,dt_help_fkey)
44632   if ~cls_setup then let fnclssetup
44634   let fndisplay_top=fndisplaytop(cap$,pk$, dt_cap_left_align,dt_trust$,dt_screen_handle,dt_help_fkey)
44636 fnend 
44640 def fndisplaytop(dt_cap$*80; dt_pk$*80, dt_cap_left_align,dt_trust$*80,dt_screen_handle,dt_help_fkey) ! dt_
44650 ! dt_cap$ - Program Caption
44660 ! dt_pk$ - Program's Menu Path
44670 ! DT_Cap_Left_Align - if 1 then align Left, else center the Caption
44675 ! Dt_Help_Fkey - if Help Icon, should be displayed, this parameter should be passed as the FKey that will trigger the Help
44680   dim dt_pk_display$*18
44690   let scr_freeze
44700   let fnsessionsize_setup(dt_screen_height,dt_screen_width)
44710 ! close #dt_screen_handle: ioerr IGNORE
44720   if dt_screen_handle>0 and trim$(file$(dt_screen_handle))="" then !:
          open #dt_screen_handle: 'SRow=1,SCol=1,Rows='&str$(dt_screen_height)&',Cols='&str$(dt_screen_width),display,output 
44730   print #dt_screen_handle: newpage
44740   let dt_cap$=trim$(dt_cap$)
44750   let dt_trust$=trim$(dt_trust$)
44760   if dt_cap_left_align=1 then 
44770     print #dt_screen_handle,fields "1,1,Cl 80,[S]": dt_cap$
44780   else 
44790     if dt_trust$<>'' then 
44800       let dt_cap_len=min(50,len(dt_cap$))
44810       let dt_cap_pos=int((dt_screen_width-dt_cap_len)/2)
44820       print #dt_screen_handle, fields '1,1,C '&str$(dt_screen_width)&',[S]': ''
44830       print #dt_screen_handle, fields '1,1,'&str$(dt_cap_pos)&'/C 80,[S]': dt_trust$
44840       print #dt_screen_handle,fields '1,'&str$(dt_cap_pos)&','&str$(dt_cap_len)&'/Cc 80,[S]': dt_cap$
44850     else 
44860       print #dt_screen_handle,fields '1,1,Cc '&str$(dt_screen_width)&',[S]': dt_cap$
44870     end if  ! DT_Trust$<>''   /   else 
44880   end if  ! DT_Cap_Left_Align=1   /   else 
44885   if dt_help_fkey>0 then print #dt_screen_handle,fields "1,79,P 1/2,[Toolbar],B"&str$(dt_help_fkey) : 'Icons\Help.png:Isotropic'
44890   if dt_pk$<>'' then 
44900     let dt_pk$=fnpk_cleanup$(dt_pk$)
44910     let pk_len=len(dt_pk$)
44920     if (dt_help_fkey<=0 and pk_len>18) or (dt_help_fkey>0 and pk_len>15) then let dt_pk_display$=trim$(dt_pk$)(1:7)&"..."&trim$(dt_pk$)(pk_len-7:pk_len) else let dt_pk_display$=trim$(dt_pk$)
44922     if dt_help_fkey>0 then !:
            let dt_right_len = len(dt_pk_display$)+3 !:
          else !:
            let dt_right_len = len(dt_pk_display$)
44930     if dt_right_len>0 then print #dt_screen_handle,fields "1,"&str$(dt_screen_width-dt_right_len+1)&",CR "&str$(len(dt_pk_display$))&",[S]": dt_pk_display$
44940   end if  ! dt_pk$<>''
44950 fnend  ! fnDisplayTop
44960 def library fnsec_level$*8(; slv_pk$*80)
44962   if ~setup_whoami then gosub SETUP_WHOAMI
44964   let fnsec_level$=fn_sec_level$(slv_pk$)
44966 fnend  ! fnsec_level$
44970 def fn_sec_level$*8(; slv_pk$*80)
44975   if slv_pk$(1:5)='1-3-1' then 
44980     let slv_return$=min_new$
44985   else if slv_pk$(1:5)='1-3-2' then 
44990     let slv_return$=min_master$
44995   else if slv_pk$(1:5)='2-8' then 
45000     let slv_return$=min_acc$
45005   else 
45010     let slv_return$=min_paper$
45015   end if 
45020   let fn_sec_level$=slv_return$
45025 fnend  ! fn_sec_level$(sl_pk$)
45030 def library fnmask_copy(maskc_sql_field$*80,maskc_copy_data$*128; maskc_sec_level$*10,maskc_pk$*80) ! maskc_
45032   if ~maskc_setup then 
45034     let maskc_setup=1
45036     if ~setup_constants then gosub SETUP_CONSTANTS
45038     if ~setup_whoami then gosub SETUP_WHOAMI
45040     if ~setup_zone_security then gosub SETUP_ZONE_SECURITY
45042   end if  ! ~maskc_setup
45044   let fnmask_copy=fn_mask_copy(maskc_sql_field$,maskc_copy_data$,maskc_pk$)
45046 fnend  ! fnmask_copy
45050 def fn_mask_copy(maskc_sql_field$*80,maskc_copy_data$*128; maskc_sec_level$*10,maskc_pk$*80)
45060   dim maskc_zone_security$*80,maskc_sec_level$*10
45070   if maskc_sec_level$='' then let maskc_sec_level$=fn_sec_level$(maskc_pk$)
45080   let maskc_sql_field$=trim$(maskc_sql_field$,'{')
45090   let maskc_sql_field$=trim$(maskc_sql_field$,'}')
45100   if pos(maskc_sql_field$,'.')<=0 then let maskc_sql_field$='Master.'&maskc_sql_field$
45110   if lwrc$(maskc_sql_field$)='internal.0.masforw.main.acct_no' then let maskc_sql_field$='Master.Forw_FileNo'
45120   let maskc_zone_security$='{'&maskc_sql_field$&'}'
45130   let fn_zone_security(maskc_zone_security$)
45140   let maskc_zone=fnval_(maskc_zone_security$(2:2))
45150   let maskc_zone_security_masked=min(1,max(0,pos(maskc_zone_security$,'~Mask~')))
45160   if maskc_zone_security_masked and maskc_sec_level$(maskc_zone:maskc_zone)<>'Y' then 
45170     let fn_zone_mask$(maskc_copy_data$,maskc_sql_field$)
45180   end if 
45190   let setenv('Clipboard',rtrm$(maskc_copy_data$))
45200 fnend  ! fn_mask_copy
45210 def library fnaccount$*40
45212   let fnaccount$=fn_account$
45214 fnend 
45220 def fn_account$*40
45225   dim cur_trust$*40
45230   let des1$="Unknown account or in use"
45235   open #account_handle:=fngethandle_: "NAME=ACCOUNT//7,shr",display,input ioerr L45250
45240   linput #account_handle: des1$ !:
        linput #account_handle: cur_trust$ eof ignore
45245   close #account_handle: 
45250 L45250: let fn_account$=des1$(1:40)
45255 fnend  ! fn_account$
45260 def library fnaccount_code$*4
45262   let fnaccount_code$=fn_account_code$
45264 fnend  ! fnaccount_code$
45270 def fn_account_code$*4
45275   let fn_account$
45280   let fn_account_code$=cur_trust$(1:4)
45285 fnend  ! fn_account_code$
45290 def library fnget_diarysearch(&search$,h_queue$,l_queue$,dqueue$,h_date$,l_date$,ddate$,h_code$,l_code$,c0de,h_code,l_code,h_priority$,l_priority$,dpriority)
45292   let fnget_diarysearch=fnget_diarysearch_(search$,h_queue$,l_queue$,dqueue$,h_date$,l_date$,ddate$,h_code$,l_code$,c0de,h_code,l_code,h_priority$,l_priority$,dpriority)
45294 fnend 
45300 def fnget_diarysearch_(&search$,h_queue$,l_queue$,dqueue$,h_date$,l_date$,ddate$,h_code$,l_code$,c0de,h_code,l_code,h_priority$,l_priority$,dpriority)
45305   if h_priority$="" then let h_priority$="999"
45310   let h_queue$=uprc$(h_queue$) !:
        let l_queue$=uprc$(l_queue$) !:
        let dqueue$=uprc$(dqueue$) ! Queue Should not be Case Sensitive, index is CU 8
45315   let read_done=-999 ! No more READS reqd !:
        let read_first_again=1 ! READ using new search$ !:
        let read_next=2 ! READ next record !:
        let read_type=0
45320   if dqueue$>h_queue$ then !:
          let read_type=read_done !:
          goto DONE_FNGET_DIARYSEARCH
45325   if ddate$<l_date$ then !:
          let search$=dqueue$&l_date$&l_code$ !:
          let read_type=read_first_again !:
          goto DONE_FNGET_DIARYSEARCH
45330   if ddate$>h_date$ then !:
          let search$=dqueue$&rpt$(chr$(255),8)&l_code$ !:
          let read_type=read_first_again !:
          goto DONE_FNGET_DIARYSEARCH
45335   if c0de<l_code then !:
          let search$=dqueue$&ddate$&l_code$ !:
          let read_type=read_first_again !:
          goto DONE_FNGET_DIARYSEARCH
45340   if c0de>h_code then !:
          let search$=dqueue$&ddate$&rpt$(chr$(255),8) !:
          let read_type=read_first_again !:
          goto DONE_FNGET_DIARYSEARCH
45345   let dpriority$=lpad$(str$(dpriority),3) !:
        if dpriority$<lpad$(l_priority$,3) or dpriority$>lpad$(h_priority$,3) then !:
          let read_type=read_next !:
          goto DONE_FNGET_DIARYSEARCH
45350 DONE_FNGET_DIARYSEARCH: !:
        let fnget_diarysearch_=read_type
45355 fnend 
45360 def library fnget_diaryhighlow(mat h_diary,mat l_diary,mat h_diary$,mat l_diary$,mat dia_filtersn$,mat dia_filtersc$,&diary_queue_high$,&diary_queue_low$,&diary_date_high$,&diary_date_low$,&diary_code_high,&diary_code_low,&diary_prior_high$,&diary_prior_low$)
45362   let fnget_diaryhighlow_(mat h_diary,mat l_diary,mat h_diary$,mat l_diary$,mat dia_filtersn$,mat dia_filtersc$,diary_queue_high$,diary_queue_low$,diary_date_high$,diary_date_low$,diary_code_high,diary_code_low,diary_prior_high$,diary_prior_low$)
45364 fnend 
45370 def fnget_diaryhighlow_(mat h_diary,mat l_diary,mat h_diary$,mat l_diary$,mat dia_filtersn$,mat dia_filtersc$,&diary_queue_high$,&diary_queue_low$,&diary_date_high$,&diary_date_low$,&diary_code_high,&diary_code_low,&diary_prior_high$,&diary_prior_low$)
45375   if diary_queue_low$<>"" or diary_queue_high$<>"" then !:
          let temp_ele=fnstretch_(mat dia_filtersc$) !:
          let fnstretch_(mat l_diary$) !:
          let fnstretch_(mat h_diary$) !:
          let dia_filtersc$(temp_ele)="QUEUE" !:
          let l_diary$(temp_ele)=diary_queue_low$ !:
          let h_diary$(temp_ele)=diary_queue_high$
45380   if diary_date_low$<>"" or diary_date_high$<>"" then !:
          let temp_ele=fnstretch_(mat dia_filtersc$) !:
          let fnstretch_(mat l_diary$) !:
          let fnstretch_(mat h_diary$) !:
          let dia_filtersc$(temp_ele)="DATE" !:
          let l_diary$(temp_ele)=fndate10_$(diary_date_low$) !:
          let h_diary$(temp_ele)=fndate10_$(diary_date_high$)
45385   if diary_code_low<>0 or diary_code_high<>0 then !:
          let temp_ele=fnstretch_(mat dia_filtersn$) !:
          let fnstretch_n_(mat l_diary) !:
          let fnstretch_n_(mat h_diary) !:
          let dia_filtersn$(temp_ele)="CODE" !:
          let l_diary(temp_ele)=diary_code_low !:
          let h_diary(temp_ele)=diary_code_high
45390   if diary_prior_low$<>"" or diary_prior_high$<>"" then !:
          let temp_ele=fnstretch_(mat dia_filtersc$) !:
          let fnstretch_(mat l_diary$) !:
          let fnstretch_(mat h_diary$) !:
          let dia_filtersc$(temp_ele)="PRIORITY" !:
          let l_diary$(temp_ele)=diary_prior_low$ !:
          let h_diary$(temp_ele)=diary_prior_high$
45395 fnend 
45400 def library fnget_masterhighlow(mat h_master,mat l_master,mat h_master$,mat l_master$,mat mast_filtersn$,mat mast_filtersc$,master_forw_high,master_forw_low,master_atty_high,master_atty_low,master_secy_high,master_secy_low,master_coll_high,master_coll_low,master_sales_high,master_sales_low,master_bal_high,master_bal_low,master_date_high$,master_date_low$)
45405   if master_forw_low<>0 or master_forw_high<>0 then !:
          let temp_ele=fnstretch_(mat mast_filtersn$) !:
          let fnstretch_n_(mat l_master) !:
          let fnstretch_n_(mat h_master) !:
          let mast_filtersn$(temp_ele)="FORW_NO" !:
          let l_master(temp_ele)=master_forw_low !:
          let h_master(temp_ele)=master_forw_high
45410   if master_atty_low<>0 or master_atty_high<>0 then !:
          let temp_ele=fnstretch_(mat mast_filtersn$) !:
          let fnstretch_n_(mat l_master) !:
          let fnstretch_n_(mat h_master) !:
          let mast_filtersn$(temp_ele)="ATTY" !:
          let l_master(temp_ele)=master_atty_low !:
          let h_master(temp_ele)=master_atty_high
45415   if master_secy_low<>0 or master_secy_high<>0 then !:
          let temp_ele=fnstretch_(mat mast_filtersn$) !:
          let fnstretch_n_(mat l_master) !:
          let fnstretch_n_(mat h_master) !:
          let mast_filtersn$(temp_ele)="PARA" !:
          let l_master(temp_ele)=master_secy_low !:
          let h_master(temp_ele)=master_secy_high
45420   if master_coll_low<>0 or master_coll_high<>0 then !:
          let temp_ele=fnstretch_(mat mast_filtersn$) !:
          let fnstretch_n_(mat l_master) !:
          let fnstretch_n_(mat h_master) !:
          let mast_filtersn$(temp_ele)="COLLECTOR" !:
          let l_master(temp_ele)=master_coll_low !:
          let h_master(temp_ele)=master_coll_high
45425   if master_sales_low<>0 or master_sales_high<>0 then !:
          let temp_ele=fnstretch_(mat mast_filtersn$) !:
          let fnstretch_n_(mat l_master) !:
          let fnstretch_n_(mat h_master) !:
          let mast_filtersn$(temp_ele)="SALES_NO" !:
          let l_master(temp_ele)=master_sales_low !:
          let h_master(temp_ele)=master_sales_high
45430   if master_bal_low<>0 or master_bal_high<>0 then !:
          let temp_ele=fnstretch_(mat mast_filtersn$) !:
          let fnstretch_n_(mat l_master) !:
          let fnstretch_n_(mat h_master) !:
          let mast_filtersn$(temp_ele)="BALANCE" !:
          let l_master(temp_ele)=master_bal_low !:
          let h_master(temp_ele)=master_bal_high
45435   if master_date_low$<>"" or master_date_high$<>"" then !:
          let temp_ele=fnstretch_(mat mast_filtersc$) !:
          let fnstretch_(mat l_master$) !:
          let fnstretch_(mat h_master$) !:
          let mast_filtersc$(temp_ele)="DATE_RECD" !:
          let l_master$(temp_ele)=fndate10_$(master_date_low$) !:
          let h_master$(temp_ele)=fndate10_$(master_date_high$)
45440 fnend 
45450 def library fnget_advfilters(mat adv_filters$,mat adv_forw1$,mat adv_forw1,&sc_ele,&action)
45455   let action=0 !:
        ! 0 - everything ok !:
        ! ACTION=-222 - No Forwarders in Ascii File !:
        ! ACTION=-333 - No Forwarders for Sort Code
45460   if trim$(adv_filters$(1)&adv_filters$(2))<>"" then goto GET_FORWS
45465 L45465: if trim$(adv_filters$(3))<>"" then goto ASCI_FORWS
45470   goto END_ADV_FILTERS
45475 ! 
45480 ASCI_FORWS: !:
        let adv_filters$(3) = trim$(adv_filters$(3))
45481   if pos(adv_filters$(3),"/")<=0 and pos(adv_filters$(3),"\")<=0 then let adv_filters$(3) = adv_filters$(3) & "/custom"
45482   if not fnasci_(adv_filters$(3),mat adv_forw1$) then goto BAD_ASCI
45485   let sc_ele=udim(adv_forw1$) !:
        mat adv_forw1(sc_ele)
45490   if sc_ele<1 then goto BAD_ASCI
45495   for j=1 to udim(adv_forw1$)
45500     let adv_forw1(j)=val(adv_forw1$(j)) conv BAD_ASCI
45505   next j
45510   goto END_ASCI
45515 ! 
45520 BAD_ASCI: let action=-222
45525 END_ASCI: goto END_ADV_FILTERS
45530 ! 
45535 GET_FORWS: !:
        let sort$=trim$(adv_filters$(1)) !:
        let sc_ele=0
45540   let fow_file=fngethandle_
45545   open #fow_file: "NAME=MASFORW//8,shr",internal,input,relative 
45550 SC_FORM: form pos 1,bh 3,pos 152,c 4,pos 667,c 10
45555   mat adv_forw1(0) !:
        if sort$="" then goto CHK_EDI_TYPE
45560 READ_FOW: read #fow_file,using SC_FORM,release: fow_rec,sc$,editype$ eof EXIT_GET_FORWS
45565   let sc$=trim$(uprc$(sc$)) !:
        if sc$<>"" and sc$=sort$ then 
45570     let sc_ele=udim(adv_forw1)+1 !:
          mat adv_forw1(sc_ele) !:
          let adv_forw1(sc_ele)=rec(fow_file)
45575     goto READ_FOW ! if added by sort code, no need to check edi type
45580   end if 
45585 CHK_EDI_TYPE: !:
        let adv_filters$(2)=trim$(adv_filters$(2)) !:
        if adv_filters$(2)="" then goto READ_FOW
45590   let editype$=trim$(uprc$(editype$)) !:
        if editype$<>"" and editype$=adv_filters$(2) then 
45595     let sc_ele=udim(adv_forw1)+1 !:
          mat adv_forw1(sc_ele) !:
          !:
          let adv_forw1(sc_ele)=rec(fow_file)
45600   end if 
45605   goto READ_FOW
45610 EXIT_GET_FORWS: !:
        close #fow_file: !:
        if udim(adv_forw1)=0 then let action=-333
45615   goto L45465
45620 END_ADV_FILTERS: fnend 
45630 def library fnget_diaryvalues(mat dia_filtersc$,mat dia_filtersn$,mat l_diary$,mat h_diary$,mat l_diary,mat h_diary,&l_queue$,&h_queue$,&l_date$,&h_date$,&l_prior$,&h_prior$,&l_code$,&h_code$,&l_code,&h_code,&search$)
45635 ! Set defaults !:
        let fngetdefault_queues_(l_queue$,h_queue$) !:
        let t=fngetdefault_diarydates_(l_date$,h_date$) !:
        let l_code=0 !:
        let h_code=999 !:
        let l_prior=0 !:
        let h_prior=999
45640   let ele_queue=srch(dia_filtersc$,"QUEUE") !:
        let ele_code=srch(dia_filtersn$,"CODE") !:
        let ele_date=srch(dia_filtersc$,"DATE") !:
        let ele_prior=srch(dia_filtersn$,"PRIORITY")
45645   if ele_queue>0 then let l_queue$=rpad$(l_diary$(ele_queue),8) !:
          let h_queue$=rpad$(h_diary$(ele_queue),8)
45650   if ele_code>0 then let l_code=l_diary(ele_code) !:
          let h_code=h_diary(ele_code)
45655   if ele_date>0 then let l_date$=l_diary$(ele_date) !:
          let h_date$=h_diary$(ele_date)
45660   let l_code$=lpad$(trim$(str$(l_code)),8) !:
        let h_code$=lpad$(trim$(str$(h_code)),8) !:
        let l_date$=date$(days(fndate10_(l_date$)),"CYMD") !:
        let h_date$=date$(days(fndate10_(h_date$)),"CYMD")
45665   if ele_prior>0 then !:
          let l_prior=l_diary(ele_prior) !:
          let h_prior=h_diary(ele_prior)
45670   let l_prior$=lpad$(str$(l_prior),3) !:
        let h_prior$=lpad$(str$(h_prior),3)
45675   let search$=l_queue$&l_date$&l_code$
45680 fnend 
45690 def library fngetcode(code$,fileno$,mat pap_line$,gc_activ_handle)
45695   dim afileno$,acmt$*40,aextra$*25,aacode$
45700   dim tfileno$,tcmt$*40,textra$*25,ttcode$
45705   dim ffileno$,fcmt$*40,fextra$*25,fcode$
45710   dim dq$,search$,cmt_line$(1)*75
45715   let dq$=chr$(39)&chr$(39)
45720 ! OPEN #gc_activ_handle: "NAME=ACTIVE.INT//6,KFNAME=ACTIVE.IDX//6,SHR",INTERNAL,OUTIN,KEYED
45725   let search$=fileno$ !:
        let code$=uprc$(code$)
45730   let ored=ord(fileno$(8:8))
45735   let search$(8:8)=chr$(ored+1)
45740   read #gc_activ_handle,using R20,key>=search$,release: afileno$,adate,atime,acmt$,aextra$,aacode$ nokey L45805
45745 L45745: read #gc_activ_handle,using R20,prior,release: tfileno$,tdate,ttime,tcmt$,textra$,ttcode$ eof L45805
45750   if tfileno$<>fileno$ then goto L45805
45755   if uprc$(ttcode$)=code$ then !:
          let fngetcode=tdate !:
          let cmt_line$(1)=textra$&tcmt$ !:
          goto CODEFOUND
45760   goto L45745
45765 CODEFOUND: read #gc_activ_handle,using R20,next,release: ffileno$,fdate,ftime,fcmt$,fextra$,fcode$ eof L45805
45770   if ffileno$<>fileno$ then goto L45805
45775   if trim$(fcode$)<>dq$ then goto L45805
45780   let add_line=udim(cmt_line$)+1
45785   mat cmt_line$(add_line) !:
        let cmt_line$(add_line)=fextra$&fcmt$
45790 ! LET LINENUM+=1
45795   goto CODEFOUND
45800 R20: form pos 1,c 8,bh 4,bh 4,c 28,c 20,c 8,c 1
45805 L45805: ! PAUSE  !:
        let maxline=udim(cmt_line$) !:
        mat pap_line$(maxline) !:
        mat pap_line$=cmt_line$
45810 fnend 
45820 def library fnpack(filename$*80,fbackup$*80,filesize)
45825   if ~exists(filename$) and ~exists(fbackup$) then !:
          print filename$&' Does not Exists, Skipping' !:
          goto L45905
45830   let pack_handle=fngethandle_
45835   print "Attempting to Pack "&filename$&" Using "&fbackup$&" recl=";filesize
45840   open #pack_handle: "name="&filename$,internal,outin,ioerr PACK_PROBLEM
45845   let trecsm=lrec(pack_handle): let rlnm=rln(pack_handle): let fresp=freesp(pack_handle): close #pack_handle: !:
        if rlnm<filesize then let rlnm=filesize
45850   if pos(fnos$,"98")>0 and fresp=0 then !:
          print bell; !:
          let msg$(fnos$&" Data At Risk"): print "Warning - ";fnos$;" encountered, Your data is at risk!" !:
          let fresp=2**31 !:
          let sleep(1) !:
          print bell; !:
          let sleep(1) !:
          print bell;
45855   if fresp<0 then let fresp=inf else !:
          if fresp=2000000000 then !:
            let fresp=inf
45860   if trecsm*rlnm>=fresp and fresp>=0 then !:
          print "There is not Enough Hard Disk Space to Pack the Database" !:
          print "The update WILL NOT PERFORM CORRECTLY" !:
          print "There is:";fresp;" Space Left" !:
          print "Call CLS for Assitance" !:
          pause  !:
          execute "Clear Proc" !:
          stop 
45865   if exists(fbackup$) then !:
          print "Warning, there is a problem, Backup already exists:" !:
          print filename$ !:
          print fbackup$ !:
          pause  !:
          execute "clear proc": stop 
45870   execute "RENAME "&filename$&" "&fbackup$
45875   if ~exists(fbackup$) then !:
          print "Warning, Rename failed!": print filename$ !:
          print fbackup$ !:
          pause : execute "clear proc": stop 
45880   execute "copy "&fbackup$&" "&filename$&" -d -"&str$(rlnm)
45885   if ~exists(filename$) then !:
          print "Warning, copy failed!" !:
          print filename$ !:
          print fbackup$ !:
          pause  !:
          execute "clear proc": stop 
45890   execute "free "&fbackup$
45895   print "Pack Completed "&filename$&" recl=";filesize
45900   print rpt$('=',80)
45905 L45905: fnend 
45910 PACK_PROBLEM: ! r: THERE WAS A PROBLEM
45915 print "There was a problem Packing the Database:";file$ !:
      print "Error:";err;" Line:";line !:
      execute "STAT LOCKS"
45920 pause 
45925 retry ! /r
45930 def fnsetup_localization
45935   dim loc_from$(1)*20,loc_to$(1)*20
45940   let loc_items=0
45945   let setup_localization=1
45950   let localize_handle=fngethandle_ !:
        open #localize_handle: "Name=Localize.ini//8,shr",display,input ioerr L45980
45955 L45955: linput #localize_handle: buff$ eof L45975
45960   let ntab=pos(buff$,chr$(9)) !:
        if ntab<=0 then goto L45955
45965   let loc_items+=1 !:
        mat loc_from$(loc_items) !:
        mat loc_to$(loc_items) !:
        let loc_from$(loc_items)=trim$(buff$(1:ntab-1)) !:
        let loc_to$(loc_items)=trim$(buff$(ntab+1:999))
45970   goto L45955
45975 L45975: close #localize_handle: 
45980 L45980: fnend 
45990 def library fnlocalize$*512(loc_from$*512)
45992   let fnlocalize$=fnlocalize_$(loc_from$)
45994 fnend 
46000 def fnlocalize_$*1024(loc_from$*1024)
46005   if ~setup_localization then let fnsetup_localization
46010   for nlocalize=1 to loc_items
46015     let loc_from$=srep$(loc_from$,loc_from$(nlocalize),loc_to$(nlocalize))
46020   next nlocalize
46025   let fnlocalize_$=loc_from$
46030 fnend 
46040 def fnwrite_log(message$*4096,log_debug$*20,log_handle_fnwrite_log)
46042   if log_debug$="YES" then print #log_handle_fnwrite_log: message$
46044 fnend 
46050 def library fnpath_appdata$*256 ! papd_
46055   if ~setup_constants then gosub SETUP_CONSTANTS
46060   dim papd_temp$*256, papd_cached$*256
46065   if papd_cached$="" then 
46070     if lwrc$(env$("Client_Server"))='yes' then ! is client-server
46075       let papd_temp$="N:CM\AppData\"
46080     else 
46085       let papd_temp$=trim$(env$("AppData"))&'\CLS\Collection-Master\'
46090     end if  ! is client-server   /   else 
46095     let papd_cached$=fngetshortname$(papd_temp$,"",1)
46100     if fn_make_dir(papd_cached$)<0 then 
46105       if debug then print "fnpath_appdata$ encountered a failure (error "&str$(abs(pe_makedir_response))&" in Fnmake_Dir) creating directory: "&papd_cached$
46110       if developer then pause 
46115       if lwrc$(env$("Client_Server"))='yes' then ! is client-server
46120         let papd_cached$='N:'
46125       else 
46130         let papd_temp$=trim$(env$("AppData"))&'\'
46135       end if  ! is client-server   /   else 
46140     end if  ! fn_make_dir<0
46145   end if  ! papd_cached$=""   /   else 
46150   let fnpath_appdata$=papd_cached$
46155 fnend  ! fnpath_appdata$
46160 def library fnvcharges(mat master_data$,mat master_data,mat master_fieldsc$,mat master_fieldsn$)
46162   if ~master_common then let fnmaster_common
46164   if ~cls_setup then let fnclssetup
46166   let fnsql2_master
46168   let fnvcharges=fnvcharges_
46170 fnend 
46180 def library fnvcharges_master(&fileno$,mat filerec,mat frec,&amt6)
46182 ! This function will figure the "Principal Portion Due" for a claim
46184   let fnvcharges_master=fnvcharges_
46186 fnend 
46190 def fnvcharges_
46195 ! The purpose of this routine is to figure out the Amount of Principal Charged.!:
        ! This figure is a complex calculation based on many conditions!:
        ! It is possible that this formula will Assign "Additional Charges" to principal under certain cituations !:
        ! ** It will not harm the accounting, instead it will show The split in a strange way.
46200   let vcharges=0 !:
        let vorig_claim=filerec(1) !:
        let vsuit_amt=filerec(2) !:
        let vjmt_amt=filerec(4) !:
        let vprin_coll=filerec(8) !:
        let vint_coll=filerec(9) !:
        let vbalance=filerec(5)
46205   let vstat_fees_due=filerec(3)-filerec(20)-frec(28) !:
        let vcosts_due=filerec(16)-filerec(17) !:
        let vcontract_due=amt6-frec(27) !:
        let vcalc_prin_coll=vprin_coll-frec(28)-frec(27)
46210   let vpre_suit_payments=filerec(10)+filerec(12)+frec(6) !:
        let vpost_suit_payments=filerec(11)+filerec(13)+frec(7) !:
        let vpost_jmt_payments=frec(9)+frec(3)+frec(8)
46215   let vpre_jmt_lo_paid=min(frec(27)+frec(28),vpre_suit_payments+vpost_suit_payments) !:
        let vpre_jmt_l_paid=fnplus_(vpre_jmt_lo_paid-frec(27)) !:
        let vpre_jmt_o_paid=fnplus_(vpre_jmt_lo_paid-vpre_jmt_l_paid)
46220   if vpre_suit_payments<0 then !:
          let vpost_suit_payments+=vpre_suit_payments !:
          let vpre_suit_payments=0
46225   let vpre_suit_lo_paid=min(frec(27)+frec(28),vpre_suit_payments) !:
        let vpre_suit_l_paid=fnplus_(vpre_suit_lo_paid-frec(27)) !:
        let vpre_suit_o_paid=fnplus_(vpre_suit_lo_paid-vpre_suit_l_paid)
46230   if vpre_suit_payments<0 then !:
          let vpost_suit_payments+=vpre_suit_payments !:
          let vpre_suit_payments=0
46235   let vcharges_debug$=uprc$(env$("DEBUG_INTEREST")) !:
        if vcharges_debug$="YES" then 
46236     let log_handle_vcharges=fngethandle_ !:
          open #log_handle_vcharges: "NAME=[TEMP]VCHARGES-[SESSION].HTM,REPLACE,RECL=9999",display,output  !:
          let fnwrite_log("Calculations for "&fileno$&"<hr>",vcharges_debug$,log_handle_vcharges) !:
          let fnwrite_log("Original Claim Amount F(1):"&str$(vorig_claim)&"<br>Suit Amount F(2):"&str$(vsuit_amt)&"<br>Judgment Amount F(4):"&str$(vjmt_amt)&"<br>Principal Collected F(8):"&str$(vprin_coll)&"<br>Interest Collected F(9)"&str$(vint_coll)&"<br>Balance F(5):"&str$(vbalance)&"<br>vPre Suit LO Paid:"&str$(vpre_suit_lo_paid)&"<br>vPre JMT LO Paid:"&str$(vpre_jmt_lo_paid)&"<BR>",vcharges_debug$,log_handle_vcharges) !:
          let fnwrite_log("Atty Fees Due:"&str$(vstat_fees_due)&"<br>Costs Due:"&str$(vcosts_due)&"<br>Contract Fees Due:"&str$(vcontract_due)&"<br>Calculated Principal Collected:"&str$(vcalc_prin_coll)&"<br>",vcharges_debug$,log_handle_vcharges) !:
          let fnwrite_log("Pre Suit Payments:"&str$(vpre_suit_payments)&"<br>Post Suit Payments:"&str$(vpost_suit_payments)&"<br>Post Judgement Payments"&str$(vpost_jmt_payments)&"<hr>",vcharges_debug$,log_handle_vcharges)
46237   end if  ! VCharges_Deb ug.
46250 ! First We need to Decide the condition of the claim "BPJ"
46255   if vjmt_amt<>0 then goto L46345 else !:
          if vsuit_amt<>0 then goto L46270
46260 ! Claim is Pre-Suit, Principal Charges are easy to figure out !:
        let fnwrite_log("75100 - Claim is Pre Suit - Assigning Original Claim Amount<br>",vcharges_debug$,log_handle_vcharges)
46265   let vcharges=vorig_claim !:
        goto PROCESS_VCHARGES
46270 L46270: ! Claim is Post Suit, Several Optinos Available !:
        let fnwrite_log("75120 - Claim is Post Suit<br>",vcharges_debug$,log_handle_vcharges)
46275   if vpre_suit_payments=0 then !:
          let vcharges=vsuit_amt !:
          let fnwrite_log("75125 - No Pre Suit Payments, Assigning Suit Amount<br>",vcharges_debug$,log_handle_vcharges) !:
          goto PROCESS_VCHARGES !:
          ! ** if nothings was paid Pre-Suit, then simply use Suit Amount as Charges
46280   if vprin_coll=0 then !:
          let fnwrite_log("75130 - No Payments Applied to Principal - Assigning Suit Amount<br>",vcharges_debug$,log_handle_vcharges) !:
          let vcharges=vsuit_amt !:
          goto PROCESS_VCHARGES !:
          ! ** if no principal was paid Pre-Suit, then simply use Suit Amount as Charges
46285   if vint_coll=0 then !:
          let fnwrite_log("75140 - No Payments Applied to Interest - Assigning Suit Amount + Pre Suit Payments - Pre Suit LO Paid<br>",vcharges_debug$,log_handle_vcharges) !:
          let vcharges=vsuit_amt+vpre_suit_payments- vpre_suit_lo_paid !:
          goto PROCESS_VCHARGES !:
          ! ** if no interest was paid Pre-Suit, then Add Pre-Suit Payments to Suit Amt to calculate Charges
46290 ! We might need to Figure out Stat Fees & Atty Fees, they might change things
46295 ! 
46300 ! A Post Suit Claim has both pre & post Suit Payments, because of this, we have to "Guess" what the original Charges Are
46305   let vprincipal_due=vbalance-vstat_fees_due-vcosts_due-vcontract_due
46310   let vcharges=vprincipal_due+vcalc_prin_coll
46315   let fnwrite_log("75195 - Pre Suit Claim - Is Complex with Principal & Interest Applied<br>",vcharges_debug$,log_handle_vcharges) !:
        let fnwrite_log("Calculated Principal Due:"&str$(vprincipal_due)&"<br>",vcharges_debug$,log_handle_vcharges) !:
        let fnwrite_log("Calculated Charges Due:"&str$(vcharges)&"<br>",vcharges_debug$,log_handle_vcharges)
46320 ! We may need some sanity checks against Principal & Suit Amounts
46325   let vmax_fee=vorig_claim !:
        if (vsuit_amt+vpre_suit_payments)>vmax_fee then !:
          let vmax_fee=vsuit_amt+vpre_suit_payments
46330   if vcharges>vmax_fee then !:
          let fnwrite_log("Maximum Charges Allowed VMAX_FEE:"&str$(vmax_fee)&"<br>",vcharges_debug$,log_handle_vcharges) !:
          let fnwrite_log("75220 Maximum Values Enforced - Charges are Calculated Principal Due + Calclulated Principal Collected<br>",vcharges_debug$,log_handle_vcharges) !:
          let vcharges=vmax_fee
46335 ! Note if Orig_Claim & Suit_amt are the same, it is likely that VCHARGES will be as well
46340   goto PROCESS_VCHARGES
46345 L46345: ! Claim is Post Judgment !:
        let fnwrite_log("75250 - Claim is Post Judgment<br>",vcharges_debug$,log_handle_vcharges) !:
        let fnwrite_log(str$(oj_costs)&":Include Costs in Judgment<br>",vcharges_debug$,log_handle_vcharges) !:
        let fnwrite_log(str$(oj_stat)&":Include Stat in Judgment<br>",vcharges_debug$,log_handle_vcharges) !:
        let fnwrite_log(str$(oj_contract)&":Include Contract in Judgment<br>",vcharges_debug$,log_handle_vcharges) !:
        let fnwrite_log(str$(oj_prejint)&":Include PJI in Judgment<br>",vcharges_debug$,log_handle_vcharges)
46350   let vcalc_jmt=vjmt_amt !:
        let vjudgment_costs=(frec(2)*~oj_costs) - (filerec(3)*~oj_costs) !:
        let vjudgment_stat_fee=(filerec(3)*~oj_stat) !:
        let vjudgment_contract=(amt6*~oj_contract) !:
        let vpji=0 ! (FREC(14)*OJ_PREJINT) !:
        ! ** Note: VJUDGMENT_CONTRACT NECESSARY !:
        ! ** NOTE: PJI is already part of Judgment if Appropriate!
46355   let vcalc_jmt-=(vjudgment_stat_fee + vjudgment_costs +vpji+vjudgment_contract) - vpre_jmt_l_paid*~oj_stat - vpre_jmt_o_paid*~oj_contract !:
        let vcalc_jmt=fnplus_(vcalc_jmt) !:
        let vtot_judgment=vcalc_jmt+vjudgment_costs+vjudgment_stat_fee+vpji ! ** VCALC_JMT is the 'Principal Only Portion of Jugment" !:
        ! ** Under the most simple conditions, it is the VCHARGES AMOUNT
46360   let vpre_j_prin_paid=min((vpre_suit_payments+vpost_suit_payments),vprin_coll)
46365   let fnwrite_log("Calculated Judgment Amount:"&str$(vcalc_jmt)&"<br>Judgment Costs:"&str$(vjudgment_costs)&"<br>Judgment Stat Fee:"&str$(vjudgment_stat_fee)&"<br>Judgment Pre-Judgment Interest:"&str$(vpji)&"<br>Total Judgment Amount:"&str$(vtot_judgment)&"<hr>",vcharges_debug$,log_handle_vcharges)
46370   if vpre_suit_payments=0 and vpost_suit_payments=0 then !:
          let fnwrite_log("75280 - No Pre J Payments - Assign Calculated Judgment Amount<br>",vcharges_debug$,log_handle_vcharges) !:
          let vcharges=vcalc_jmt !:
          goto PROCESS_VCHARGES !:
          ! ** if there are no Pre-Suit Payments, then simply use the Judgement Principal
46375   if vprin_coll=0 then !:
          let fnwrite_log("75290 - No Principal Collected Assigning Calculated Judgment Amount<br>",vcharges_debug$,log_handle_vcharges) !:
          let vcharges=vcalc_jmt !:
          goto PROCESS_VCHARGES !:
          ! ** if there are no Principal Payments, then simply use the Judgement Principal
46380   if filerec(9)=0 and frec(28)=0 and frec(27)=0 then !:
          let fnwrite_log("75300 - No Interest or Atty/Contract Fees Collected Assigning Calculated Judgment Principal + Pre & Post Suit Payments<br>",vcharges_debug$,log_handle_vcharges) !:
          let vcharges=vcalc_jmt+vpre_j_prin_paid !:
          goto PROCESS_VCHARGES !:
          ! No interest, atty fees or Contract Fees Collected, it's safe to assume 100% of pre-j payments are applied to principal
46385   if filerec(9)<>0 then goto L46410
46390 ! Interest is 0, but Stat or Contract has been collected.!:
        let fnwrite_log("75320 - Interest is 0, but Stat or Contract has been collected.<br>",vcharges_debug$,log_handle_vcharges)
46395 ! We don't know the vcharges for sure, we have to guess !:
        ! Compound Interst settings now affect our guess !:
        ! Compound interest is known because OJ_PREJINT=0
46400   if oj_prejint=1 then !:
          let fnwrite_log("75340 - Not Compounding Interest.<br>",vcharges_debug$,log_handle_vcharges) !:
          let vcharges=vtot_judgment-vjudgment_costs+vpre_j_prin_paid-vjudgment_stat_fee !:
          goto PROCESS_VCHARGES !:
          ! ** Claim is Not Compounding interest, 100% save to assume payments are all principalN
46405   let fnwrite_log("75350 - Compounding Interest.  Charges are Total Judgment - Judgment Costs + (Pre & Post Suit Payments) (Reflects L&O Paid based on setup)<br>",vcharges_debug$,log_handle_vcharges) !:
        let vcharges=vtot_judgment-vjudgment_costs+vpre_j_prin_paid-vjudgment_stat_fee - (vpre_jmt_l_paid*oj_stat + vpre_jmt_o_paid*oj_contract) !:
        goto PROCESS_VCHARGES !:
        ! ** Claim is Compounding interest!:
        ! ** As no Interest Was Collected, is it safe to simply do this?
46410 L46410: ! We don't know the vcharges for sure, we have to guess !:
        ! Compound Interst settings now affect our guess !:
        ! Compound interest is known because OJ_PREJINT=0 !:
        ! ** This section is reserved for Both Principal & Interest Payments applied!
46415   if oj_prejint=1 then !:
          goto L46435 !:
          ! if We are Not compounding interest, move forward
46420   let fnwrite_log("75380 - LET VCHARGES=VTOT_JUDGMENT-VJUDGMENT_COSTS+VPRE_J_PRIN_PAID-FILEREC(3)<br>",vcharges_debug$,log_handle_vcharges) !:
        let vcharges=vtot_judgment-vjudgment_costs+vpre_j_prin_paid-filerec(3)
46425 ! Is this really right?   !:
        ! Was about Atty Fees & Contract fees collected ?? !:
        ! ** It should be safe because We are compounding interest, so there are no Pre-Judgment Interest Payments
46430   goto PROCESS_VCHARGES
46435 L46435: ! We are not compounding interest, and have recovered principal & interest !:
        ! This situation has many possible situations!
46440   if vpre_suit_payments<>0 or vpost_suit_payments<>0 then !:
          goto L46450 !:
          ! ** Only Proceed if Only Post Jugment Payments on the claim
46445   let vcharges=vcalc_jmt !:
        goto PROCESS_VCHARGES !:
        ! Judgment is correct as there are no pre-judgment Payments
46450 L46450: if vpost_jmt_payments<>0 then !:
          goto L46470 !:
          ! ** Only Proceed if Only Post Jugment Payments on the claim
46455 ! As there are no Post Judgment Payments, we know that any interest collected had to be pre-suit !:
        ! We also do not compound interest, so it was not moved to principal
46460   let vcharges=vcalc_jmt+vpre_suit_paymnents+vpost_suit_payments-vint_coll
46465   goto PROCESS_VCHARGES
46470 L46470: ! There are mixed pre & post Jmt Payments!:
        ! We are really going to have to guess
46475 !  Current Balance = Balance - Stat, Contract & Costs Due
46480   let vcurrent_due=vbalance-vstat_fees_due-vcontract_due-vcosts_due
46485 ! VCALC_PRIN_COLL = Principal Collected
46490   let vcharges=vcurrent_due+vcalc_prin_coll
46495 ! As vcharges is a guess, we need to make sure this guess does not exceed the larges amount possible
46500   let vmax_fee=vorig_claim !:
        if (vsuit_amt+vpre_suit_payments)>vmax_fee then !:
          let vmax_fee=vsuit_amt+vpre_suit_payments
46505   if (vcalc_jmt+vpre_suit_payments+vpost_suit_payments)>vmax_fee then !:
          let vmax_fee=(vcalc_jmt+vpre_suit_payments+vpost_suit_payments)
46510   if vcharges>vmax_fee then let vcharges=vmax_fee
46515   goto PROCESS_VCHARGES
46520 PROCESS_VCHARGES: ! VCharges Calculated, figure out additional steps or sanity checks!
46525   let fnvcharges_=vcharges
46530   let fnwrite_log("<hr>Calculation Results:"&str$(vcharges)&"<hr>",vcharges_debug$,log_handle_vcharges)
46535   if uprc$(vcharges_debug$)="YES" then !:
          close #log_handle_vcharges: !:
          let log_handle_vcharges=0
46540 fnend 
46550 def library fnscreen7_sql$*128
46552   let fnscreen7_sql$=fn_screen7_sql$
46554 fnend  ! fnscreen7_sql$
46560 def fn_screen7_sql$*128
46565   if ~s7s_setup then 
46570     let s7s_setup=1
46575     dim s7s_field_desc$(1)*36
46580     gosub SCREEN7_SETUP
46585 FORM_SQL_LAYOUT: form pos 1,c 29,'|',c 36,'|',n 7,' |',n 7.2,' | ',c 17,'| ',pic(###),' |',c 18,'|'
46590   end if  ! ~s7s_setup
46595   open #s7s_h_layout:=fngethandle_: 'Name='&env$('temp')&'\Screen7.'&session$&',RecL=130,Replace',display,output 
46600   print #s7s_h_layout,using FORM_SQL_LAYOUT: 'FILENO','File Number',1,8,'C',1,''
46605   let str2mat(srep$(srep$(fhelp$,'3A;',''),'\n',' '),mat s7s_field_desc$,';')
46610   mat s7s_field_desc$(datar)
46615   let s7s_pos=9
46620   for s7s_item=1 to datar
46625     let str2mat(field_type$(s7s_item),mat s7s_field_type_part$,' ')
46630     let str2mat(field_pos$(s7s_item),mat s7s_field_pos_part$,',')
46635     let s7s_note$=''
46640     let s7s_name$='U'&str$(s7s_item)
46645     if trim$(s7s_field_desc$(s7s_item))='' then let s7s_field_desc$(s7s_item)='Screen 7 Field '&str$(s7s_item)
46650     if lwrc$(s7s_field_pos_part$(3))='pic(####/##/##)' then 
46655       let s7s_note$='DATE(CCYY/MM/DD)'
46660       let s7s_name$='U'&str$(s7s_item)&'_DATE'
46665     end if  ! lwrc$(s7s_field_pos_part$(3))='pic(###/##/##)'
46670     let s7s_field_len=fnval_(s7s_field_type_part$(2))
46675     print #s7s_h_layout,using FORM_SQL_LAYOUT: s7s_name$,s7s_field_desc$(s7s_item),s7s_pos,s7s_field_len,s7s_field_type_part$(1),s7s_item+1,s7s_note$
46680     let s7s_pos+=int(s7s_field_len)
46685   next s7s_item
46690   let fn_screen7_sql$=file$(s7s_h_layout)
46695   close #s7s_h_layout: 
46700 fnend  ! fn_screen7_sql$
46710 def fnsql2_master
46720   if trim$(thrudat$)="" then let thrudat$=date$
46730   let fileno$=master_data$(master_fileno) !:
        let jdate$=master_data$(master_jmt_date) !:
        let sdate$=master_data$(master_suit_date) !:
        let idate$=master_data$(master_idate) !:
        mat filerec=(0): mat frec=(0): mat rates=(0)
46740   let stored_int=master_data(master_stored_int) !:
        let rates(1)=master_data(master_rates(1)) !:
        let rates(2)=master_data(master_rates(2))
46750   let venue=master_data(master_venue1_no) !:
        let sher=master_data(master_sher_no) !:
        let forw=master_data(master_forw_no) !:
        let masco=master_data(master_coco_no) !:
        let atty_no=master_data(master_atty) !:
        let para_no=master_data(master_para) !:
        let collector_no=master_data(master_collector) !:
        let sales_no=master_data(master_sales_no)
46760   for nx=1 to 20 !:
          if master_filerec(nx) then let filerec(nx)=master_data(master_filerec(nx))
46770   next nx
46780   for nx=1 to 80 !:
          if master_frec(nx) then let frec(nx)=master_data(master_frec(nx))
46790   next nx
46800   let amt6=master_data(master_contract_fee)
46899 fnend 
46900 def library fnupdate_refno(finan_handle,finanh_handle,fileno$,tanum,refno,type$;refno_type)
46902   if (update_refno_result:=fn_update_refno_pass(finan_handle,fileno$,tanum,refno,type$,refno_type))<=0 then !:
          let update_refno_result=fn_update_refno_pass(finanh_handle,fileno$,tanum,refno,type$,refno_type)
46904   let fnupdate_refno=update_refno_result
46906 fnend 
46909 ! Refno_Type identifies the "Type of Refno" that we are updating !:
      ! 0 = Unknown (Updates only CHECKNO POS 353,BH 3)!:
      ! 1 = Specifically CHECKNO - (Updates only CHECKNO POS 353,BH 3) - This is for Batch Checks!:
      ! 2 = Remittance Invoice - UPDATES CHECKNO POS 353,BH 3 & INVOICE POS 378,BH 3) - Remittances !:
      ! 3 = Cost Invoice - UPDATES INVOICE POS 378,BH 3) - Cost Bills
46910 def fn_update_refno_pass(finan_pass_handle,fileno$,tanum,refno,type$;refno_type) ! open files only
46915   let search$=fileno$
46920   let ored=ord(fileno$(8:8))
46925   let search$(8:8)=chr$(ored+1)
46930   read #finan_pass_handle,using W22,search>=search$,release: afileno$,anumdat,atime,allcode$,atype$,tref nokey L46935 !:
        goto L46945
46935 L46935: restore #finan_pass_handle,last: eof L46985
46940 W22: form c 8,2*bh 4,c 8,c 1,pos 78,bh 3
46945 L46945: read #finan_pass_handle,using W22,prior,release: afileno$,anumdat,atime,allcode$,atype$,tref norec L46985 eof L46985
46950   if afileno$<>fileno$ then goto L46985
46955   if trim$(type$)<>"" and atype$<>type$ then goto L46945 !:
          ! ** Only mark the Appropriate Type Transactions !:
          ! ** Payments are "B" !:
          ! ** Costs are "C" !:
          ! ** Note if ATYPE$="" then don't worry about this!
46960   let tcode=int(val(allcode$)) conv L46945 !:
        if tcode=1 or tcode=7 or tcode=29 or tcode>=90 then goto L46945
46965 ! Do not Mark 29 or 90+ Transactions (Usually 20-25 and 33-82) !:
        ! ** Also skip 1 or 7 Transactions (Fees Received shouldn't result in a check!) !:
        ! This routine reads backwards for performance purposes !:
        ! Key = FILENO, DATE, TIME, CODE, TYPE & RECNO (From Active)
46970   if tref<>tanum then goto L46945 !:
        else !:
          read #finan_pass_handle,same: 
46971   if refno_type<=1 then 
46972     rewrite #finan_pass_handle,using FINAN_CHECKNO_FORM: refno
46973   else if refno_type=2 then 
46974     rewrite #finan_pass_handle,using FINAN_CHECKNO_INVOICE: refno,refno
46975   else if refno_type=3 then 
46976     rewrite #finan_pass_handle,using FINAN_INVOICE_FORM: refno
46977   else 
46978     print "Warning, Unknown Refno_Type Passed" : pause 
46979     rewrite #finan_pass_handle,using FINAN_CHECKNO_FORM: refno
46980   end if  ! Refno_Type
46981   let fn_update_refno_pass=rec(finan_pass_handle) !:
        ! ** Note: FINAN is rewriting CHECKNO - Hard Coded
46982 FINAN_CHECKNO_FORM: form pos 353,bh 3
46983 FINAN_CHECKNO_INVOICE: form pos 353,bh 3,pos 378,bh 3
46984 FINAN_INVOICE_FORM: form pos 378,bh 3
46985 L46985: fnend 
46990 def fn_needs_open_file(existing_handle,matching_text$*256)
46992   if existing_handle=0 or pos(uprc$(file$(existing_handle)),matching_text$)>0 then !:
          let fn_needs_open_file=1
46994 fnend 
47000 def library fnaddress_verified$*1(av_debtor_ret_mail$*1)
47002   dim av_return$*1
47004   let av_return$=''
47006   let av_debtor_ret_mail$=uprc$(trim$(av_debtor_ret_mail$))
47008   if av_debtor_ret_mail$='Y' then 
47010     let av_return$='N'
47012   else if av_debtor_ret_mail$='N' then 
47014     let av_return$='Y'
47016   else if av_debtor_ret_mail$='V' then 
47018     let av_return$='Y'
47020   else 
47022     let av_return$=''
47024   end if  ! av_debtor_ret_mail$=...   /   else 
47026   let fnaddress_verified$=av_return$
47028 fnend  ! fnaddress_verified$
47030 def library fnzone_mask$(&zone_data$,zm_inzone$*20)
47032   if ~setup_zone_security then gosub SETUP_ZONE_SECURITY
47034   let fnzone_mask$=fn_zone_mask$(zone_data$,zm_inzone$)
47036 fnend  ! fnzone_mask$
47040 def fn_zone_mask$(&zone_data$,zm_inzone$*20)
47050   let zm_inzone$=uprc$(trim$(zm_inzone$))
47060   let zone_mask$=""
47070   let _inzone=srch(mat zone_from$,"{"&zm_inzone$&"}")
47080   if _inzone>0 then 
47090     let zone_mask$=trim$(zone_mask$(_inzone))
47100     if zone_mask$<>'' then 
47102       if policy_mask_ssn and zone_mask$="*MASK_SSN" then 
47104         let zone_data$=fn_mask$(zone_data$,-4)
47106       else if policy_mask_dob and zone_mask$="*MASK_DOB" then 
47108         let zone_data$=fn_mask$(zone_data$,-5)
47110       else if policy_mask_forw_fileno and zone_mask$="*MASK_FORW_FILENO" then 
47112         let zone_data$=fn_mask$(zone_data$,-4)
47114       else if policy_mask_forw_fileno and zone_mask$="*MASK_CC" then 
47116         let zone_data$=fn_mask_cc$(zone_data$)
47118       else if policy_mask_orgactn and zone_mask$="*MASK_ORGACT#" then 
47120         let zone_data$=fn_mask$(zone_data$,-4)
47122       else if policy_mask_bank and zone_mask$="*MASK_BANK_FULL" then 
47124         let zone_data$=trim$(srep$(fn_mask$(rpad$(zone_data$,31,chr$(255)),-1),chr$(255),""))
47126       else if policy_mask_bank and zone_mask$="*MASK_BANK" then 
47128         let zone_data$=fn_mask$(zone_data$,-4)
47130       end if 
47260     end if  ! zone_mask$<>''
47270   end if  ! _inzone>0
47280 fnend  ! fn_zone_mask$
47290 ! -------LIBRARY-----FNEVENT_LOG----------------------------------------
47295 def library fnevent_log(source$*40, message$*10000; type$*30, eventid, category, rawdata$*10000)
47300   if ~xml_setup then gosub XML_SETUP
47305   let event_log = fnopen_xml_writer("[WBWORK]ELog"&session$&".xml")
47310   let xml_filename$ = file$(event_log)
47315   let fnopen_node(event_log, "eventLog")
47320   let fnopen_node(event_log, "parameters")
47325   let fnadd_node(event_log, "source", source$)
47330   let fnadd_node(event_log, "message", message$)
47335   if len(trim$(type$)) > 0 then !:
          let fnadd_node(event_log, "type", type$)
47340   if eventid then !:
          let fnadd_node(event_log, "eventID", str$(eventid))
47345   if category then !:
          let fnadd_node(event_log, "category", str$(category))
47350   if len(trim$(rawdata$)) > 0 then !:
          let fnadd_node(event_log, "rawData", unhex$(rawdata$))
47355   let fnclose_xml_writer(event_log)
47360   let fnexec_cmclient_("eventLog", xml_filename$)
47365 fnend 
47370 ! ----GOSUB---------DOTNET_SETUP_CONFIG---------------------------------
47375 DOTNET_SETUP_CONFIG: ! r:
47380 if ~xml_setup then gosub XML_SETUP
47385 dim dotnet_path$*100, codegroupname$*100, assemblyfile$*100, dotnet_server_dir$*100, dotnet_local_dir$*100, dotnet_service_dir$*100, xml_filename$*256
47390 dim cmstatus_info$(1)*100
47395 let cmsi_num_elements = 7 !:
      let cmsi_server_version = 1 !:
      let cmsi_session_version = 2 !:
      let cmsi_client_version = 3 !:
      let cmsi_server_os_info = 4 !:
      let cmsi_session_os_info = 5 !:
      let cmsi_is_service = 6 !:
      let cmsi_is_terminal_server = 7
47400 let dotnet_network_version$ = "v1.1.4322" !:
      let cmserver_network_version$ = "1.1.0.0" !:
      let cmsession_network_version$ = "1.1.0.0" !:
      let cmclient_network_version$ = "1.1.0.0"
47405 let dotnet_path$ = env$("WINDIR")&"\Microsoft.NET\Framework" !:
      let dotnet_server_dir$ = "N:\Users\James\CM.NET" !:
      let dotnet_local_dir$ = env$("TEMP")&"\CM.NET"
47410 if len(trim$(env$("ProgramFiles"))) > 0 then !:
        let dotnet_service_dir$ = env$("ProgramFiles")&"\CM.NET" !:
      else !:
        let dotnet_service_dir$ = "C:\Program Files\CM.NET"
47415 let dotnet_setup_config = 1
47420 return ! /r
47430 ! --LIBRARY----------FNEXEC_CMCLIENT------------------------------------
47432 def library fnexec_cmclient(application$*100, filename$*256; host$*100, port)
47434   let fnexec_cmclient=fnexec_cmclient_(application$, filename$, host$, port)
47436 fnend 
47440 ! -------------------FNEXEC_CMCLIENT_-----------------------------------
47445 def fnexec_cmclient_(application$*100, filename$*256; host$*100, port)
47450   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
47455   if ~fncomp_version(cmclient_network_version$, fncmclient_local_version$) then 
47460     if exists(dotnet_local_dir$&"\CMClient.exe") then !:
            let scr_thaw: execute 'System -w "'&dotnet_local_dir$&'\CMClient.exe" "'&filename$&'"' error L47495 !:
          else !:
            let scr_thaw: execute 'System -w vb.net\CMClient.exe "'&filename$&'"' error L47495
47465   else 
47470     if port = 0 then let port = 8700
47475     if len(trim$(host$)) = 0 then let host$ = "127.0.0.1"
47480     let scr_thaw: execute 'System -w "'&dotnet_local_dir$&'\CMClient.exe" -h '&host$&' -p '&str$(port)&' "'&application$&'" "'&fngetsessionname$&'" "'&filename$&'"' error L47495
47485   end if 
47490   goto L47500
47495 L47495: let fnexec_cmclient_ = error
47500 L47500: fnend 
47510 ! ---LIBRARY---------FNDOTNET_SETUP-------------------------------------
47515 def library fndotnet_setup
47520   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
47525   if wbplatform$<>"WINDOWS" then let dotnet_setup = 1
47530   if dotnet_setup then goto END_FNDOTNET_SETUP
47535   let codegroupname$ = "Collection-Master_Client" !:
        let assemblyfile$ = "VB.NET\CMSERVER.EXE"
47540   if ~fndotnet_installed or ~fncomp_version(dotnet_network_version$, fndotnet_local_version$) then !:
          let fndotnet_setup = 3 !:
          let fndotnet_notify("Installing .NET Framework") !:
          let fndotnet_install
47545   if ~fndotnet_configured then !:
          let fndotnet_setup = 3 !:
          let fndotnet_notify("Configuring .NET") !:
          let fndotnet_configure(codegroupname$, assemblyfile$)
47550   let fncmserver_status(mat cmstatus_info$)
47555   if ~(fncomp_version(cmsession_network_version$, cmstatus_info$(cmsi_session_version)) and fncomp_version(cmserver_network_version$, cmstatus_info$(cmsi_server_version))) then !:
          let fndotnet_setup = 3 !:
          let fndotnet_notify("Installing Server") !:
          let fngui_broker_install
47560   if dotnet_notify_hnd then close #dotnet_notify_hnd: 
47565   let dotnet_setup = 1
47570 END_FNDOTNET_SETUP: fnend 
47580 ! -------------------FNDOTNET_INSTALLED---------------------------------
47585 def fndotnet_installed
47590   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
47595   if exists(env$("WINDIR")&"\Microsoft.NET") then 
47600     if exists(dotnet_path$&"\"&fndotnet_local_version$&"\CasPol.exe") then !:
            let fndotnet_installed = 1 !:
          else !:
            let fndotnet_installed = 0
47605   else 
47610     let fndotnet_installed = 0
47615   end if 
47620 fnend 
47630 ! -------------------FNDOTNET_CONFIGURED--------------------------------
47635 def fndotnet_configured
47640   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
47645   if exists(dotnet_path$&"\CLS.CFG") then !:
          let fndotnet_configured = 1 !:
        else !:
          let fndotnet_configured = 0
47650 fnend 
47660 ! -------------------FNCMSERVER_STATUS----------------------------------
47665 def fncmserver_status(mat status_info$)
47670   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
47675   mat status_info$(cmsi_num_elements) = ("")
47680   let myxml = fnopen_xml_writer("[Temp]STAT"&session$&".XML")
47685   let xml_filename$ = file$(myxml)
47690   let fnopen_node(myxml, "status") !:
        let fnopen_node(myxml, "parameters")
47695   let fnclose_xml_writer(myxml)
47700   let fnexec_cmclient_("status", xml_filename$) error L47705 !:
        goto L47710
47705 L47705: let lasterr = err !:
        print lasterr
47710 L47710: dim xml_fields$(1)*20, xml_data$(1)*500, xml_attrib$(1)*20
47715   let xml_reader = fngethandle_ !:
        let result = fnxml_io(xml_reader, xml_filename$, "Select=\status\parameters\*", mat xml_fields$, mat xml_data$, mat xml_attrib$)
47720   let xserver_version = srch(mat xml_fields$, "serverVersion") !:
        if xserver_version < 1 then !:
          let xversion = srch(mat xml_fields$, "version")
47725   let xsession_version = srch(mat xml_fields$, "sessionVersion")
47730   let xserver_os_info = srch(mat xml_fields$, "serverOperatingSystem")
47735   let xsession_os_info = srch(mat xml_fields$, "sessionOperatingSystem")
47740   let xis_service = srch(mat xml_fields$, "runningAsService")
47745   let xis_terminal_server = srch(mat xml_fields$, "terminalServer")
47750   if xserver_version >= 1 then !:
          let status_info$(cmsi_server_version) = trim$(xml_data$(xserver_version))(1:100) !:
        else !:
          if xversion >= 1 then !:
            let status_info$(cmsi_server_version) = trim$(xml_data$(xversion))(1:100)
47755   if xsession_version >= 1 then !:
          let status_info$(cmsi_session_version) = trim$(xml_data$(xsession_version))(1:100)
47760   let status_info$(cmsi_client_version) = trim$(fncmclient_local_version$)
47765   if xserver_os_info >= 1 then !:
          let status_info$(cmsi_server_os_info) = trim$(xml_data$(xserver_os_info))(1:100)
47770   if xsession_os_info >= 1 then !:
          let status_info$(cmsi_session_os_info) = trim$(xml_data$(xsession_os_info))(1:100)
47775   if xis_service >= 1 then !:
          let status_info$(cmsi_is_service) = trim$(xml_data$(xis_service))(1:100)
47780   if xis_terminal_server >= 1 then !:
          let status_info$(cmsi_is_terminal_server) = trim$(xml_data$(xis_terminal_server))(1:100)
47785 fnend 
47790 ! -------------------FNCMCLIENT_LOCAL_VERSION$--------------------------
47795 def fncmclient_local_version$
47800   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
47805   if ~exists(dotnet_local_dir$&"\CMClient.exe") then !:
          let fncmclient_local_version$ = "1.0.0.0" !:
          goto L47845
47810   if fnfile_modified(dotnet_local_dir$, "CMClient.exe") < fngetdir_parse_time("10/01/04  12:00P") then !:
          let fncmclient_local_version$ = "1.1.0.0" !:
          goto L47845
47815   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
47820 L47820: open #(myfile:=fngethandle_): "Name=[WBWORK]cver"&session$&".xml,REPLACE",display,output  !:
        let xml_filename$ = file$(myfile) !:
        close #myfile: 
47825   let scr_thaw: execute 'System -w "'&dotnet_local_dir$&'\CMClient.exe" clientVersion "'&fngetsessionname$&'" "'&xml_filename$&'"' error L47820
47830   let xml_reader = fngethandle_ !:
        let result = fnxml_io(xml_reader, xml_filename$, "Select=\clientVersion\*", mat xml_fields$, mat xml_data$, mat xml_attrib$)
47835   let xclient_version = srch(mat xml_fields$, "version")
47840   if xclient_version >= 1 then !:
          let fncmclient_local_version$ = trim$(xml_data$(xclient_version)) !:
        else !:
          let fncmclient_local_version$ = "1.0.0.0"
47845 L47845: fnend 
47850 ! -------------------FNDOTNET_INSTALL-----------------------------------
47855 def fndotnet_install
47860   if fndotnet_installed and fncomp_version(dotnet_network_version$, fndotnet_local_version$) then !:
          goto END_FNDOTNET_INSTALL
47865   let retval = fnmessagebox_("Install the Microsoft.NET Framework?", 36)
47870   if retval = 6 then !:
          let scr_thaw: execute "SYSTEM -w vbsetup\dotnetfx.exe" !:
        else !:
          goto END_FNDOTNET_INSTALL
47875   if ~fncomp_version(dotnet_network_version$, fndotnet_local_version$) then 
47880     let fnmessagebox_("Wrong version of Microsoft.NET Framework installed!\nPlease notify CLS!", 16)
47885   end if 
47890 END_FNDOTNET_INSTALL: fnend 
47895 ! -------------------FNDOTNET_CONFIGURE---------------------------------
47900 def fndotnet_configure(code_group_name$*100, assembly_file$*100)
47905   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
47910   if ~fndotnet_installed or ~fncomp_version(dotnet_network_version$, fndotnet_local_version$) then !:
          goto END_FNDOTNET_CONFIGURE
47915   let scr_thaw: execute 'SYSTEM -w -M "'&dotnet_path$&'\'&fndotnet_local_version$&'\CasPol.exe" -q -enterprise -remgroup "'&code_group_name$&'" > NUL'
47920   let scr_thaw: execute 'SYSTEM -w -M "'&dotnet_path$&'\'&fndotnet_local_version$&'\CasPol.exe" -q -enterprise -addgroup All_Code -strong -file "'&assembly_file$&'" -noname -noversion FullTrust -exclusive on -levelfinal on -name "'&code_group_name$&'" > NUL'
47925   open #(myfile:=fngethandle_): "NAME="&dotnet_path$&"\CLS.CFG,REPLACE",display,output 
47930   print #myfile: "[CLS .NET Settings]" !:
        print #myfile: ".NET Version = "; fndotnet_local_version$ !:
        print #myfile: "Code Group Name = "; code_group_name$ !:
        print #myfile: "Assembly File = "; assembly_file$
47935   close #myfile: 
47940 END_FNDOTNET_CONFIGURE: fnend 
47945 ! -------------------FNDOTNET_LOCAL_VERSION$----------------------------
47950 def fndotnet_local_version$
47955   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
47960   dim dn_dirs$(1)*80, dn_files$(1)*80, dn_size(1), dn_dates$(1)*80, dn_curdir$*80, dn_final_dir$*80
47965   if len(dn_final_dir$) then goto SKIP_FNDOTNET_VERSION
47970   let fngetdir(dotnet_path$, mat dn_dirs$, mat dn_files$, mat dn_size, mat dn_dates$, "Y")
47975 ! the directories we're interested in begin with 'v' and end in a dotted numeral
47980   for curdir = 1 to udim(mat dn_dirs$)
47985     let dn_curdir$ = dn_dirs$(curdir)
47990     if uprc$(dn_curdir$)(1:1) <> "V" then goto NEXT_CURDIR
47995     if dn_curdir$(2:2) < "0" or dn_curdir$(2:2) > "9" then goto NEXT_CURDIR
48000     if dn_curdir$ > dn_final_dir$ then let dn_final_dir$ = dn_curdir$
48005 NEXT_CURDIR: next curdir
48010 SKIP_FNDOTNET_VERSION: let fndotnet_local_version$ = dn_final_dir$
48015 fnend 
48020 ! -------------------FNDOTNET_READ_CFG----------------------------------
48025 def fndotnet_read_cfg
48030   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
48035   dim cfg_dotnet_version$*30, cfg_code_group_name$*100, cfg_assembly_file$*100, cfg_line$*132, cfg_key$*100, cfg_value$*100
48040   open #(myfile:=fngethandle_): "NAME="&dotnet_path$&"\CLS.CFG", display, input error DOTNET_CFG_ERROR
48045   linput #myfile: cfg_line$ eof DOTNET_CFG_EOF
48050   if cfg_line$ <> "[CLS .NET Settings]" then goto DOTNET_CFG_ERROR
48055 DOTNET_CFG_NEXT: linput #myfile: cfg_line$ eof DOTNET_CFG_EOF
48060   let eqpos = pos(cfg_line$, "=")
48065   if eqpos < 0 then goto DOTNET_CFG_NEXT
48070   let cfg_key$ = trim$(cfg_line$(1:eqpos-1)) !:
        let cfg_value$ = trim$(cfg_line$(eqpos+1:132))
48075   if cfg_key$ = ".NET Version" then let cfg_dotnet_version$ = cfg_value$
48080   if cfg_key$ = "Code Group Name" then let cfg_code_group_name$ = cfg_value$
48085   if cfg_key$ = "Assembly File" then let cfg_assembly_file$ = cfg_value$
48090   goto DOTNET_CFG_NEXT
48095 DOTNET_CFG_EOF: close #myfile: 
48100 DOTNET_CFG_ERROR: fnend 
48105 ! -------------------FNGUI_BROKER_INSTALL-------------------------------
48110 def fngui_broker_install
48115   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
48120   if ~fndotnet_installed or ~fncomp_version(dotnet_network_version$, fndotnet_local_version$) then !:
          goto END_FNGUI_BROKER_INSTALL
48125   let fncmserver_status(mat cmstatus_info$)
48130   let upgrade_svr = 0 !:
        let upgrade_ssn = 0
48135   if fncomp_version("1.0.0.27", cmstatus_info$(cmsi_server_version)) and ~fncomp_version("1.0.0.28", cmstatus_info$(cmsi_server_version)) then !:
          let cmstatus_info$(cmsi_is_service) = "True"
48140   if ~fncomp_version(cmserver_network_version$, cmstatus_info$(cmsi_server_version)) then ! if the server needs to be upgraded
48145     if cmstatus_info$(cmsi_is_service) = "True" then ! if it's a service
48150       if cmstatus_info$(cmsi_is_terminal_server) = "True" then ! if we're running on Terminal Server
48155         let fnmessagebox_("Collection-Master Server Upgrade required!\nPlease contact your System Administrator!", 16) !:
              goto END_FNGUI_BROKER_INSTALL
48160       else 
48165         if exists(dotnet_path$&"\"&fndotnet_local_version$&"\InstallUtil.exe") then !:
                let scr_thaw: execute 'System -w -M "'&dotnet_path$&'\'&fndotnet_local_version$&'\InstallUtil.exe" /u "'&dotnet_service_dir$&'\CMService.exe"' !:
                ! I'm honestly not certain how you'd install it without this program, but okay
48170         let upgrade_svr = 1
48175       end if 
48180     else ! It's not a service
48185       let myfile = fnopen_xml_writer("[WBWORK]sd"&session$&".xml")
48190       let xml_filename$ = file$(myfile)
48195       if fncomp_version("1.1.0.0", cmstatus_info$(cmsi_server_version)) then !:
              let app$ = "shutdownServer" !:
            else !:
              let app$ = "shutdown"
48200       let fnopen_node(myfile, app$) !:
            let fnopen_node(myfile, "parameters")
48205       let fnclose_xml_writer(myfile)
48210       if fncomp_version("1.0.0.34", cmserver_version$) then !:
              open #(sdhnd:=fngethandle_): "Name="&env$("TEMP")&"\GUI_SD.TMP,REPLACE",display,output  !:
              close #sdhnd: 
48215       let fndotnet_notify("Server Stopping")
48220       let fnexec_cmclient_(app$, xml_filename$)
48225       let fndotnet_gui_spinlock(env$("TEMP")&"\GUI_SD.TMP")
48230       let upgrade_svr = 1
48235     end if  ! We should all be uninstalled
48240   end if 
48245   if ~fncomp_version(cmsession_network_version$, cmstatus_info$(cmsi_session_version)) then 
48250     if fncomp_version("1.1.0.0", cmstatus_info$(cmsi_session_version)) then 
48255       let myfile = fnopen_xml_writer("[WBWORK]sd"&session$&".xml") !:
            let xml_filename$ = file$(myfile)
48260       let fnopen_node(myfile, "shutdownSession") !:
            let fnopen_node(myfile, "parameters") !:
            let fnclose_xml_writer(myfile)
48265       let fnexec_cmclient_("shutdownSession", xml_filename$) !:
            let upgrade_ssn = 1
48270     end if 
48275     let upgrade_ssn = 1
48280   end if 
48285   let fndotnet_notify("Installing Server")
48290   mat server_files$(3) !:
        let server_files$(1) = "CMServer.exe" !:
        let server_files$(2) = "CLSShare.dll" !:
        let server_files$(3) = "Server.dll"
48295   mat server_files$(3) !:
        let server_files$(1) = "CMService.exe" !:
        let server_files$(2) = "CLSShare.dll" !:
        let server_files$(3) = "Server.dll"
48300   mat session_files$(6) !:
        let session_files$(1) = "CMSession.exe" !:
        let session_files$(2) = "CLSShare.dll" !:
        let session_files$(3) = "LogApp.dll" !:
        let session_files$(4) = "SpellCheck.dll" !:
        let session_files$(5) = "SpellCheckBO.dll" !:
        let session_files$(6) = "StatusApp.dll"
48305   execute '*mkdir "'&dotnet_local_dir$&'"' error GBI_DIR_EXISTS
48310 GBI_DIR_EXISTS: if ~fncomp_version(cmclient_network_version$, cmstatus_info$(cmsi_client_version)) then 
48315     let fnfile_modified_copy_("CMClient.exe", dotnet_server_dir$, dotnet_local_dir$)
48320   end if 
48325   if upgrade_svr then 
48330     if cmstatus_info$(cmsi_is_service) = "True" then ! if it's a service
48335     end if 
48340     let fnfile_modified_copy_(mat service_files$, dotnet_server_dir$, dotnet_service_dir$)
48345   else 
48350     let fnfile_modified_copy_(mat server_files$, dotnet_server_dir$, dotnet_local_dir$)
48355   end if 
48360   if upgrade_ssn then 
48365     let fnfile_modified_copy_(mat session_files$, dotnet_server_dir$, dotnet_local_dir$)
48370   end if 
48375   if cmstatus_info$(cmsi_is_service) = "True" then ! if it's a service
48380     if cmstatus_info$(cmsi_is_terminal_server) <> "True" then ! if we're not running on Terminal Server
48385       if exists(dotnet_path$&"\"&fndotnet_local_version$&"\InstallUtil.exe") then !:
              let scr_thaw: execute 'System -w -M "'&dotnet_path$&'\'&fndotnet_local_version$&'\InstallUtil.exe" "'&dotnet_local_dir$&'\CMService.exe"'
48390       let scr_thaw: execute 'System -w -M VBSetup.NET\sc.exe start "CM Service"'
48395       let scr_thaw: execute 'System -w -c "'&dotnet_local_dir$&'\CMSession.exe"'
48400     end if 
48405   else 
48410     if exists(local_dir$&'\CMServer.exe') then 
48415       open #(suhnd:=fngethandle_): "Name="&env$("TEMP")&"\GUI_SU.TMP,REPLACE",display,output  !:
            close #suhnd: 
48420       let scr_thaw: execute 'System -w -c "'&dotnet_local_dir$&'\CMServer.exe"' error GBI_SKIP_SPINLOCK
48425       let fndotnet_notify("Starting Server") !:
            let fndotnet_gui_spinlock(env$("TEMP")&"\GUI_SU.TMP")
48430 GBI_SKIP_SPINLOCK: end if 
48435   end if 
48440 END_FNGUI_BROKER_INSTALL: fnend 
48445 ! -------------------FNDOTNET_NOTIFY------------------------------------
48450 def fndotnet_notify(text$*40)
48455   if ~dotnet_notify_hnd then open #(dotnet_notify_hnd:=fngethandle_): "SRow=10,SCol=21,ERow=14,ECol=60,BORDER=S",display,output 
48460   if len(trim$(text$)) = 0 then let text$ = "Installing .NET Functionality"
48465   print #dotnet_notify_hnd: newpage
48470   print #dotnet_notify_hnd, fields "3,"&str$(int((40-len(text$))/2+1))&",C": text$
48475   let fndotnet_notify = dotnet_notify_hnd
48480 fnend 
48485 ! -----LIBRARY-------FNDOTNET_START_GUI---------------------------------
48490 def library fndotnet_start_gui
48495   if ~dotnet_setup_config then gosub DOTNET_SETUP_CONFIG
48500   let scr_thaw: execute 'System -w -c '&dotnet_local_dir$&'\CMServer.exe' error L48505
48505 L48505: fnend 
48510 ! -------------------FNDOTNET_GUI_SPINLOCK------------------------------
48515 def fndotnet_gui_spinlock(filename$*256)
48520   let iter = 1
48525 SL_LOOP: let su_sl = exists(filename$) error END_SL
48530   let sleep(0.5)
48535   if iter > 30 then goto END_SL else let iter += 1
48540   if su_sl then goto SL_LOOP
48545 END_SL: fnend 
48550 ! -------------------FNCOMP_VERSION-------------------------------------
48555 def fncomp_version(req_ver$, avail_ver$; version_delim$)
48560   if len(version_delim$) = 0 then let version_delim$ = "."
48565   let req_ver_delim = avail_ver_delim = 0
48570 CV_NEXT_DELIM: let req_ver_prev = req_ver_delim+1 !:
        let avail_ver_prev = avail_ver_delim+1
48575   let req_ver_delim = pos(req_ver$, version_delim$, req_ver_prev) !:
        let avail_ver_delim = pos(avail_ver$, version_delim$, avail_ver_prev)
48580   if req_ver_delim < 1 or avail_ver_delim < 1 then goto CV_LAST_COMP
48585   let rv$ = req_ver$(req_ver_prev:req_ver_delim-1) !:
        let av$ = avail_ver$(avail_ver_prev:avail_ver_delim-1) !:
        let rv = val(rv$) conv CV_STR_COMP !:
        let av = val(av$) conv CV_STR_COMP
48590   if rv > av then goto CV_VERSION_BAD
48595   goto CV_NEXT_DELIM
48600 CV_STR_COMP: if uprc$(rv$) > uprc$(av$) then goto CV_VERSION_BAD
48605   goto CV_NEXT_DELIM
48610 CV_LAST_COMP: let rv$ = req_ver$(req_ver_prev:len(req_ver$)) !:
        let av$ = avail_ver$(avail_ver_prev:len(avail_ver$)) !:
        let rv = val(rv$) conv CV_FINAL_STR_COMP !:
        let av = val(av$) conv CV_FINAL_STR_COMP
48615   if rv > av then !:
          let fncomp_version = 0 !:
        else !:
          let fncomp_version = 1
48620   goto CV_FNEND
48625 CV_FINAL_STR_COMP: if uprc$(rv$) > uprc$(av$) then !:
          let fncomp_version = 0 !:
        else !:
          let fncomp_version = 1
48630   goto CV_FNEND
48635 CV_VERSION_BAD: let fncomp_version = 0
48640 CV_FNEND: fnend 
48650 ! --LIBRARY---------FNGET_SESSION_NAME$---------------------------------
48652 def library fnget_session_name$*100
48654   let fnget_session_name$=fngetsessionname$
48656 fnend 
48660 ! -------------------FNGETSESSIONNAME$----------------------------------
48665 def fngetsessionname$*100
48670   dim session_name$*100
48675   if len(trim$(session_name$)) > 0 then goto END_FNGETSESSIONNAME
48680   if len(trim$(env$("ComputerName"))) = 0 then !:
          let session_name$ = "Localhost:" !:
        else !:
          let session_name$ = trim$(env$("ComputerName"))&":"
48685   if len(trim$(env$("SessionName"))) = 0 then !:
          let session_name$ = session_name$&"(Console)" !:
        else !:
          let session_name$ = session_name$&"("&trim$(env$("SessionName"))&")"
48690 END_FNGETSESSIONNAME: let fngetsessionname$ = session_name$
48695 fnend 
48700 ! -------------------FNCOMP_FILE_DATE-----------------------------------
48705 def fncomp_file_date(filename$*100, net_file_path$*100, local_file_path$*100)
48710   let network_date = fnfile_modified(net_file_path$, filename$)
48715   let local_date = fnfile_modified(local_file_path$, filename$)
48720   if network_date = -1 then ! file does not exist on network !:
          let fncomp_file_date = -1 !:
          goto END_FNCOMP_FILE_DATE
48725   if local_date < network_date then ! file does not exist locally or is old !:
          let fncomp_file_date = 0 !:
        else !:
          let fncomp_file_date = 1 ! local file is okay
48730 END_FNCOMP_FILE_DATE: fnend 
48735 ! -------------------FNGETDIR_PARSE_TIME--------------------------------
48740 def fngetdir_parse_time(getdir_date$*100)
48745   let d$ = getdir_date$(1:8) !:
        let t$ = getdir_date$(11:16)
48750   let parsed = days(fndate10_(fndate_inp10_$(d$)))
48755   if parsed = 0 then !:
          let fngetdir_parse_time = 0 !:
          goto END_FNGETDIR_PARSE_TIME
48760   let p_time = val(t$(1:2)) !:
        if p_time = 12 then !:
          let p_time = 0
48765   let p_time *= 60 !:
        let p_time += val(t$(4:5)) !:
        if uprc$(t$(6:6)) = "P" then !:
          let p_time += 12*60
48770   let parsed += p_time / (24*60)
48775   let fngetdir_parse_time = parsed
48780 END_FNGETDIR_PARSE_TIME: fnend 
48790 ! -------------------FNFILE_MODIFIED------------------------------------
48795 def fnfile_modified(path$*200, filename$*100; sep$)
48800   if len(trim$(sep$)) = 0 then let sep$ = "\"
48805   if ~exists(path$&sep$&filename$) then !:
          let fnfile_modified = -1 !:
          goto END_FNFILE_MODIFIED
48810   dim fm_dirs$(1)*80, fm_files$(1)*80, fm_size(1), fm_dates$(1)*80
48815   let fngetdir(path$&sep$&filename$, mat fm_dirs$, mat fm_files$, mat fm_size, mat fm_dates$, "Y")
48820   for curdir = 1 to udim(mat fm_files$)
48825     if uprc$(trim$(fm_files$(curdir))) = uprc$(trim$(filename$)) then !:
            let fnfile_modified = fngetdir_parse_time(fm_dates$(curdir)) !:
            let curdir = udim(mat fm_files$)
48830   next curdir
48835 END_FNFILE_MODIFIED: fnend 
48840 ! --LIBRARY----------FNFILE_MODIFIED_COPY-------------------------------
48842 def library fnfile_modified_copy(mat files$, from_dir$*100, to_dir$*100; sep$)
48844   let fnfile_modified_copy=fnfile_modified_copy_(mat files$, from_dir$, to_dir$, sep$)
48846 fnend 
48850 ! -------------------FNFILE_MODIFIED_COPY_------------------------------
48855 def fnfile_modified_copy_(mat files$, from_dir$*100, to_dir$*100; sep$)
48860   if len(trim$(sep$)) = 0 then let sep$ = "\"
48865   let copied = 0
48870   for iter = 1 to udim(mat files$)
48875     if fncomp_file_date(files$(iter), from_dir$, to_dir$) = 0 then !:
            execute '*Copy "'&from_dir$&sep$&files$(iter)&'" "'&to_dir$&'"' error FQC_NEXT_FILE !:
            let copied += 1
48880 FQC_NEXT_FILE: next iter
48885   let fnfile_modified_copy_ = copied
48890 fnend 
48900 def library fnget_status_prompt(status_handle,status_key$,mat groups$,mat status_group$,mat restrict$,mat status$)
48905   dim status_message$*320
48910   let nprompt=0 !:
        mat restrict$(nprompt)=("") !:
        mat status$(nprompt)=("") !:
        mat status_group$(nprompt)=("")
48915   let status_key$=fn_status_code$(status_key$)
48920   read #status_handle,using L48925,search>=status_key$,release: nstatus_code$,status_group$,status_restrict$,status_message$ nokey L48945
48925 L48925: form pos 1,c 3,c 3,c 1,c 320
48930 L48930: if nstatus_code$<>status_key$ then goto L48945
48935   if srch(mat groups$,status_group$)>0 then !:
          let nprompt+=1 !:
          mat restrict$(nprompt) !:
          mat status$(nprompt) !:
          mat status_group$(nprompt) !:
          let restrict$(nprompt)=status_restrict$ !:
          let status$(nprompt)=status_message$ !:
          let status_group$(nprompt)=status_group$
48940   read #status_handle,using L48925,release: nstatus_code$,status_group$,status_restrict$,status_message$ eof L48945 !:
        goto L48930
48945 L48945: let fnget_status_prompt=nprompt
48950 fnend 
48960 def library fnmatch$*512(match_from$*512,match_file_name$*256;match_else$*512)
48965   dim match_cached_file_name$*256,match_data$(2)*512
48970   dim match_from$(1)*512,match_to$(1)*512,match_data$*1024,match_csv_fields$(1)*60
48975   if lwrc$(match_file_name$)&"/custom" <> match_cached_file_name$ then 
48980     mat match_from$(0) : mat match_to$(0)
48985     let csv_open=fnopen_csv_(h_csv:=fngethandle_,match_file_name$&"/custom",csv_delimiter$,mat csv_fields$,mat csv_data$)
48990     let csv_find=srch(csv_fields$,"FIND") !:
          let csv_replace=srch(csv_fields$,"REPLACE")
48995     if csv_open>0 and csv_find>0 and csv_replace>0 then 
49000       let cached_file_name$=lwrc$(file_name$)&"/custom"
49005 L49005: linput #h_csv: match_data$ eof L49050
49010       let fnparse_csv_(match_data$,mat match_data$,csv_delimiter$) !:
            mat match_data$(udim(csv_fields$))
49015       let fn_add_one$(mat match_from$,uprc$(trim$(match_data$(csv_find))))
49020       let fn_add_one$(mat match_to$,match_data$(csv_replace))
49025     else 
49030       let match_cached_file_name$=""
49035       goto X_FNMATCH
49040     end if 
49045     goto L49005
49050 L49050: close #h_csv: ioerr L49055
49055 L49055: end if 
49060   let xlate_ele=srch(mat match_from$,uprc$(trim$(match_from$)))
49065   if xlate_ele>0 then 
49070     let fnmatch$=match_to$(xlate_ele)
49075   else 
49080     let fnmatch$=match_else$
49085   end if 
49090 X_FNMATCH: !:
      fnend 
49100 def library fnrange(rg1_from,rg1_file_name$*128; rg1_else_default)
49102   if ~cls_setup then let fnclssetup
49104   let fnrange=fn_range(rg1_from,rg1_file_name$, rg1_else_default)
49106 fnend  ! fnrange
49110 def fn_range(rg1_from,rg1_file_name$*128; rg1_else_default) ! rg1_
49115   dim rg1_data_range_low(1),rg1_data_range_high(1),rg1_data_value(1)
49120   if pos(rg1_file_name$,'/')<=0 and pos(rg1_file_name$,'\')<=0 then let rg1_file_name$=rg1_file_name$&'/Custom'
49125   let rg1_open_csv_return=fnopen_csv_(rg1_csv_handle:=fngethandle_,rg1_file_name$,rg1_csv_delimiter$,mat rg1_field$,mat rg1_data$)
49130   for rg1_item=1 to udim(mat rg1_field$) : let rg1_field$(rg1_item)=uprc$(rg1_field$(rg1_item)) : next rg1_item
49135   let rg1_range_low=srch(mat rg1_field$,"LOW")
49140   let rg1_range_high=srch(mat rg1_field$,"HIGH")
49145   let rg1_value=srch(mat rg1_field$,"VALUE")
49150   if rg1_open_csv_return>0 and rg1_range_low>0 and rg1_range_high>0 and rg1_value>0 then 
49155     mat rg1_data_range_low(0) : mat rg1_data_range_high(0) : mat rg1_data_value(0)
49160     do 
49165       do 
49170         linput #rg1_csv_handle: rg1_line$ eof RG1_EOF
49175       loop until rg1_line$(1:1)<>'!' and trim$(rg1_line$)<>''
49180       let fnparse_csv_(rg1_line$,mat rg1_data$,rg1_csv_delimiter$)
49185       mat rg1_data$(max(udim(mat rg1_data$),udim(mat rg1_field$)))
49190       let fn_add_one(mat rg1_data_range_low,fnval_(rg1_data$(rg1_range_low)))
49195       let fn_add_one(mat rg1_data_range_high,fnval_(rg1_data$(rg1_range_high)))
49200       let fn_add_one(mat rg1_data_value,fnval_(rg1_data$(rg1_value)))
49205     loop  ! until EOF
49210 RG1_EOF: ! 
49215   end if 
49220   close #rg1_csv_handle: ioerr ignore
49225 ! 
49230   for rg1_item=1 to udim(mat rg1_data_range_low)
49235     if rg1_data_range_low(rg1_item)<=rg1_from and rg1_from<=rg1_data_range_high(rg1_item) then 
49240 L49240: let rg1_return=rg1_data_value(rg1_item)
49245       goto RG1_XIT
49250     end if  ! rg1_from within range
49255   next rg1_item
49260   let rg1_return=rg1_else_default
49265   goto RG1_XIT
49270 RG1_XIT: ! 
49275   let fn_range=rg1_return
49280 fnend  ! fn_range
49290 def library fnrange$*128(rg2_from,rg2_file_name$*128; rg2_else_default$*128)
49292   if ~cls_setup then let fnclssetup
49294   let fnrange$=fn_range$(rg2_from,rg2_file_name$, rg2_else_default$)
49296 fnend  ! fnrange$
49300 def fn_range$*128(rg2_from,rg2_file_name$*128; rg2_else_default$*128) ! rg2_
49305   dim rg2_data_range_low(1),rg2_data_range_high(1),rg2_data_value$(1)*128,rg2_line$*256
49310   if pos(rg2_file_name$,'/')<=0 and pos(rg2_file_name$,'\')<=0 then let rg2_file_name$=rg2_file_name$&'/Custom'
49315   let rg2_open_csv_return=fnopen_csv_(rg2_csv_handle:=fngethandle_,rg2_file_name$,rg2_csv_delimiter$,mat rg2_field$,mat rg2_data$)
49320   for rg2_item=1 to udim(mat rg2_field$) : let rg2_field$(rg2_item)=uprc$(rg2_field$(rg2_item)) : next rg2_item
49322   mat rg2_data_range_low(0) : mat rg2_data_range_high(0) : mat rg2_data_value$(0)
49325   let rg2_range_low=srch(mat rg2_field$,"LOW")
49330   let rg2_range_high=srch(mat rg2_field$,"HIGH")
49335   let rg2_value=srch(mat rg2_field$,"VALUE")
49340   if rg2_open_csv_return>0 and rg2_range_low>0 and rg2_range_high>0 and rg2_value>0 then 
49350     do 
49355       do 
49360         linput #rg2_csv_handle: rg2_line$ eof RG2_EOF
49365       loop until rg2_line$(1:1)<>'!' and trim$(rg2_line$)<>''
49370       let fnparse_csv_(rg2_line$,mat rg2_data$,rg2_csv_delimiter$)
49375       mat rg2_data$(max(udim(mat rg2_data$),udim(mat rg2_field$)))
49380       let fn_add_one(mat rg2_data_range_low,fnval_(rg2_data$(rg2_range_low)))
49385       let fn_add_one(mat rg2_data_range_high,fnval_(rg2_data$(rg2_range_high)))
49390       let fn_add_one$(mat rg2_data_value$,rg2_data$(rg2_value))
49395     loop  ! until EOF
49400 RG2_EOF: ! 
49405   end if 
49410   close #rg2_csv_handle: ioerr ignore
49415 ! 
49420   for rg2_item=1 to udim(mat rg2_data_range_low)
49425     if rg2_data_range_low(rg2_item)<=rg2_from and rg2_from<=rg2_data_range_high(rg2_item) then 
49430       let rg2_return$=rg2_data_value$(rg2_item)
49435       goto RG2_XIT
49440     end if  ! rg2_from within range
49445   next rg2_item
49450   let rg2_return$=rg2_else_default$
49455   goto RG2_XIT
49460 RG2_XIT: ! 
49465   let fn_range$=rg2_return$
49470 fnend  ! fn_range$
49480 def fncode$(x1)
49482   if x1<-20202 then let x1=0
49484   let fncode$=cnvrt$("PIC($$,$$$,$$$.##-)",x1) conv L49240
49486 fnend 
49490 def library fn7(seven_handle,fileno$,&l7_fileno$,mat u$)
49495   if not setup_7 then gosub SETUP_7
49500   if fileno$=l7_fileno$ then !:
          mat u$=u_cache$ !:
          goto EXIT_7 !:
        else !:
          let l7_fileno$=fileno$
49505   mat u$=("") : mat u=(0) !:
        mat u_cache$(udim(u$))=("") !:
        read #seven_handle,using formr$,key=fileno$,release: tfileno$,mat u$ ioerr EXIT_7
49510   for z=1 to udim(u$) !:
          let u(z)=val(srep$(srep$(u$(z),"/",""),"$","")) conv L49515
49515 L49515: if field_type$(z)(1:1)="N" or trim$(field_type$(z))="C 8" then !:
            goto L49520 else goto L49535
49520 L49520: if trim$(field_type$(z))="C 8" and pos(field_pos$(z),"##/##/##")<=0 then goto L49535
49525     if field_type$(z)(1:1)="N" and pos(field_type$(z),".2")>0 then let u$(z)=fncode$(u(z)) !:
            goto L49535 else if field_type$(z)(1:1)="N" then goto L49535
49530   let u$(z)=date$(days(u(z)))
49535 L49535: next z
49540 mat u_cache$=u$
49545 EXIT_7: !:
      fnend 
49550 def library fnexist_cache_update(ecu_folder$*256)
49555   let exists_cache_ele=srch(exists_cache$,ecu_folder$)
49560   if exists_cache_ele>0 then !:
          let exists_cache(exists_cache_ele)=1
49565 fnend 
49570 def library fnrmdir_exists_cache(rm_folder$*256)
49575   execute "rmdir "&rm_folder$
49580   let exists_cache_ele=srch(exists_cache$,rm_folder$)
49585   if exists_cache_ele>0 then !:
          let exists_cache(exists_cache_ele)=0
49590 fnend 
49600 SETUP_7: ! r: STARTUP USER DEFINED ROUTINE
49605 L49605: form pos 1,b 4,datar*v 32,datar*v 8,v 1024,v 1024
49610 open #setup_7=fngethandle_: "NAME=USERDEF.FIL//9,shr",internal,outin,relative ioerr L49645
49615 read #setup_7,using L49605,rec=1,release: datar
49620 mat field_pos$(datar)=("") : mat field_type$(datar)=("") : mat u$(datar)=("") : mat tu$(datar)=("") !:
      mat u(datar)=(0)
49625 read #setup_7,using L49605,rec=1,release: datar,mat field_pos$,mat field_type$,fhelp$,formr$
49630 close #setup_7: 
49635 open #seven_handle: "NAME=USERDEF.INT//6,kfname=userdef.idx//6,shr",internal,outin,keyed ioerr L49645
49640 let dleno=8: let formo$="FORM POS 1,C 8": for z=1 to udim(field_type$): let work$=field_type$(z)(2:len(field_type$(z))): let formo$=formo$&",C "&str$(int(val(work$))) : let dleno+=int(val(work$)): next z : let datao=udim(field_type$)
49645 L49645: return ! /r
49650 def library fnget_group_count(mat groups$,mat group_code$,mat group_name$)
49655 F_GROUPMEM: form pos 1,2*c 3
49660   let groups=fnget_groups_(mat group_code$,mat group_name$)
49665   mat groups$(groups)
49670   let groupmem_handle=fngetfile("name=GROUPMEM//8,KFNAME=GROUPMEM.GRP//8,USE,RECL=6,KPS=1/4,KLN=3U/3U,SHR")
49675   for g_ele=1 to groups
49680     let group$=group_code$(g_ele) !:
          let groups$(g_ele)=group_code$(g_ele)&""&group_name$(g_ele)&" #### Members" !:
          let subtot=0
49685     read #groupmem_handle,using F_GROUPMEM,search>=group$&rpt$(chr$(0),3),release: tgroup$,tinit$ nokey GROUP_LOOP
49690 GROUP_TOL: if tgroup$=group$ then !:
            let subtot+=1 !:
          else !:
            goto GROUP_LOOP
49695     read #groupmem_handle,using F_GROUPMEM,release: tgroup$,tinit$ eof GROUP_LOOP !:
          goto GROUP_TOL
49700 GROUP_LOOP: !:
          let groups$(g_ele)(47:50)=lpad$(str$(subtot),4)
49705   next g_ele
49710 fnend 
49720 def fnget_groups_(mat group_code$,mat group_name$)
49725   let groups_handle=fngetfile("name=GROUPS//8,KFNAME=GROUPS.IDX//8,USE,RECL=43,KPS=1,KLN=3U,SHR")
49730   let ngroups=0 !:
        mat group_code$(0)=(""): mat group_name$(0)=("")
49735 L49735: read #groups_handle,using L38265,release: group_code$,group_name$ eof L49750
49740   let ngroups+=1 !:
        mat group_code$(ngroups) !:
        mat group_name$(ngroups) !:
        let group_code$(ngroups)=group_code$ !:
        let group_name$(ngroups)=group_name$
49745   goto L49735
49750 L49750: if ngroups=0 then !:
          let ngroups=1 !:
          mat group_code$(1)=("***"): mat group_name$(1)=("Everyone")
49755   let fnget_groups_=ngroups
49760 fnend 
49770 def library fnget_groups(mat group_code$,mat group_name$)
49772   let fnget_groups=fnget_groups_(mat group_code$,mat group_name$)
49774 fnend 
49780 def library fnget_user_groups(init$,mat group_code$)
49785   let groupmem_handle=fngetfile("Name=GROUPMEM//8,KFNAME=GROUPMEM.USR//8,USE,RECL=6,KPS=4/1,KLN=3U/3U,SHR")
49790   let ngroups=0 !:
        mat group_code$(0)=("")
49795   read #groupmem_handle,using L49800,search>=init$,release: group_code$,group_user_init$ nokey L49825
49800 L49800: form pos 1,2*c 3
49805 L49805: if group_user_init$<>init$ then goto L49825
49810   let ngroups+=1 !:
        mat group_code$(ngroups) !:
        let group_code$(ngroups)=group_code$
49815   read #groupmem_handle,using L49800,release: group_code$,group_user_init$ eof L49825
49820   goto L49805
49825 L49825: if ngroups=0 then let ngroups=1 !:
          mat group_code$(1)=("***")
49830 fnend 
49840 def library fnget_array$*512(mat array$,element)
49842   if element<1 or element>udim(array$) then goto L49846
49844   let fnget_array$=array$(element)
49846 L49846: fnend 
49850 def library fnget_array(mat array,element)
49852   if element<1 or element>udim(array) then goto L49856
49854   let fnget_array=array(element)
49856 L49856: fnend 
49860 ! --LIBRARY----------FNDELTA_INT----------------------------------------
49865 def library fndelta_int(finan_handle, fileno$, pdate, ptanum)
49870   let fileno$ = rpad$(fileno$, 8)(1:8)
49875   if pos(uprc$(file$(finan_handle)),"ACTIV")>0 then !:
          print "WARNING - YOU MUST USE FINAN.INT NOT ACTIVE.INT!" !:
          let kstat$(1) !:
          goto END_FNDELTA_INT
49880   if file(finan_handle) then !:
          let fndelta_int = 0 !:
          goto END_FNDELTA_INT
49885   let last_dig=ord(fileno$(8:8)) !:
        let next_file$=fileno$(1:7)&chr$(mod(last_dig+1,256))
49890   read #finan_handle,using L49895,search>=next_file$,release: tfileno$ nokey L49900 !:
        goto L49905
49895 L49895: form pos 1,c 8
49900 L49900: restore #finan_handle,last: 
49905 L49905: let retval = fnread_prior_finan(finan_handle, fileno$, pdate, ptanum, curfileno$, curdate, int1, curtanum, curtype$, curc0de$)
49910   if retval<0 then goto END_FNDELTA_INT
49915   let retval = fnread_prior_finan(finan_handle, fileno$, 0, -1, curfileno$, curdate, int2, curtanum, curtype$, curc0de$)
49920   if retval<0 then let int2 = 0
49925   let fndelta_int = int1 - int2
49930 END_FNDELTA_INT: fnend 
49940 def fnread_prior_finan(finan_handle, pfileno$, pdate, ptanum, &curfileno$, &curdate, &curint, &curtanum, &curtype$, &curc0de$)
49945 L49945: let curfileno$=curtype$=curc0de$="" !:
        let curdate=curtanum=0 !:
        read #finan_handle,using L49950,prior,release: curfileno$, curdate, curtanum, curtype$, curc0de$ eof L49960
49950 L49950: form pos 1,c 8,pos 9,bh 4,pos 78,bh 3,pos 25,c 1,pos 17,c 8
49955 L49955: form pos 209,pd 6.2
49960 L49960: if curfileno$<>fileno$ then !:
          let fnread_prior_finan=-1 !:
          goto L50000
49965   let c0de = int(val(curc0de$)) conv L49945
49970   if c0de<>2 and not (c0de>=20 and c0de<=28) then goto L49945
49975   reread #finan_handle,using L49955,release: curint
49980 ! PRINT "Mark 1:"; PFILENO$; "|"; STR$(PDATE); "|"; STR$(PTANUM); "|"; CURFILENO$; "|"; STR$(CURDATE); "|"; STR$(CURINT); "|"; STR$(CURTANUM); "|"; CURTYPE$; "|"; CURC0DE$
49985   if ptanum>=0 and days(pdate)<>days(curdate) then goto L49945
49990   if ptanum>0 and ptanum=curtanum then goto L50000
49995   if ptanum>0 then goto L49945
50000 L50000: fnend 

50010   def library fnmax_page(filnum)
50015     dim nfile$*256
50020     let nfile$=file$(filnum)(1:4) !:
          let nrec=krec(filnum)
50025     let max_win_page=60 !:
          ! if WBVERSION$="4.18d" THEN LET MAX_WIN_PAGE=59 !:
          ! * BR 4.18d had a problem only allows 60 lines on 1 page !:
          ! ** The newer 4.18d no longer has this problem !:
          ! ** Note: This used to be 61 pages!:
          ! TODO: Test to see if WIN can get away with 61
50030     if nfile$="WIN:" and nrec>=max_win_page then !:
            let fnmax_page=1 !:
            goto L50040
50035     if nfile$<>"WIN:" and nrec>=60 then let fnmax_page=1
50040 L50040: fnend 
50050   def library fnkrec(filnum)
50052     if file$(filnum)(1:4)="WIN:" then !:
            let fnkrec=krec(filnum)-1 else !:
            let fnkrec=krec(filnum)
50054   fnend 
50060 ! FNLIKE compares LIKEA$ to LIKEB$ !:
        ! Case , and RTRM or spaces are ignored !:
        ! * At end may be used in LIKEB$!:
        ! ? May be used in LIKEB$ to represent a "Wild Character".!:
        ! TODO: We could enhance this to suppor more complete LIKE Clauses including wild cards on both sides.
50065   def library fnlike(likea$*512, likeb$*512)
50066     let fnlike=fn_like(likea$, likeb$)
50067   fnend 
50068   def fn_like(likea$*512, likeb$*512)
50070     let likea$=rtrm$(uprc$(likea$)) : let likeb$=rtrm$(uprc$(likeb$))
50075     if likea$=likeb$ then !:
            let fn_like=1 : goto EXIT_FNLIKE
50080     let pointer=1 : let wildpointer2=1 : let strpointer2=1 : let wildpointer1=1 : let strpointer1=1
50085     if (pos(likeb$,"**")>0) then 
50090       goto EXIT_FNLIKE ! This occurs if an invalid wildcard is present
50095     end if 
50100     let pointer = 1
50105     do while ((pointer <= len(likea$)) and (likeb$(pointer:pointer)<>"*"))
50110       if ((likea$(pointer:pointer)<>likeb$(pointer:pointer)) and (likeb$(pointer:pointer)<>"?")) then 
50115         goto EXIT_FNLIKE ! This occurs if the strings do not match and no wildcard is current, e.g. "abc","ae*"
50120       end if 
50125       let pointer = pointer + 1
50130     loop 
50135     let wildpointer1 = pointer : let strpointer1 = pointer ! if we reach this point, then either a wildcard is found or we have traversed the string
50140     do while (strpointer1 <= len(likea$))
50145       if (likeb$(wildpointer1:wildpointer1) = "*") then 
50150         let wildpointer1 = wildpointer1 + 1
50155         if (likeb$(wildpointer1:wildpointer1)="") then 
50160           let fn_like=1 : goto EXIT_FNLIKE ! This occurs if the last part of the wildcard is *
50165         end if 
50170         let wildpointer2 = wildpointer1 ! We move the wildcard pointer to the next point, e.g. "*efgh" becomes "efgh"
50175         let strpointer2 = strpointer1+1
50180       else 
50185         if ((likeb$(wildpointer1:wildpointer1)=likea$(strpointer1:strpointer1)) or (likeb$(wildpointer1:wildpointer1)="?")) then 
50190           let wildpointer1 = wildpointer1+1
50195           let strpointer1 = strpointer1+1 ! if a match occurs, siwildpointer2ly increment both pointers
50200         else 
50205           let wildpointer1 = wildpointer2
50210           let strpointer1=strpointer2
50215           let strpointer2 = strpointer2+1 ! This section is where the wildcard effect occurs, e.g. the string pointer moves while the wildcard pointer stays still
50220         end if 
50225       end if 
50230     loop 
50235     do while (likeb$(wildpointer1:wildpointer1)="*")
50240       let wildpointer1=wildpointer1+1 ! Basically "ignore" any '*' wildcards
50245     loop 
50250     if (likeb$(wildpointer1:wildpointer1)="") then 
50255       let fn_like=1 : goto EXIT_FNLIKE ! Everything is matched 1 to 1
50260     else 
50265       let fn_like=0 : goto EXIT_FNLIKE ! There exists a string in wildcard that is yet to be matched
50270     end if 
50275 EXIT_FNLIKE: fnend 
50280   def library fnget_file$*256(x_row;data_fil$*256)
50285     dim data_fil$*40
50290 L50290: print fields str$(x_row)&",1,CR 30,[W];24,1,CC 80,[S]": "Enter Name of File To Process:","Enter Name of ASCII File  'F5' for List"
50295 L50295: rinput fields str$(x_row)&",32,40/C 256,[D]SAE": data_fil$
50300     if cmdkey=5 and trim$(data_fil$)="" then !:
            let data_fil$=fnopen_$("N:*.*"): goto L50295 !:
            goto L50295 else !:
            if cmdkey=5 then let data_fil$=fnopen_$(trim$(data_fil$)) !:
              goto L50295
50305     if trim$(data_fil$)="" or (cmdkey=99 or cmdkey=93) then goto EXIT_GET_FILE
50310     on error goto L50290
50315     if pos(data_fil$,"*")>0 or pos(data_fil$,"?")>0 then !:
            let data_fil$=fnopen_$(trim$(data_fil$)) !:
            goto L50295
50320     on error system 
50325     let df_handle=fngethandle_
50330     open #df_handle: "NAME="&data_fil$,internal,input,relative ioerr L50335 !:
          close #df_handle: !:
          goto L50345
50335 L50335: open #df_handle: "NAME="&trim$(data_fil$)&",recl=512",display,input ioerr L50295
50340     close #df_handle: 
50345 L50345: let fnget_file$=data_fil$
50350 EXIT_GET_FILE: !:
        fnend 
50360   def library fnmsword_template(mat msword_code$,mat msword_template$)
50365     dim msword_code$*80,msword_template$*80
50370     let msword_handle=fngetdisplay_("MSWORD.TXT/WP") !:
          let nword=0
50375 L50375: linput #msword_handle: buff$ eof L50395 !:
          let npos=pos(buff$,",")
50380     let msword_code$=buff$(1:npos-1) !:
          let msword_template$=buff$(npos+1:99)
50385     let nword+=1 !:
          mat msword_code$(nword) !:
          mat msword_template$(nword) !:
          let msword_code$(nword)=msword_code$ !:
          let msword_template$(nword)=msword_template$
50390     goto L50375
50395 L50395: close #msword_handle: 
50400     let fnmsword_template=nword !:
          ! End of MSWORD_TEMPLATE
50405   fnend 
50410   def library fnps_spell(mat ps$)
50415     dim ps$*2000
50420     let orig_spell_fkey=fkey !:
          let fkey(-1) !:
          let nspell=0 !:
          let ps_spell=0 !:
          let fnsetup_spell
50425 L50425: let nspell+=1 !:
          let tspell=nspell !:
          let ps$=""
50430 L50430: let ps$=ps$&ps$(tspell) !:
          if trim$(ps$(tspell))(55:60)<>"" and tspell<>udim(ps$) then let tspell+=1 !:
            goto L50430 !:
            ! ** Build a "Long Wraparound"
50435     if tspell<udim(ps$) and trim$(ps$(tspell+1))="" then let tspell+=1 !:
            goto L50430
50440     if len(ps$)>60 and tspell<udim(ps$) and len(rtrm$(ps$(tspell)))>50 then let tspell+=1 !:
            goto L50430
50445     if ~fnspellcheck(ps$,"",99) then let ps_spell=1 else !:
            goto L50460 !:
            ! ** Do not bother fixing lines that are spelled correctly
50450     let nfixed=nspell
50455 L50455: let ps$=ltrm$(ps$) !:
          let ps$(nfixed)=ps$(1:60) !:
          let ps$(1:60)="" !:
          let nfixed+=1 !:
          if nfixed<=tspell and trim$(ps$)<>"" then goto L50455 !:
          else !:
            if trim$(ps$)<>"" then let ps$(nfixed-1)(60:60)="*" !:
              ! ** Rebuild PS statement with spelled version !:
              ! ** Note: It may truncate the PS Statement
50460 L50460: let nspell=tspell
50461     if fkey<>99 and nspell<udim(ps$) then goto L50425
50464     if fkey<>orig_spell_fkey then !:
            let fkey(orig_spell_fkey)
50465     let fnps_spell=ps_spell
50470   fnend 
50480   def library fnstat_locks(message$*2048,title$*512;filename$*256)
50482     let fnstat_locks=fn_stat_locks(message$,title$,filename$)
50484   fnend 
50490   def fn_stat_locks(message$*2048,title$*512;filename$*256)
50495     dim locks$(1)*80,current_users_of$*80
50500     execute "stat locks >[wbwork]LOCK[SESSION].TXT"
50505     let fnasci_("[wbwork]LOCK[SESSION].TXT",mat locks$)
50510     let locks_handle=fngethandle_ !:
          let fn_stat_locks=locks_handle
50515     let current_users_of$="" !:
          let start_display=0
50520     for _locks=1 to udim(locks$)
50525       if uprc$(trim$(locks$(_locks)))(1:17)="CURRENT USERS OF " then !:
              let current_users_of$=trim$(locks$(_locks)(18:999)) !:
              ! LET fn_list_print("",LOCKS_HANDLE,TRUE:=1,"Title="&CURRENT_USERS_OF$&" Heading=Login Name;WSID;Session;Share Type Form=C;CR;C;C Width=20;4;10;10")
50530       if start_display=0 and trim$(locks$(_locks))="--------- ---- --------- ----------" then !:
              let start_display=_locks
50535       if start_display>0 and _locks>start_display then !:
              let fn_list_print(locks$(_locks)(26:99)&""&locks$(_locks)(11:15)&""&locks$(_locks)(16:25)&""&locks$(_locks)(1:10),locks_handle,true:=1,"Title="&current_users_of$&" Heading=Login Name;WSID;Session;Share Type Form=C;CR;C;C Width=20;4;10;10")
50540     next _locks
50545     let fnmessagebox_(message$,64,title$)
50550     close #locks_handle: ioerr L50555 !:
          let locks_handle=0
50555 L50555: fnend 
50560   def library fnorig_trans_date(fileno$*8,h_active,matrix_type$,mat acceptable$; fow,sort$,last_action_code$)
50562     let fnorig_trans_date=fn_orig_trans_date(fileno$,h_active,matrix_type$,mat acceptable$, fow,sort$,last_action_code$)
50564   fnend  ! fnOrig_Trans_Date
50570   def fn_orig_trans_date(fileno$*8,h_active,matrix_type$,mat acceptable$; fow,sort$,last_action_code$)
50575 ! library "CLSUtil/Library": FNCACHE_MATRIX ! just remove the _ from the one call to put it back in CLSUTIL
50580     dim nfileno$*8 ! ,OTD_ACTIVE_FORM$*30
50585     dim reason$*80
50590     if otd_active_form$="" then 
50595       let otd_active_form$=cform$("Form C 8,BH 4,Pos 65,C 8")
50600     end if 
50605 ! 
50610 ! Set Nfileno to next possibity
50615     let fileno$=rpad$(trim$(fileno$),8)
50620     let nfileno$=fileno$(1:7)&chr$(ord(fileno$(8:8))+1)
50625 ! 
50630     let llcode$=edi_code$="" : let active_data_trans_date=0
50635     read #h_active,search>=nfileno$,release: nokey OTD_READLAST
50640 OTD_READ: ! 
50645     read #h_active,using otd_active_form$,prior,release: newfileno$,active_data_trans_date,llcode$ eof OTD_FAILURE
50650     if newfileno$<>fileno$ then 
50655       let reason$="couldn't find active record"
50660       goto OTD_FAILURE
50665     end if  ! NEWFILENO$<>FILENO$
50670     if fncachematrix(llcode$,fow,matrix_type$,sort$, mat action$,edi_code$)=0 then 
50675       goto OTD_READ
50680     end if  ! FNCACHEMATRIX=0
50685     if trim$(acceptable$(1))<>"" and srch(mat acceptable$,uprc$(trim$(edi_code$)))<=0 then 
50690       goto OTD_READ
50695     end if  ! TRIM$(ACCEPTABLE$(1))<>"" AND SRCH(MAT ACCEPTABLE$,UPRC$(TRIM$(EDI_CODE$)))<=0
50700     if trim$(last_action_code$)<>"" and srch(mat action$,last_action_code$)<=0 then 
50705       goto OTD_READ
50710     end if  ! TRIM$(LAST_ACTION_CODE$)<>"" AND SRCH(MAT ACTION$,LAST_ACTION_CODE$)<=0
50715     goto OTD_DONE
50720 ! 
50725 OTD_FAILURE: ! 
50730     if uprc$(env$("Debug"))="YES" then print "FAILED - "&reason$
50735     let active_data_trans_date=0
50740     goto OTD_XIT
50745 ! 
50750 OTD_DONE: ! 
50755     let fn_orig_trans_date=active_data_trans_date
50760     goto OTD_XIT
50765 ! 
50770 OTD_READLAST: ! 
50775     read #h_active,last,release: 
50780     goto OTD_READ
50785 ! 
50790 OTD_XIT: ! 
50795   fnend  ! fn_Orig_Trans_Date
50800   def library fnhelp(; hh_pk$*80,hh_cap$*80)
50802     gosub SETUP_LIBRARY
50804     gosub SETUP_CONSTANTS
50806     gosub SETUP_SQL_HLPLNK1
50808     gosub SETUP_SQL_HLPLNK2
50810     let fnhelp=fn_help( hh_pk$,hh_cap$)
50812   fnend  ! FnHelp(; hh_pk$)
50820   def fn_help(; hh_pk$*80,hh_cap$*80) ! hh_
50825 ! todo: enhance with a command like      hh.exe mk:@MSITStore:F:\Siul\CLSInc\Help\CM73.chm::/Setup/col_order.htm
50830 ! see also:     http://www.help-info.de/en/Help_Info_HTMLHelp/hh_command.htm
50835     if hh_cap$='' then let hh_cap$='Help for '&hh_pk$
50840     if hh_pk$='' then 
50845       gosub HH_CHM_MAIN_PAGE
50850     else 
50855       let hh_hlplnk1_handle=fnindex_handle("Name=hlplnk1.int/help,KFName=hlplnk1.Idx/help",'Input',hh_hlplnk1_record_prior)
50860       if hh_hlplnk1_handle>0 then 
50865         if hh_pk$(1:7)='STATUS:' then let hh_pk$='3-9'
50870         let hh_pk$=fnpk_cleanup$(hh_pk$,0)
50875         dim hh_title$(1)*100,hh_file_path$(1)*128,hh_option$(1)*256
50880         do 
50885           let hh_pk$=rpad$(hh_pk$,80)
50890           mat hh_title$(0)
50895           mat hh_file_path$(0)
50900           mat hh_option$(0)
50905           let hh_option_count=0
50910           mat hlplnk1_data$=('')
50915           read #hh_hlplnk1_handle,using hlplnk1_formc$,key>=hh_pk$: mat hlplnk1_data$ ioerr ignore
50920           do 
50925             if hlplnk1_data$(hlplnk1_pk)=hh_pk$ and file(hh_hlplnk1_handle)=0 then 
50930               let hh_option_count+=1
50935               let fn_add_one$(mat hh_title$,hlplnk1_data$(hlplnk1_title))
50940               let fn_add_one$(mat hh_file_path$,hlplnk1_data$(hlplnk1_file_path))
50945               dim hh_file_tmp$*20
50950               let hh_file_tmp$=hlplnk1_data$(hlplnk1_file_path)(6:pos(lwrc$(hlplnk1_data$(hlplnk1_file_path)),'.chm')-1)
50955               let fn_add_one$(mat hh_option$,str$(hh_option_count)&''&hlplnk1_data$(hlplnk1_title)&''&hh_file_tmp$)
50960             end if  ! hlplnk1_data$(hlplnk1_pk)=hh_pk$ and and file(hh_hlplnk1_handle)=0
50965             mat hlplnk1_data$=('')
50970             read #hh_hlplnk1_handle,using hlplnk1_formc$: mat hlplnk1_data$ ioerr ignore
50975           loop while hlplnk1_data$(hlplnk1_pk)=hh_pk$ and file(hh_hlplnk1_handle)=0
50985           if hh_option_count<1 then 
50990             let fn_log('Help\PK_Not_Found.log','climb'&tab$&hh_pk$)
50995             let fnremovepk_part$(hh_pk$,1)
51000           else if hh_option_count=1 then 
51005             let hlplnk1_data$(hlplnk1_file_path)=hh_file_path$(1)
51010             let hlplnk1_data$(hlplnk1_title)=hh_title$(1)
51015             gosub HH_CHM_TARGETED_PAGE
51020             goto HH_FINIS
51025           else if hh_option_count>1 then 
51030             let hh_option_choice_default=0
51035             do 
51040               let hh_option_choice=fnwinscroll_(mat hh_option$, hh_option_choice_default,'Title=Collection-Master Help for '&hh_pk$&' Heading=No;Title;Location','','Keys=0;99 Labels=View;[Esc] Close') ! ,3,2,22,78)
51045               if fkey<>93 and fkey<>99 then 
51050                 let hh_option_choice_default=hh_option_choice
51055                 let hlplnk1_data$(hlplnk1_file_path)=hh_file_path$(hh_option_choice)
51060                 let hlplnk1_data$(hlplnk1_title)=hh_title$(hh_option_choice)
51065                 gosub HH_CHM_TARGETED_PAGE
51070               end if  ! fkey<>93 and fkey<>99
51075             loop until fkey=93 or fkey=99
51080             let fkey(0)
51085             goto HH_FINIS
51090           end if  ! hh_option_count>1   /   hh_option_count=0 and hh_pk$<>''
51095         loop until hh_pk$=''
51100         gosub HH_CHM_MAIN_PAGE
51105         goto HH_FINIS
51110       else 
51115         if debug then print 'hh_hlplnk1_handle=';hh_hlplnk1_handle;' (fnindex_handle failed!)'
51120         if developer then pause 
51125         gosub HH_CHM_MAIN_PAGE
51130       end if  ! hh_hlplnk1_handle>0   /   else 
51135     end if  ! hh_pk$=''   /   else 
51140     goto HH_XIT
51145 HH_CHM_TARGETED_PAGE: ! 
51150     execute "Sys -w -c hh.exe mk:@MSITStore:"&hlplnk1_data$(hlplnk1_file_path)
51155 !   let fnmessagebox_("Help Launched,\nKey="&hh_pk$&"\nDecription="&hlplnk1_data$(hlplnk1_title)&"\nDoc="&hlplnk1_data$(hlplnk1_file_path),mb_information+mb_okonly,"Help Invoked")
51160     return  ! HH_CHM_TARGETED_PAGE
51165 HH_CHM_MAIN_PAGE: ! 
51170     if debug then print 'HH_CHM_MAIN_PAGE'
51175     execute 'Sy -w -c hh.exe mk:@MSITStore:Help\CM8x.chm::HELP/NOpage.htm'
51180     return  ! HH_CHM_MAIN_PAGE
51185 HH_FINIS: ! 
51190     if hh_hlplnk1_record_prior<=0 then close #hh_hlplnk1_handle: 
51195     let hh_hlplnk1_handle=0
51200 HH_XIT: ! 
51205   fnend  ! Fn_Help
51260 CALL_FNMENU2: ! r: M_M2_  (fnmenu uses this routine to call fnmenu2)
51265   dim m_m2_option$(1)*80
51270   let m_m2_option_count=udim(mat selmenu$)
51275   mat m_m2_option$(m_m2_option_count)
51280   for m_m2_item=1 to m_m2_option_count
51285     let m_m2_option$(m_m2_item)=selmenu$(m_m2_item)
51290     let m_m2_option$(m_m2_item)(1:5)=srep$(m_m2_option$(m_m2_item)(1:5),'.','')
51295   next m_m2_item
51300   if default_selection<=0 or default_selection>udim(mat m_m2_option$) then let m_m2_default_selection$='' else let m_m2_default_selection$=trim$(m_m2_option$(default_selection)(1:pos(m_m2_option$(default_selection),"")-1))
51305   if nnp=2 then let m_m2_preserve_backgroup=1 else let m_m2_preserve_backgroup=0
51310   let menu_curfld=fnmenu2(title$,cap$,pk$,mat m_m2_option$,m_m2_default_selection$,m_trust$,m_timeout,footer$,m_m2_preserve_backgroup)
51315   return  ! /r CALL_FNMENU2
51320   def fnsetup_spell
51322     if ~setup_spell then let setup_spell=1 else goto L51326
51324     library "SPELL/LIBRARY": fnspellcheck
51326 L51326: fnend 
51330   def fnchanges_(changes_handle,active_handle,trans_date,trans_time,fileno$,debtor_no,relation,type$,changes_code$,changes_desc$*11,user_id,recno,mat before_data$,mat before_data,mat after_data$,mat after_data,mat fieldsc$,mat fieldsn$,table_name$,account)
51332     dim nvalue$*60
51334     let table_name$=uprc$(table_name$) !:
          if account=1 then let changes_code$="" !:
            ! ** if new placement, do not bother making a note in the paperless file!
51336     if ~setup_changes then let fnsetup_changes
51338     if trim$(file$(changes_handle))="" or trim$(file$(active_handle))="" then print "WARNING CHANGES.INT & ACTIVE.INT MUST BE OPENED!" !:
            let kstat$(1) !:
            goto L51388
51340     if trans_date=0 then let trans_date=date("CCYYMMDD") else let trans_date=fndate10_(str$(trans_date))
51342     if trans_time=0 then let trans_time=fnstime_(time$)
51344 ! LET TRANS_DATE=DATE("CCYYMMDD") !:
          ! LET TRANS_TIME=FNSTIME_(TIME$) !:
          let stamp_recno=0 !:
          if trim$(changes_code$)<>"" then !:
            let stamp_recno=lrec(active_handle)+1
51346     let nchanges=nadded=nchanges_excluded=nadded_excluded=0
51348     for nfields=1 to udim(before_data$)
51350       if fnsql_value$(fieldsc$(nfields),uprc$(before_data$(nfields)))=fnsql_value$(fieldsc$(nfields),uprc$(after_data$(nfields))) then !:
              goto L51362
51352       let is_excluded=fnchanges_exclude(debtor_no,relation,trim$(uprc$(type$)),trim$(uprc$(table_name$)),trim$(uprc$(fieldsc$(nfields)))) !:
            if trim$(before_data$(nfields))="" then let nadded+=1 !:
              let nadded_excluded+=is_excluded
51354       if trim$(before_data$(nfields))="" and account=1 then goto L51362 else !:
              if trim$(before_data$(nfields))="" then goto L51358 !:
                ! ** Note: Do not Bother Recording Blank Data ON "New Claims" !:
                ! This is also true for EDI!
51356       let nchanges+=1 !:
            let nchanges_excluded+=is_excluded
51358 L51358: if ~fnchanges_exclude(debtor_no,relation,"X",trim$(uprc$(table_name$)),trim$(uprc$(fieldsc$(nfields)))) then !:
              write #changes_handle,using L51360: fileno$,trans_date,trans_time,debtor_no,relation,type$,table_name$,fieldsc$(nfields),fnsql_value$(fieldsc$(nfields),before_data$(nfields)),changes_code$,"D",user_id,stamp_recno
51360 L51360: form pos 1,c 8,2*bh 4,2*n 3,2*c 10,c 15,c 60,c 8,c 1,bh 2,bh 4
51362 L51362: next nfields
51364     for nfields=1 to udim(before_data)
51366       if fnsql_value(fieldsn$(nfields),before_data(nfields))=fnsql_value(fieldsn$(nfields),after_data(nfields)) then !:
              goto L51378
51368       let is_excluded=fnchanges_exclude(debtor_no,relation,trim$(uprc$(type$)),trim$(uprc$(table_name$)),trim$(uprc$(fieldsn$(nfields)))) !:
            if before_data(nfields)=0 then let nadded+=1 !:
              let nadded_excluded+=is_excluded !:
              ! ** Note: Do not Bother Recording Blank Data
51370       if before_data(nfields)=0 and account = 1 then goto L51378 else !:
              if before_data(nfields)=0 then goto L51374
51372       let nchanges+=1 !:
            let nchanges_excluded+=is_excluded
51374 L51374: let nvalue$=str$(fnsql_value(fieldsn$(nfields),before_data(nfields)))
51376       if ~fnchanges_exclude(debtor_no,relation,"X",trim$(uprc$(table_name$)),trim$(uprc$(fieldsn$(nfields)))) then !:
              write #changes_handle,using L51360: fileno$,trans_date,trans_time,debtor_no,relation,type$,table_name$,fieldsn$(nfields),nvalue$,changes_code$,"D",user_id,stamp_recno
51378 L51378: next nfields
51380     let nvalue$="" !:
          if nchanges-nchanges_excluded>=1 then let nvalue$=str$(nchanges)&" Fields Modified"
51382     if nadded-nadded_excluded>=1 then let nvalue$=trim$(nvalue$&" "&str$(nadded)&" Fields Added")
51384     if trim$(changes_code$)<>"" and nvalue$<>"" then !:
            let nvalue$=trim$(changes_desc$)&":"&trim$(nvalue$) !:
            write #active_handle,using L51386: fileno$,trans_date,trans_time,nvalue$(21:48),nvalue$(1:20),changes_code$,"D",user_id,0,stamp_recno,0,0
51386 L51386: form pos 1,c 8,2*bh 4,c 28,c 20,c 8,c 1,bh 2,2*bh 4,2*bh 4.2
51388 L51388: let fnchanges_=nchanges+nadded ! this function will return the number of changes (reported or not)
51389   fnend 
51390   def library fnschanges(setup_type$*10,setup_code$*10,table_name$*10,table_code$*10,mat before_data$,mat before_data,mat after_data$,mat after_data,mat fieldsc$,mat fieldsn$)
51392     let fnschanges=fn_schanges(setup_type$,setup_code$,table_name$,table_code$,mat before_data$,mat before_data,mat after_data$,mat after_data,mat fieldsc$,mat fieldsn$)
51394   fnend 
51400   def fn_schanges(setup_type$*10,setup_code$*10,table_name$*10,table_code$*10,mat before_data$,mat before_data,mat after_data$,mat after_data,mat fieldsc$,mat fieldsn$)
51402     let setup_type$=uprc$(setup_type$) !:
          let setup_code$=uprc$(setup_code$) !:
          let table_name$=uprc$(table_name$)
51404     if ~setup_schanges then 
51406       if ~setup_changes then let fnsetup_changes
51408       open #(schanges_handle:=fngethandle_): "Name=Schanges.Int//8,Kfname=SChanges.idx//8,shr",internal,outin,keyed 
51409       let schanges_user_id=fnget_user
51410     end if  ! setup_SChanges
51412     let trans_date=date("CCYYMMDD")
51414     let trans_time=fnstime_(time$)
51416     let nchanges=nadded=nchanges_excluded=nadded_excluded=0
51418     for nfields=1 to udim(before_data$)
51420       if fnsql_value$(fieldsc$(nfields),uprc$(before_data$(nfields)))<>fnsql_value$(fieldsc$(nfields),uprc$(after_data$(nfields))) then 
51422         write #schanges_handle,using SCHANGES_FORM: setup_type$,setup_code$,trans_date,trans_time,table_name$,table_code$,fieldsc$(nfields),fnsql_value$(fieldsc$(nfields),before_data$(nfields)),schanges_user_id
51424       end if 
51426 SCHANGES_FORM: form pos 1,2*c 10,2*bh 4,2*c 10,c 15,c 200,bh 2
51428     next nfields
51430     for nfields=1 to udim(before_data)
51432       if fnsql_value(fieldsn$(nfields),before_data(nfields))<>fnsql_value(fieldsn$(nfields),after_data(nfields)) then 
51434         let nvalue$=str$(fnsql_value(fieldsn$(nfields),before_data(nfields)))
51436         write #schanges_handle,using SCHANGES_FORM: setup_type$,setup_code$,trans_date,trans_time,table_name$,table_code$,fieldsn$(nfields),nvalue$,schanges_user_id
51438       end if 
51440     next nfields
51442   fnend 
51490   def library fnnav$
51495     if fkey=112 then let fnnav$="HOME" else !:
            if fkey=113 then let fnnav$="END" else !:
              if fkey=105 then let fnnav$="UP" else !:
                if fkey=106 then let fnnav$="DOWN" else !:
                  if fkey=124 then let fnnav$="SCROLL UP" else !:
                    if fkey=125 then let fnnav$="SCROLL DOWN"
51500   fnend 
51510   def fnsetup_changes
51512     let setup_changes=1
51514     dim changes_exclude$(1)*40,changes_key$*40
51516 ! NoChange.INI FIELDS !:
          ! DEBTOR - Dbt # or 0 For Claim !:
          ! RELATION - Rel Party Relation or 0 !:
          ! TYPE - Rel Party Type, blank or "X" to exclude this item from chages table!:
          ! TABLE - SQL Table Name!:
          ! FIELD - SQL Field Name
51518     if user_id=0 then let user_id=fnget_user
51520     let fnasci_("NOCHANGE.INI//8",mat changes_exclude$)
51522   fnend 
51530   def fnchanges_exclude(debtor,relation,type$,table$,field$)
51535     if trim$(type$)="X" then 
51540       let changes_key$=str$(debtor)&chr$(9)&str$(relation)&chr$(9)&type$&chr$(9)&table$&chr$(9)&field$ !:
            if srch(mat changes_exclude$,changes_key$)>0 then !:
              let fnchanges_exclude=1 : goto L51590 else !:
              goto L51590
51545     end if  ! Type$="X"
51550     let changes_key$=str$(debtor)&chr$(9)&str$(relation)&chr$(9)&type$&chr$(9)&table$&chr$(9)&field$ !:
          !:
          if srch(mat changes_exclude$,changes_key$)>0 then !:
            let fnchanges_exclude=1 : goto L51590
51555     let changes_key$=str$(debtor)&chr$(9)&str$(relation)&chr$(9)&""&chr$(9)&table$&chr$(9)&field$ !:
          if srch(mat changes_exclude$,changes_key$)>0 then !:
            let fnchanges_exclude=1 : goto L51590
51560     let changes_key$="###"&chr$(9)&"###"&chr$(9)&type$&chr$(9)&table$&chr$(9)&field$ !:
          if srch(mat changes_exclude$,changes_key$)>0 then !:
            let fnchanges_exclude=1 : goto L51590
51565     let changes_key$="###"&chr$(9)&"###"&chr$(9)&""&chr$(9)&table$&chr$(9)&field$ !:
          if srch(mat changes_exclude$,changes_key$)>0 then !:
            let fnchanges_exclude=1 : goto L51590
51570     let changes_key$="###"&chr$(9)&str$(relation)&chr$(9)&type$&chr$(9)&table$&chr$(9)&field$ !:
          if srch(mat changes_exclude$,changes_key$)>0 then !:
            let fnchanges_exclude=1 : goto L51590
51575     let changes_key$="###"&chr$(9)&str$(relation)&chr$(9)&""&chr$(9)&table$&chr$(9)&field$ !:
          if srch(mat changes_exclude$,changes_key$)>0 then !:
            let fnchanges_exclude=1 : goto L51590
51580     let changes_key$=str$(debtor)&chr$(9)&"###"&chr$(9)&type$&chr$(9)&table$&chr$(9)&field$ !:
          if srch(mat changes_exclude$,changes_key$)>0 then !:
            let fnchanges_exclude=1 : goto L51590
51585     let changes_key$=str$(debtor)&chr$(9)&"###"&chr$(9)&""&chr$(9)&table$&chr$(9)&field$ !:
          if srch(mat changes_exclude$,changes_key$)>0 then !:
            let fnchanges_exclude=1 : goto L51590
51590 L51590: fnend 
51600   def fnsql_value$*200(field$*20,value$*200)
51605     if pos(field$,"DATE")>0 then let fnsql_value$=fndate10_$(value$) !:
            goto L51615
51610     let fnsql_value$=trim$(value$)
51615 L51615: fnend 
51620   def fnsql_value(field$*20,value)
51625     if value=-20202 or abs(value)=20202.02 or abs(value)=2020202.02 or abs(value)=202020202.02 or value=2105376 or value=538976288 then !:
            let value=0
51630     let fnsql_value=value
51635   fnend 
51640   def library fnrms_icr$(prefix$)
51645     let rms_icr_handle=fngethandle_ !:
          open #rms_icr_handle: "NAME=RMS_ICR.INT//9,KFNAME=RMS_ICR.IDX//9,USE,KPS=1,KLN=2,SHR,recl=64",internal,outin,keyed 
51650     let rms_counter=0 !:
          read #rms_icr_handle,using L51655,key=rpad$(prefix$,2)(1:2): tpre_fix$,rms_counter nokey L51655 !:
          goto L51665
51655 L51655: form pos 1,c 10,bh 2
51660     let rms_counter=0 !:
          write #rms_icr_handle,using L51655: prefix$,rms_counter
51665 L51665: let rms_counter+=1 !:
          if rms_counter>(36*36)-1 then let rms_counter=1
51670     let digit1=int(rms_counter/36) !:
          let digit2=rms_counter-(digit1*36)
51675     let digit1$=digit2$="" !:
          if digit1<=9 then let digit1$=str$(digit1) else !:
            let digit1$=chr$(digit1+55)
51680     if digit2<=9 then let digit2$=str$(digit2) else !:
            let digit2$=chr$(digit2+55)
51685     let fnrms_icr$=prefix$&digit1$&digit2$
51690     rewrite #rms_icr_handle,using L51655,key=rpad$(prefix$,2)(1:2): prefix$,rms_counter
51695     close #rms_icr_handle: 
51700   fnend 
51710   def library fnnj_acs$(prefix$)
51715     let nj_acs_handle=fngethandle_ !:
          open #nj_acs_handle: "NAME=NJ_ACS.INT//9,KFNAME=NJ_ACS.IDX//9,USE,KPS=1,KLN=10,SHR,recl=64",internal,outin,keyed 
51720     let nj_acs_counter=0 !:
          read #nj_acs_handle,using L51725,key=rpad$(prefix$,10)(1:10): tpre_fix$,nj_acs_counter nokey L51725 !:
          goto L51735
51725 L51725: form pos 1,c 10,bh 4
51730     let nj_acs_counter=0 !:
          write #nj_acs_handle,using L51725: prefix$,nj_acs_counter
51735 L51735: let nj_acs_counter+=1 !:
          if nj_acs_counter>(16777216)-1 then let nj_acs_counter=1
51740     open #(nj_acs_io:=fngethandle_): "SCOL=23,SROW=10,COLS=35,ROWS=2,TAB=NJACS Sequence #,Border=S",display,outin  !:
          print #nj_acs_io: newpage
51745 L51745: print #nj_acs_io,fields "2,1,CR 20": "Next Value:" !:
          rinput #nj_acs_io,fields "2,21,N 10,[D]SAE",attr '[A]': nj_acs_counter conv L51745
51750     close #nj_acs_io: 
51755     let fnnj_acs$=str$(nj_acs_counter)
51760     rewrite #nj_acs_handle,using L51725,key=rpad$(prefix$,10)(1:10): prefix$,nj_acs_counter
51765     close #nj_acs_handle: 
51770   fnend 
51780   def library fnedi_counter$(prefix$)
51785     let edi_counter_handle=fngethandle_ !:
          open #edi_counter_handle: "NAME=EDICOUNT.INT//9,KFNAME=EDICOUNT.IDX//9,USE,KPS=1,KLN=10,SHR,recl=64",internal,outin,keyed 
51790     let edi_counter_counter=0 !:
          read #edi_counter_handle,using L51795,key=rpad$(prefix$,10)(1:10): tpre_fix$,edi_counter_counter nokey L51795 !:
          goto L51805
51795 L51795: form pos 1,c 10,bh 4
51800     let edi_counter_counter=0 !:
          write #edi_counter_handle,using L51795: prefix$,edi_counter_counter
51805 L51805: let edi_counter_counter+=1 !:
          if edi_counter_counter>(16777216)-1 then let edi_counter_counter=1
51810     open #(edi_counter_io:=fngethandle_): "SCOL=30,SROW=10,COLS=35,ROWS=2,TAB=Sequence #,Border=S",display,outin  !:
          print #edi_counter_io: newpage
51815 L51815: print #edi_counter_io,fields "2,1,CR 20": "Next Value:" !:
          rinput #edi_counter_io,fields "2,21,N 10,[D]SAE",attr '[A]': edi_counter_counter conv L51815
51820     close #edi_counter_io: 
51825     let fnedi_counter$=str$(edi_counter_counter)
51830     rewrite #edi_counter_handle,using L51795,key=rpad$(prefix$,10)(1:10): prefix$,edi_counter_counter
51835     close #edi_counter_handle: 
51840   fnend 
51850   def library fnget_fonts(mat fonts$)
51852     let fnget_fonts=fngetfonts(mat fonts$)
51854   fnend 
51860   def fngetfonts(mat fonts$)
51865     mat fonts$(0)=("") !:
          let fonts=0
51870     execute "*STATUS FONTS >[Temp]ST-[Session].txt"
51875     let nworkfile=fngethandle_ !:
          open #nworkfile: "NAME=[Temp]ST-[Session].txt",display,input 
51880 L51880: linput #nworkfile: buff$ eof L51910
51885     if pos(buff$,"ACTIVE     END")<=0 or pos(uprc$(buff$),"CLSUTIL")<=0 then goto L51880
51890 L51890: linput #nworkfile: buff$ eof L51910
51895     if pos(buff$,"LOADED     END")>0 then goto L51890
51900     let fonts+=1 !:
          mat fonts$(fonts) !:
          let fonts$(fonts)=uprc$(trim$(buff$))
51905     goto L51890
51910 L51910: close #nworkfile: 
51915     let fngetfonts=fonts
51920   fnend 
51930   def library fnpick_fonts$*99(;current_font$*99)
51935     dim pick_fonts$(1)*80
51940     let fngetfonts(mat pick_fonts$)
51945     let pick_font=fnwinscroll_(mat pick_fonts$,1,"TITLE=Select Desired FONT HEADING=FONT")
51950     let fnpick_fonts$=pick_fonts$(pick_font)
51955   fnend 
51960 ! STAMP_TRANS_TIME,STAMP_TRANS_DATE,STAMP_RECNO
51965   def library fnget_stamp_info(&_stamp_trans_time,&_stamp_trans_date,&_stamp_recno)
51970     let _stamp_trans_time=stamp_trans_time !:
          let _stamp_trans_date=stamp_trans_date !:
          let _stamp_recno=stamp_recno
51975   fnend 
51980 ! The local DEF FNGETVAR$ function was removed !:
        ! Performing "EXE" Statements in the middle of CLSUTIL to assign variables (As FNGETVAR$ does) causes memory Instability.!:
        ! Enhance SETUP_SQL with "Hard Coded SRCH" names instead of using the PROC!:
        ! Please to not create a local FNGETVAR$ to prevent this problem again as it may cause BR to GPF
51985   def library fnget_var$*128(unq$, mat fieldsc$, mat fieldsn$)
51990 ! UNQ$ - Unique File Identifier ... ie Master, or Bank, or whatever - no spaces, this will be a part of a variable name, so keep it short, because your gonna be reusing it alot!
51995 ! these two arrays should be built by fnGet_FormArr and passed to this function
52000 ! mat FIELDSC$ - This array will contain the names of the string fields contained in the file record.
52005 ! mat FIELDSN$ - This array will contain the names of the numeric fields contained in the file record.
52010     dim outline$*850
52015     let maxlinelength=575 : let procfilelinelen=maxlinelength+50
52020     open #procfile:=fngethandle_: "Name=[wbwork]Proc-"&session$&".$$$,RecL="&str$(procfilelinelen)&",Size=0,Replace",display,output 
52025     for j=1 to udim(fieldsc$)+1
52030       if len(outline$)>maxlinelength or j>udim(fieldsc$) then !:
              print #procfile: outline$(2:len(outline$)) : let outline$=""
52035       if j<=udim(fieldsc$) then !:
              let outline$(9999:0)=":Let "&unq$&"_"&srep$(srep$(fieldsc$(j),"#",""),'&','_')&"="&str$(j)
52040     next j
52045 ! if OUTLINE$<>"" THEN !:
          !  LET OUTLINE$=OUTLINE$(2:LEN(OUTLINE$)) !:
          !   PRINT #PROCFILE: OUTLINE$ !:
          !    LET OUTLINE$=""
52050     for j=1 to udim(fieldsn$)+1
52055       if len(outline$)>maxlinelength or j>udim(fieldsn$) then !:
              print #procfile: outline$(2:len(outline$)) : let outline$=""
52060       if j<=udim(fieldsn$) then !:
              let outline$(9999:0)=":Let "&unq$&"_"&srep$(srep$(fieldsn$(j),"#",""),'&','_')&"="&str$(j)
52065     next j
52070 ! if OUTLINE$<>"" THEN !:
          !  LET OUTLINE$=OUTLINE$(2:LEN(OUTLINE$)) !:
          !   PRINT #PROCFILE: OUTLINE$ !:
          !    LET OUTLINE$=""
52075     let fnget_var$="*"&file$(procfile)
52080     close #procfile: 
52085   fnend 
52090   def fnmappedmsgbox(message$*2048, type, title$*200)
52095 ! function returns a -999 if it was a bad call or -998 if env$("debug")='yes'
52100     let set_fnmappedmsgbox=0
52105     if uprc$(env$("Debug"))="YES" then let set_fnmappedmsgbox=-998 : goto XIT_FNMAPPEDMSGBOX
52110     dim nval$*80
52115     let nval$=(lpad$(fndec2bin_$(type),10,"0")) !:
          let message$=srep$(message$,"\n",chr$(10))
52120     let symbol$="??" !:
          let nlen=len(nval$)
52125     if nval$(nlen-6:nlen-4)="011" then let symbol$="EXCL" else !:
            if nval$(nlen-6:nlen-4)="001" then let symbol$="ERR" else !:
              if nval$(nlen-6:nlen-4)="010" then let symbol$="QST" else !:
                if nval$(nlen-6:nlen-4)="100" then let symbol$="INF" else !:
                  let symbol$="xxx"
52130     let boxtype$="??" !:
          if nval$(nlen-2:nlen)="000" then let boxtype$="ok" else !:
            if nval$(nlen-2:nlen)="001" then let boxtype$="okc" else !:
              if nval$(nlen-2:nlen)="010" then let boxtype$="xxx" else !:
                if nval$(nlen-2:nlen)="011" then let boxtype$="ync" else !:
                  if nval$(nlen-2:nlen)="100" then let boxtype$="yn" else !:
                    let boxtype$="xxx"
52135     let default=1 !:
          if nval$(nlen-8:nlen-8)="1" then let default=2 else !:
            if nval$(nlen-9:nlen-9)="1" then let default=3
52140     let tresult=-999 !:
          let boxtype$(default:default)=uprc$(boxtype$(default:default)) !:
          if default<>1 and uprc$(boxtype$(default:default))<>"N" then !:
            goto L52150
52145     let tresult=msgbox(message$,title$,boxtype$,symbol$) error L52150
52150 L52150: if tresult = 1 then let set_fnmappedmsgbox = 1 else !:
            if tresult = 2 then let set_fnmappedmsgbox = 6 else !:
              if tresult = 3 then let set_fnmappedmsgbox = 7 else !:
                if tresult = 4 then let set_fnmappedmsgbox = 2 else !:
                  let set_fnmappedmsgbox = -999
52155 XIT_FNMAPPEDMSGBOX: ! 
52160     let fnmappedmsgbox=set_fnmappedmsgbox
52165   fnend 
52170 !
52172   def library fnmake_dir(indir$*256) !:
          let fnmake_dir=fn_make_dir(indir$) !:
        fnend 
52180   def fn_make_dir(indir$*256)
52185 ! returns a 0 if directory is already there !:
          ! 1 if creation is sucessful !:
          ! or -Error Value if there was an error !:
          ! -10001 = Drive doesn't exist.
52190 ! ACCEPTABLE PATH PATERNS:  X:\DIR\DIR\   DIR\DIR   \\SERVER\RESOURCE\DIR\DIR   \\SERVER\RESOURCE\DIR\DIR\ !:
          ! QUESTIONABLE (NON-TESTED) PATERNS: X:DIR !:
          ! WON'T WORK PATERNS: *\Filename
52195     dim goodpath$*256,md_drive$*256
52200     dim testdir$*244 ! Windows XP directory name limit
52205     let indir$=trim$(indir$)
52210     let md_drive$="" : let md_len=0 !:
          if indir$(1:3)="@::" and indir$(5:5)=":" then !:
            let md_drive$=indir$(1:5) : let md_len=6 else !:
            if indir$(2:2)=":" then !:
              let md_drive$=indir$(1:2) : let md_len=3
52215     let goodpath$=''
52220     if exists(indir$)<>0 then let fn_make_dir=0 : goto MD_XIT ! already there
52225 !                 PRINT INDIR$ : PAUSE  ! XXX
52230     if indir$(len(indir$):len(indir$))="\" then let indir$=indir$(1:len(indir$)-1) !:
            ! remove any \ on the end
52235     if trim$(md_drive$)<>"" and exists(md_drive$)<>0 then 
52240       let goodpath$=md_drive$ : let indir$=indir$(md_len:len(indir$))
52245     else if trim$(md_drive$)<>"" and exists(md_drive$)=0 then 
52250       let fn_make_dir=-10001 : goto MD_XIT
52255     else if indir$(1:2)="\\" and exists(indir$(1:pos(indir$,"\",pos(indir$,"\",3)+1))) then 
52260       let goodpath$=indir$(1:pos(indir$,"\",pos(indir$,"\",3)+1)) : let indir$(1:pos(indir$,"\",pos(indir$,"\",3)+1))=""
52265     end if 
52270     do while len(indir$)>0
52275       if indir$(1:1)="\" then let indir$(1:1)="" : let goodpath$(9999:0)="\"
52280       let testpos=pos(indir$,"\")
52285       if testpos=0 then let testpos=len(indir$)
52290       let testdir$=indir$(1:testpos)
52295       if exists(goodpath$&testdir$)=0 then 
52300         let testdir$=srep$(testdir$,"[SESSION]",session$) !:
              let testdir$=srep$(testdir$,"[WSID]",wsid$)
52305         execute 'MkDir "'&goodpath$&testdir$&'"' ioerr MD_ERROR
52310         let fn_make_dir=1
52315       end if 
52320       let goodpath$(9999:0)=testdir$ : let indir$=indir$(testpos+1:len(indir$))
52325 EOLOOP1: ! 
52330     loop 
52335     goto MD_XIT
52340 MD_ERROR: ! 
52345     let fn_make_dir=-err
52350     goto MD_XIT
52355 MD_XIT: ! 
52360   fnend 
52370 !
52375   def library fnfix_fileno$(fileno$*24) !:
          let fnfix_fileno$=fnfixfileno$(fileno$) !:
        fnend 
52380   def fnfixfileno$(fileno$*24) !:
          let fileno$=srep$(fileno$,".","_") !:
          let fileno$=srep$(fileno$,",","-") !:
          let fnfixfileno$=uprc$(trim$(fileno$)) !:
        fnend 
52390 !
52392   def library fnreport_path$*128 !:
          if ~cls_setup then let fnclssetup
52394     let fnreport_path$=report_path$
52396   fnend 
52400   def library fnclaim_path$*128(claimnumber$*24; create)
52402 ! CREATE = 0 (DEFAULT) JUST RETURN THE PATH !:
          ! CREATE = 1 RETURN THE PATH, AND CREATE if MISSING
52404     let fnclaim_path$=fnclaimpath$(claimnumber$, create)
52406   fnend 
52410   def fnclaimpath$*128(&claimnumber$; create)
52412     if ~cls_setup then let fnclssetup
52414     dim tempclaimpath$*128
52416     let claimnumber$=fnfixfileno$(claimnumber$)
52418     let tempclaimpath$=report_path$&claimnumber$(1:3)&"\"&claimnumber$&"\"
52420     if create=0 then !:
            let fnclaimpath$=tempclaimpath$ : goto XITFNCLAIMPATH
52422     if fn_make_dir(tempclaimpath$)=>0 then 
52424       let fnclaimpath$=tempclaimpath$
52426     else 
52428       let fnclaimpath$=""
52430     end if 
52432 XITFNCLAIMPATH: fnend 
52440 !
52442   def library fnget_claimfiles(cn$*24, mat gcffiles$, mat gcfdate$, mat gcfsize; filter$*80) !:
          let fnget_claimfiles=fngetclaimfiles(cn$, mat gcffiles$, mat gcfdate$, mat gcfsize, filter$) !:
        fnend 
52450   def fngetclaimfiles(claimnumber$*24, mat gcffiles$, mat gcfdate$, mat gcfsize; filter$*80)
52455 ! claimnumber$ = claim number you want files for !:
          ! mat GCFFiles$ = returns the files your looking for !:
          ! filter$ = (optional) a semi-colon delimited list of file types you want to include, if not use it'll default to all associated files.  Example: "txt;jpg;gif" or "rpt"  Note: this is not case sensitive)
52460 ! 
52465     if ~cls_setup then let fnclssetup
52470     dim type$(1),skipper$(1)*128
52475     dim claimpath$*128
52480     let claimnumber$=lwrc$(fnfixfileno$(claimnumber$))
52485     if filter$<>"" then let fnparse_csv_(filter$, mat keeper$,";")
52490     let fnasci_("Trans_U\CPE_Skip.ini",mat skipper$)
52495     mat gcffiles$(0) : mat gcfdate$(0) : mat gcfsize(0) ! mat gcffiles$(1)=("") : mat gcfdate$(1)=("") : mat gcfsize(1)=(0)
52500     let gcfilecount=0 ! counter for GCFFiles$
52505     let fngetdir(claimpath$=fnclaimpath$(claimnumber$,1), mat dirs$, mat files$, mat size, mat dait$,"B")
52510     for j=1 to udim(files$)
52515 ! if files$(j)<>'' then
52520       let ext$=lwrc$(files$(j)(pos(files$(j),".",-1)+1:len(files$(j))))
52525       let keepit=0 ! 0 means don't return it - 1 means do return it
52530       if filter$="" then 
52535         let keepit=1
52540       else 
52545         for j2=1 to udim(keeper$)
52550           if ext$=lwrc$(keeper$(j2)) then let keepit=1
52555         next j2
52560       end if 
52565       if srch(mat skipper$,uprc$(files$(j)))>0 then let keepit=0
52570       if srch(mat skipper$,"*."&uprc$(ext$))>0 or ~exists(claimpath$&files$(j)) then let keepit=0
52575       if keepit=1 and files$(j)<>"" then 
52580         if (gcfilecount+=1)>udim(gcffiles$) then !:
                mat gcffiles$(gcfilecount) !:
                mat gcfdate$(gcfilecount) !:
                mat gcfsize(gcfilecount)
52585         let gcffiles$(gcfilecount)=claimpath$&files$(j) !:
              let gcfdate$(gcfilecount)=dait$(j) !:
              let gcfsize(gcfilecount)=size(j)
52590       end if 
52595 ! end if
52600     next j
52605     let fngetdir(report_path$&claimnumber$&".RPT", mat dirs$, mat files$, mat size, mat dait$,"Y")
52610     for j=1 to udim(files$)
52615       let ext$=lwrc$(files$(j)(pos(files$(j),".",-1)+1:len(files$(j)))) !:
            let keepit=0 ! 0 means don't return it - 1 means do return it
52620       if filter$="" then 
52625         let keepit=1
52630       else 
52635         for j2=1 to udim(keeper$)
52640           if ext$=lwrc$(keeper$(j2)) then let keepit=1
52645         next j2
52650       end if 
52655       if lwrc$(files$(j)(1:pos(files$(j),".",-1)-1))<>lwrc$(claimnumber$) then let keepit=0
52660       if srch(mat skipper$,files$(j))>0 then let keepit=0
52665       if srch(mat skipper$,"*."&uprc$(ext$))>0 then let keepit=0
52670       if ~exists(report_path$&files$(j)) then let keepit=0
52675       if keepit=1 then 
52680         if (gcfilecount+=1)>udim(gcffiles$) then !:
                mat gcffiles$(gcfilecount) !:
                mat gcfdate$(gcfilecount) !:
                mat gcfsize(gcfilecount)
52685         let gcffiles$(gcfilecount)=report_path$&files$(j) !:
              let gcfdate$(gcfilecount)=dait$(j) !:
              let gcfsize(gcfilecount)=size(j)
52690       end if 
52695     next j
52700 ! 
52705   fnend  ! fngetclaimfiles
52710 !
52712   def library fnclaim_scroll(mat gcffile$, mat gcffdate$, mat gcfsize) !:
          let fnclaim_scroll=fnclaimscroll(mat gcffile$, mat gcffdate$, mat gcfsize) !:
        fnend 
52720   def fnclaimscroll(mat gcffile$, mat gcffdate$, mat gcfsize)
52722     dim scroll_data$(1)*256
52724     mat scroll_data$(udim(gcffile$))
52726     for j=1 to udim(gcffile$)
52728       let scroll_data$(j)=rpad$(fninitcap$(gcffile$(j)(pos(gcffile$(j),"\",-1)+1:len(gcffile$(j)))),55) !:
            let scroll_data$(j)(9999:0)=""&gcffdate$(j)&""
52730       if gcfsize(j)<100000000000 then !:
              let scroll_data$(j)(9999:0)=lpad$(str$(gcfsize(j)),11) !:
            else !:
              let scroll_data$(j)(9999:0)="*Over 99GB*"
52732     next j
52734     let fnclaimscroll=fnwinscroll_(mat scroll_data$, 0, "Title=Document Selection HEADING=Name;Last Modified;Size", "", "", 0, 0,0,0) ! , "", FOOTER$="", 2, 2,0,15)
52736   fnend 
52740 !
52742   def library fnput_reportpath(setit$*40)
52744     let setit$=trim$(setit$)
52746     open #equifax_setup:=fngethandle_: "NAME=SETUP.EFX/EQUIFAX,SHR",internal,outin,relative 
52748     if setit$(len(setit$):len(setit$))<>"\" then !:
            let setit$(9999:0)="\"
52750     rewrite #equifax_setup,using L13390,rec=1: setit$
52752     close #equifax_setup: 
52754   fnend 
52760 ! ____________________fnReportName$(FileName$)__________________________
52762   def fnreportname$*128(filename$*256)
52764     dim tmpreportname$*128
52766     let tmpreportname$=""
52768     open #reportfile:=fngethandle_: "Name="&filename$,display,input ioerr REPORTNAME_XIT
52770     linput #reportfile: width$ ! not used, just consumed !:
          linput #reportfile: buff$
52772     close #reportfile: 
52774     let tmpreportname$=fninitcap$(trim$(buff$))
52776 ! 
52778 REPORTNAME_XIT: ! 
52780     let fnreportname$=tmpreportname$
52782   fnend 
52790   def library fnreport_name$*128(filename$*256)
52792     let fnreport_name$=fnreportname$(filename$)
52794   fnend 
52796 ! ____________________fnItem$(Item)____________________________________
52798   def library fnmitem$(item; mi_style)
52800     let fnmitem$=fnmitem_$(item, mi_style)
52802   fnend 
52810   def fnmitem_$(item; mi_style)
52812     if mi_style=0 then 
52814       if item<=9 then 
52816         let fnmitem_$=cnvrt$('PIC(--)',item)
52818       else 
52820         let fnmitem_$=lpad$(chr$(100-item),2)
52822       end if  ! Item<=9   /   else 
52824     else if mi_style=>1 then 
52826       let fnmitem_$=lpad$(str$(item),mi_style)
52828     end if  ! mi_style=0   /   =>1
52830   fnend  ! Fnmitem_$
52840 ! ____________________fnGet_Report$___________________________________
52845   def library fnget_report$*99(rpt_filter$,&rpt_name$,mat xlt_from$,mat xlt_to$, mat menu_item$; &pk$, title$*80, footer$*80, noask)
52850 ! remember to always use a if FKEY=99 THEN GOTO XIT after this function is called.
52855 ! RPT_FILTER$ = Finds all files in ReportDir$, with this filter*.rpt, overridden by files in the CustomReportDir$ with the same name
52860 !               (Collsum is special - it returns all CollSum* and ColSum* files) !:
          !               (SysStat is special too)
52865 !  Then the User Picks from these Reports !:
          !   the rest of the values are determined and returned
52870 ! NoAsk       = if >0 then it doesn't ask and returns the value of NoAsk in the function rather than a selected answer
52875     dim reportdir$*128, customreportdir$*128, keeper$(1)*128
52880     dim filename$*128 ! , MENU_ITEM$(1)*128
52885     let reportdir$="Reports\"
52890     let customreportdir$="CustRpt\" !:
          let fn_make_dir(customreportdir$) ! removing this line may speed things up... but function may fail if CustomReportDir does not exist.
52895     let rpt_filter$=lwrc$(trim$(rpt_filter$)) !:
          if rpt_filter$="collsum" then let rpt_filter$="colsum" : let name_filter$="col" else !:
            if rpt_filter$="sysstat" then let rpt_filter$="systat" : let name_filter$="sys"
52900     if rpt_filter$="colsum" then let name_filter$="col*.rpt" else !:
            if rpt_filter$="systat" then let name_filter$="sys*.rpt" else !:
              let name_filter$=rpt_filter$&"*.rpt"
52905     let dotpos=pos(rpt_filter$,".",-1)
52910     if dotpos>1 then let favoredext$=lwrc$(rpt_filter$(dotpos+1:len(rpt_filter$))) : let rpt_filter$=rpt_filter$(1:dotpos-1) else let favoredext$="rpt"
52915     let fngetdir(reportdir$&name_filter$, mat dirs$, mat files$, mat size, mat dait$,"Y")
52920     let kfc=0 ! Kentucy Fried Chicken - j/k it's Keeper File Counter
52925     for filecount=1 to udim(files$)
52930       let ext$=lwrc$(files$(filecount)(pos(files$(filecount),".",-1)+1:len(files$(filecount)))) !:
            let filename$=files$(filecount)(1:pos(files$(filecount),".",-1)+1) !:
            let keepit=0
52935       if rpt_filter$=lwrc$(files$(filecount)(1:len(rpt_filter$))) then 
52940         let keepit=1
52945       else 
52950         if rpt_filter$="colsum" and lwrc$(filename$(1:7))="collsum" then let keepit=1 else !:
                if rpt_filter$="systat" and lwrc$(filename$(1:7))="sysstat" then let keepit=1
52955       end if 
52960       if ext$<>favoredext$ then let keepit=0
52965       if keepit=1 then !:
              mat keeper$(kfc+=1) !:
              let keeper$(kfc)=reportdir$&files$(filecount)
52970     next filecount
52975     let filedircount=fngetdir(customreportdir$&name_filter$, mat dirs$, mat files$, mat size, mat dait$,"Y")
52980 ! PAUSE  ! XXX
52985     if filedircount=>1 then 
52990       for filecount=1 to udim(files$)
52995         let ext$=lwrc$(files$(filecount)(pos(files$(filecount),".",-1)+1:len(files$(filecount)))) !:
              let filename$=files$(filecount)(1:pos(files$(filecount),".",-1)+1) !:
              let keepit=0
53000         if rpt_filter$=lwrc$(files$(filecount)(1:len(rpt_filter$))) then 
53005           let keepit=1
53010         else 
53015           if rpt_filter$="colsum" and lwrc$(filename$(1:7))="collsum" then let keepit=1 else !:
                  if rpt_filter$="systat" and lwrc$(filename$(1:7))="sysstat" then let keepit=1
53020         end if 
53025         if ext$<>"rpt" then let keepit=0
53030         if keepit=1 then 
53035           let alreadythere=srch(mat keeper$,reportdir$&files$(filecount))
53040           if alreadythere<=0 then 
53045             mat keeper$(kfc+=1) !:
                  let keeper$(kfc)=customreportdir$&files$(filecount)
53050           else 
53055             let keeper$(alreadythere)=customreportdir$&files$(filecount)
53060           end if 
53065         end if 
53070       next filecount
53075       mat keeper$(kfc)
53080     end if 
53085 ! 
53090     mat menu_item$(kfc)
53095     if kfc=0 then let fkey(99) : goto XIT_FNGET_REPORT
53100     for filecount=1 to udim(keeper$)
53105       let menu_item$(filecount)=fnreportname$(keeper$(filecount))
53110       if uprc$(env$("Debug"))="YES" then 
53115         let menu_item$(filecount)=rpad$(menu_item$(filecount),78)
53120         let menu_item$(filecount)(78-(len(keeper$(filecount))+1+2):78)=''&keeper$(filecount)
53125       end if  ! UprC$(env$("Debug"))="YES"
53130     next filecount
53135     if noask<=0 then !:
            let menuselection=fnmenu_("Select Report File",mat menu_item$, pk$,title$, footer$,2,1) !:
          else let menuselection=noask !:
            ! ** FNMENU should not mess with the screen
53140     if rpt_filter$="colsum" then let rpt_filter$="collsum" else !:
            if rpt_filter$="systat" then let rpt_filter$="sysstat"
53145     let fnxlatetable(rpt_filter$,mat xlt_from$,mat xlt_to$)
53150     if menuselection<=udim(menu_item$) then !:
            let rpt_name$=menu_item$(menuselection) !:
            let fnget_report$=keeper$(menuselection) else !:
            let rpt_name$="" !:
            let fnget_report$=""
53155     let noask=0
53160 XIT_FNGET_REPORT: ! 
53165   fnend 
53170   def library fnmenu(cap$*80,mat selmenu$; &pk$, title$*80, footer$*80, nnp, autonumber,mstart,mat custom_menubar$, mat custom_menuprg$, mat custom_menustatus$,&menu_startup$,menu_offset,m_timeout,m_trust$*30,m_f93_enable)
53172     if ~setup_library then gosub SETUP_LIBRARY
53174     if ~setup_constants then gosub SETUP_CONSTANTS
53176     let fnmenu=fnmenu_(cap$,mat selmenu$,pk$,title$,footer$,nnp,autonumber,mstart,mat custom_menubar$, mat custom_menuprg$, mat custom_menustatus$,menu_startup$,menu_offset,m_timeout,m_trust$,m_f93_enable)
53178   fnend 
53180   def fnmenu_(cap$*80,mat selmenu$; &pk$,title$*80, footer$*80, nnp, autonumber,default_selection, mat custom_menubar$, mat custom_menuprg$, mat custom_menustatus$,&menu_startup$,menu_offset,m_timeout,m_trust$*30,m_f93_enable)
53185 ! Cap$ = BR Window Caption !:
          ! mat SelMenu$ = Selections that the user will pick from !:
          ! PK$ = Path of Keys - Keyboard path used to get here and past
53190 ! Title$ = Top message in "1,1,CC 80,[S]"  !:
          ! Footer$ = Bottom message titlebar in "24,1,CC 80,[S]" !:
          ! NNP = No NewPage = 1 Don't print a NewPage !:
          !     = 2 Don't Print a NewPage, but use fnMenu2 anyway !:
          ! AutoNumber = 1 = Add Numbers/Letters to the beginning of each Menu Item
53195 ! mstart = sets the default (highlited) selection !:
          ! mat Custom_MenuBar$, mat Custom_MenuPrg$, mat Custom_MenuStatus$ - if you want a custom drop down menu than use this !:
          ! Menu_Startup$ = @5-2 or -5-2 or 5 - it'll auto-pick the first number/letter and remove it from Menu_Startup$
53200 ! M_Timeout     = Timeout after this many number of seconds (0=disable) - returns with fkey 101 and -10101 !:
          ! M_Trust$*30   = Trust Account to display along with the other fndisplay_top information !:
          ! m_F93_enable  = 0 disables f93, f93 returns as f99, 1 enables f93, thus returning f93 as f93 (the calling program must handle this)
53205     if ~setup_m1 then 
53210       dim _menubar$(1)*100,_menuprg$(1)*80,_menustatus$(1)*80,pk_original$*80
53215       let setup_m1=1
53220       if user_init$="" then let user_init$=fnuserinit$
53225       let true=yes=1 : let false=no=0
53230       let policy_gui_menu=fnsecurity_("GUI:MENU",'',0,user_init$,inquiry_only:=1) : if policy_gui_menu=-1 then let policy_gui_menu=0
53235       let policy_gui_menu_help=0 ! let Policy_Gui_Menu_Help=Fnsecurity_("GUI:MENU.HELP",'',0,User_Init$,Inquiry_Only:=1) : if Policy_Gui_Menu_Help=-1 then let Policy_Gui_Menu_Help=0
53240     end if  ! ~Setup_M1
53245     if policy_gui_menu and nnp<>1 and env$("GUIMode")="ON" then let g_use_fnmenu2=1 else let g_use_fnmenu2=0
53250     let pk$=srep$(pk$,"---","-") !:
          let pk$=srep$(pk$,"--","-") !:
          let pk_original$=trim$(pk$)
53255 ! if udim(Mat Custom_Menubar$)=10 and Custom_Menubar$(1)='' then !:
          ! mat Custom_Menubar$(0) !:
          ! mat Custom_Menuprg$(0) !:
          ! mat Custom_Menustatus$(0)
53260     let maxmenuheight=22
53265     let menu_curfld=0
53270     if trim$(title$)<>"" then let maxmenuheight-=1
53275     if trim$(footer$)<>"" then let maxmenuheight-=1
53280     if udim(custom_menubar$)=0 or trim$(custom_menubar$(1))="" then let use_custom_menu=no else let use_custom_menu=yes
53285     if ~g_use_fnmenu2 and nnp=0 and fkey<>101 then 
53290       if trim$(title$)='' then 
53295         let fndisplaytop(cap$,fnpk_cleanup$(pk$),0,m_trust$)
53300       else 
53305         let fndisplaytop(title$,fnpk_cleanup$(pk$),0,m_trust$)
53310       end if  ! Title$=''   /   else 
53315     end if  ! ~G_Use_Fnmenu2
53320     let cap$=srep$(cap$,',',';') !:
          ! ** , is "Illegal for Captions" !:
          ! Replaced with a ";" for "Closest match"
53325     if autonumber=1 then let fn_menu_autonumber(mat selmenu$)
53330     if ~g_use_fnmenu2 then let fnmenu_lowercase_enforcer(mat selmenu$)
53335     let pk$=trim$(pk$) !:
          if pk$<>"" and trim$(pk$)<>"BLANK" then !:
            let cap$=trim$(cap$)&" ["&trim$(pk$,"-")&"]" else let cap$=trim$(cap$) !:
            ! ** Do not add a path of "BLANK" to the caption name! This causes problems
53340     if udim(selmenu$)<=1 then let setfnmenu=1 : goto MENU_DONE
53345 ! *
53350     let menu_startup$=srep$(menu_startup$,"@","-") !:
          let menu_startup$=trim$(menu_startup$,"-")
53355     if menu_startup$<>"" then 
53360       let menu_startup$=trim$(menu_startup$,"-")&"-" ! add an extra - to end, in case there is none !:
            let menu_startup_choice$=menu_startup$(1:pos(menu_startup$,"-")-1)
53365       let setfnmenu=fnmenu_val(menu_startup_choice$)
53370       if setfnmenu>udim(mat selmenu$) then let fnmessagebox_("Option "&pk$&menu_startup_choice$&" is not available.",mb_stop+mb_okonly,cap$) : let setfnmenu=0 : let fkey(99) : let menu_startup$='' : goto MENU_REASK
53375       let menu_startup$(1:pos(menu_startup$,"-"))=''
53380       goto MENU_DONE
53385     end if 
53390 MENU_REASK: ! *
53395     if g_use_fnmenu2 then !:
            goto MENU_RINPUTSELECT !:
          else if udim(selmenu$)>maxmenuheight then !:
            goto MENU_WINSCROLL !:
          else !:
            goto MENU_RINPUTSELECT
53400 MENU_RINPUTSELECT: ! 
53405   if rtrm$(footer$)<>"" and ~g_use_fnmenu2 then !:
          print fields "24,1,cc 80,[S]": footer$ : let footer$=""
53410   if policy_gui_menu_help and fkey<>101 and ~g_use_fnmenu2 then 
53415     open #m_help_win_handle:=fngethandle_: "SRow=2,SCol=78,Rows=1,Cols=2,Border=None",display,output  !:
          if env$("GUIMode")="ON" then !:
            print #m_help_win_handle,fields '1,1,P 1/2,[Toolbar],B8001': 'Icons\Help.png' !:
          else !:
            print #m_help_win_handle,fields '1,1,Cc 2,[Toolbar],B8001': '?'
53420   end if  ! Policy_Gui_Menu_Help
53425   let menu_item_count=udim(selmenu$)
53430 ! Prepare Automatic Drop-Down Menus (if no custom_menu specified)
53435   if ~use_custom_menu then 
53440     mat _menubar$(menu_item_count+1) !:
          mat _menuprg$(menu_item_count+1) !:
          mat _menustatus$(menu_item_count+1)=("E") !:
          let _menustatus$(1)="" !:
          let _menubar$(1)="&"&cap$
53445   end if 
53450   let max_menuitem_len=0 !:
        for z=1 to menu_item_count
53455     let selmenu$(z)=trim$(selmenu$(z))(1:78)
53460     let max_menuitem_len=max(max_menuitem_len,len(selmenu$(z)))
53465   next z !:
        let max_menuitem_len=max(1,max_menuitem_len)
53470   if max_menuitem_len<len(cap$) then let max_menuitem_len=len(cap$)
53475   if ~g_use_fnmenu2 then 
53480     let srow=13-int(menu_item_count/2)+menu_offset : let erow=13+int(menu_item_count/2)+menu_offset !:
          if menu_item_count/2=int(menu_item_count/2) then let erow-=1
53485     if udim(selmenu$)<maxmenuheight-1 then let erow=erow-1 : let srow=srow-1
53490     if udim(selmenu$)=maxmenuheight then let srow=2 : let erow=23 !:
            ! if UDIM(SELMENU$)=MAXMENUHEIGHT AND TITLE$="" THEN LET SROW-=1 : LET EROW-=1
53495     let scol=max(2,39-int(max_menuitem_len/2)) : let ecol=min(79,41+int(max_menuitem_len/2))
53500 !   PAUSE
53505     if env$("GUIMODE")="ON" and nnp=1 and trim$(cap$)<>"" and fkey<>101 then !:
            open #menuwindow:=fngethandle_: "SRow="&str$(max(2,srow))&",SCol="&str$(scol)&",ERow="&str$(min(erow,23))&",ECol="&str$(ecol)&",Border=S[N],TAB="&cap$,display,outin  !:
          else if fkey<>101 then !:
            open #menuwindow:=fngethandle_: "SRow="&str$(max(2,srow))&",SCol="&str$(scol)&",ERow="&str$(min(erow,23))&",ECol="&str$(ecol)&",Border=S[N],Caption="&cap$,display,outin 
53510   if mod(max_menuitem_len,2) then let mw=max_menuitem_len+2 else let mw=max_menuitem_len+3
53515 end if  ! ~G_Use_Fnmenu2
53520 mat selform$(menu_item_count)=("")
53525 for j=1 to menu_item_count
53530   if mstart<>j then 
53535     let selform$(j)=str$(j)&",1,c "&str$(min(78,mw))&",[M]ae"
53540   else 
53545     let selform$(j)=str$(j)&",1,c "&str$(min(78,mw))&",c[M]ae"
53550     let mstart=0
53555   end if 
53560   if ~use_custom_menu then !:
          let _menubar$(j+1)=" &"&srep$(selmenu$(j),"",'-') : let _menuprg$(j+1)=str$(j)&"."
53565 next j
53570 if fkey<>101 then 
53575   display menu: "","",""
53580   if use_custom_menu then !:
          let fndisplay_menu_validate(mat custom_menubar$, mat custom_menuprg$, mat custom_menustatus$) !:
        else !:
          let fndisplay_menu_validate(mat _menubar$, mat _menuprg$, mat _menustatus$)
53585 end if  ! fkey<>101
53590 if g_use_fnmenu2 then 
53595   gosub CALL_FNMENU2
53600 else 
53605   let curfld(menu_curfld)
53610 MENU_RINPUTSELECT_REASK: ! 
53615   if m_timeout>0 then 
53620     rinput #menuwindow,select mat selform$,attr '[L]',wait=m_timeout: mat selmenu$ timeout ignore
53625   else 
53630     rinput #menuwindow,select mat selform$,attr '[L]': mat selmenu$
53635   end if  ! M_Timeout>0
53640   let menu_curfld=curfld
53645 end if 
53650 if cmdkey=93 and ~m_f93_enable then !:
        let cmdkey(99) !:
      else if fkey=8001 and policy_gui_menu_help then !:
        let fn_help(pk$) !:
        goto MENU_RINPUTSELECT_REASK
53655 if ~g_use_fnmenu2 and fkey<>101 then !:
        ! setfnmenu<>-10101 then !:
        let scr_freeze !:
        close #menuwindow: !:
        let scr_thaw !:
        ! Freeze the screen while erasing the menu
53660 if fkey=0 and menu_curfld=udim(selmenu$) and trim$(selmenu$(menu_curfld))(1:1)="0" then let fkey(99)
53665 if fkey=98 and use_custom_menu=yes then !:
        let pk$=menu$ : let setfnmenu=0 !:
      else if fkey<>98 and fkey<>99 and fkey<>9093 and fkey<>93 then !:
        let setfnmenu=menu_curfld !:
      else !:
        let setfnmenu=val(menu$)
53670 ! if fkey=101 then Setfnmenu=-10101
53675 if fkey=98 and use_custom_menu=no then !:
        let pk$=trim$(pk$,"-") : let pk$(9999:0)="-"&str$(val(menu$)) ! ***
53680 ! if Fkey>0 And Fkey<>99 And Fkey<=Udim(Selmenu$) then !:
      ! LET SETFNMENU=FKEY !:
      ! TODO: Should we remove this?
53685 goto MENU_DONE
53690 ! ________________________________
53695 MENU_WINSCROLL: ! 
53700 let setfnmenu=fnwinscroll_(mat selmenu$,mstart, cap$, border$, footer$, scroll_scol,scroll_srow,scroll_cols,scroll_rows,display_only)
53705 if (fkey=0 or fkey=200) and setfnmenu=udim(selmenu$) and trim$(selmenu$(setfnmenu))(1:1)="0" then let fkey(99)
53710 goto MENU_DONE
53715 ! ________________________________
53720 MENU_DONE: ! 
53725 if (fkey=93 or fkey=99) and selmenu$(udim(selmenu$))(1:2)="0." then !:
        let setfnmenu=udim(selmenu$) !:
        let pk$=fnremovepk_part$(pk$,1) !:
      else if fkey=99 or fkey=93 then !:
        let setfnmenu=max(default_selection,1)
53730 if trim$(pk_original$)="" then !:
        let pk$="BLANK"
53735 if setfnmenu=udim(selmenu$) and trim$(pk$)<>"" and fkey<>99 and fkey<>93 then !:
        let pk$=pk_original$ !:
      else if fkey<>93 and fkey<>98 and fkey<>99 and fkey<>101 and fkey<>9093 and setfnmenu<>-10093 and setfnmenu<>-10099 then !:
        let pk$=trim$(trim$(pk$),"-")&"-"&selmenu$(setfnmenu)(1:pos(selmenu$(setfnmenu),'.')-1) soflow ignore
53740 if fkey<>93 and fkey<>99 and fkey<>101 and fkey<>9093 and setfnmenu<>-10093 and setfnmenu<>-10099 and fnsecurity_("MENU:"&fnpk_cleanup$(pk$,2),"Security Policy:  MENU:"&trim$(srep$(pk$,"@","-")),0,user_init$,no)=-1 then !:
        let pk$=pk_original$ !:
        goto MENU_REASK
53745 if fkey<>101 then 
53750   if nnp=0 then print newpage else let nnp=0
53755   display menu: "","",""
53760   if policy_gui_menu_help then close #m_help_win_handle: ioerr ignore
53765 end if  ! fkey<>101
53770 if autonumber=1 then ! remove autonumber before returning !:
        for menuitemcount=1 to udim(selmenu$) !:
          let selmenu$(menuitemcount)=selmenu$(menuitemcount)(4:len(selmenu$(menuitemcount))) !:
        next menuitemcount
53775 MENU_XIT: ! 
53780 let fnmenu_=setfnmenu
53785 fnend 
53790 def fnmenu_val(menu_item$*1)
53792   let alpha=pos("ZYXWVUTSRQPONMLKJIHGFEDCBA",menu_item$)
53794   if alpha>0 then let menu_val=alpha+9 else let menu_val=fnval_(menu_item$)
53796   let fnmenu_val=menu_val
53798 fnend 
53800 def library fntemp$*256
53801   let fntemp$=fntemp_$
53802 fnend 
53805 def library fnwork$*256(work_env$*80)
53806   let fnwork$=fnwork_$(work_env$)
53807 fnend 
53810 def fntemp_$*256
53812   dim envtmp$*256
53814   if ~ran_fntmp then 
53816     let ran_fntmp=1
53818     let envtmp$=env$("Temp") ! "C:\Documents and Settings\[User]\Local Settings\Temp"
53820     let envtmp$=srep$(envtmp$,"Documents and Settings","Docume~1")
53822     let envtmp$=srep$(envtmp$,"Local Settings","Locals~1")
53824     if ~exists(envtmp$) then !:
            let envtmp$="C:\docume~1\"&env$("username")&"\Locals~1\temp"
53826     if ~exists(envtmp$) then !:
            let envtmp$="D:\docume~1\"&env$("username")&"\Locals~1\temp"
53828     if ~exists(envtmp$) then !:
            let envtmp$="C:\TEMP"
53830     if ~exists(envtmp$) then !:
            let envtmp$="C:\WORK"
53832     if ~exists(envtmp$) then let envtmp$="TEMP"
53834     if ~exists(envtmp$) then let fn_make_dir(envtmp$)
53836     if uprc$(env$("CLIENT_SERVER"))="YES" then 
53838       if pos(envtmp$,"\"&session$)<=0 then 
53840         if ~exists(envtmp$&"\"&session$) then !:
                execute "*MKDIR "&envtmp$&"\"&session$
53842         let envtmp$(999:0)="\"&session$
53844       end if  ! Pos(Envtmp$,"\"&Session$)<=0 THEN
53846     end if  ! Uprc$(Env$("CLIENT_SERVER"))="YES" THEN
53848   end if  ! ~Ran_Fntmp THEN
53850   let fntemp_$=envtmp$
53852 fnend 
53860 def fnwork_$*256(work_env$*80)
53862   dim envwork$*256,env_computername$*256
53864   if ~ran_work then 
53866     let ran_work=1
53868     let envwork$=env$(work_env$) ! Get "Generic Work Variable
53870     let envwork$=srep$(envwork$,"Documents and Settings","Docume~1")
53872     let envwork$=srep$(envwork$,"Local Settings","Locals~1")
53874     if ~exists(envwork$) then !:
            let envwork$="C:\docume~1\"&env$("username")&"\Locals~1\temp"
53876     if ~exists(envwork$) then !:
            let envwork$="D:\docume~1\"&env$("username")&"\Locals~1\temp"
53878     if ~exists(envwork$) then !:
            let envwork$="C:\TEMP"
53880     if ~exists(envwork$) then !:
            let envwork$="C:\WORK"
53882     if ~exists(envwork$) then let envwork$="TEMP"
53884     if ~exists(envwork$) then let fn_make_dir(envwork$)
53886     if uprc$(env$("CLIENT_SERVER"))="YES" then 
53887       let env_computername$=trim$(env$("CS_COMPUTERNAME")&"_"&trim$(login_name$))
53888       if pos(envwork$,"\"&env_computername$)<=0 then 
53890         if ~exists(envwork$&"\"&env_computername$) then !:
                execute "*MKDIR '"&envwork$&"\"&env_computername$&"'"
53892         let envwork$(999:0)="\"&env_computername$
53894       end if  ! Pos(EnvWork$,"\"&env_computername$)<=0
53896     end if  ! Uprc$(Env$("CLIENT_SERVER"))="YES" THEN
53898   end if  ! ~Ran_Fntmp THEN
53900   let fnwork_$=envwork$
53902 fnend 
53920 def fn_edi_code_xlate$*20(edi_code_xlate_item$*20) ! edi_code_xlate_
53925   dim edi_code_xlate_return$*20
53930   if ~setup_edi_type_xlate then gosub SETUP_EDI_TYPE_XLATE
53935   let edi_code_xlate_return$=edi_code_xlate_item$
53940   let edi_code_xlate_which=srch(mat edi_code_xlate_from$,uprc$(trim$(edi_code_xlate_item$)))
53945   if edi_code_xlate_which>0 then 
53950     let edi_code_xlate_return$=edi_code_xlate_to$(edi_code_xlate_which)
53955   end if  ! edi_code_xlate_which>0
53960   let fn_edi_code_xlate$=edi_code_xlate_return$
53965 fnend  ! fn_edi_code_xlate$
53970 def library fnget_report_fin$*128(edi_type$,sort_code$,forw_no,printer_name$,&rpt_name$,mat xlt_from$,mat xlt_to$; rmit$, defaultname$,printer_number)
53975   dim setfnget_report_fin$*128,setfnget_report_sin$*128,check_this$*128
53980   let check_this$=setnfget_report_fin$=""
53985   if printer_number=0 then let printer_number=255
53990   if fnishtml(printer_name$) and pos(uprc$(file$(printer_number)),"EXCEL_IT")>0 then let ext$=".xls" !:
        else if fnishtml(printer_name$) then let ext$=".htm" !:
        else if fnisnwp(printer_name$) then let ext$=".nwp" !:
        else let ext$=".rpt"
53995 let sort_code$=trim$(sort_code$)
54000 if rmit$="" then let rmit$="Rmit" else let rmit$=trim$(rmit$)
54005 if defaultname$="" then let defaultname$=rmit$
54010 ALTERNATE_EXTENSIONS: ! 
54015 if ext$<>".rpt" then 
54020   if forw_no>0 and forw_no<=9999 then !:
          let check_this$=fncorrecthtmname$(rmit$&cnvrt$("pic(####)", forw_no),ext$) !:
        else if forw_no>9999 then !:
          let check_this$=fncorrecthtmname$(rmit$&cnvrt$("pic(#####)", forw_no),ext$)
54025 if check_this$<>"" then let setfnget_report_fin$=check_this$ : goto FOUNDIT_FNGETREPORTFINNAME
54030 let check_this$=fncorrecthtmname$(fnrmit_rmt$(rmit$)&cnvrt$("pic(#####)", forw_no),ext$)
54035 if check_this$<>"" then let setfnget_report_fin$=check_this$ : goto FOUNDIT_FNGETREPORTFINNAME
54040 if sort_code$<>"" then let check_this$=fncorrecthtmname$(rmit$&sort_code$, ext$)
54045 if check_this$<>"" then let setfnget_report_fin$=check_this$ : goto FOUNDIT_FNGETREPORTFINNAME
54050 if edi_type$<>"" then let check_this$=fncorrecthtmname$(rmit$&edi_type$, ext$)
54055 if check_this$<>"" then let setfnget_report_fin$=check_this$ : goto FOUNDIT_FNGETREPORTFINNAME
54060 if edi_type$<>"" then let check_this$=fncorrecthtmname$(rmit$&fn_edi_code_xlate$(edi_type$), ext$)
54065 if check_this$<>"" then let setfnget_report_fin$=check_this$ : goto FOUNDIT_FNGETREPORTFINNAME
54070 let check_this$=fncorrecthtmname$(defaultname$,ext$)
54075 if check_this$<>"" then let setfnget_report_fin$=check_this$ : goto FOUNDIT_FNGETREPORTFINNAME
54080 if uprc$(ext$)=".XLS" then !:
        let ext$=".htm" !:
        goto ALTERNATE_EXTENSIONS !:
        ! if .xls not found, try .htm before defaulting to .rpt
54085 end if  ! Ext$<>".rpt"
54090 if forw_no>0 and forw_no<=9999 then !:
        let check_this$=fncorrectname$(rmit$&cnvrt$("pic(####)", forw_no)) else !:
        if forw_no>9999 then !:
          let check_this$=fncorrectname$(rmit$&cnvrt$("pic(#####)", forw_no))
54095 if trim$(check_this$)="" then !:
        let check_this$=fncorrectname$(fnrmit_rmt$(rmit$)&cnvrt$("pic(#####)", forw_no))
54100 if check_this$<>"" then let setfnget_report_fin$=check_this$ : goto FOUNDIT_FNGETREPORTFINNAME
54105 if sort_code$<>"" then let check_this$=fncorrectname$(rmit$&trim$(sort_code$))
54110 if check_this$<>"" then let setfnget_report_fin$=check_this$ : goto FOUNDIT_FNGETREPORTFINNAME
54115 if edi_type$<>"" then let check_this$=fncorrectname$(rmit$&edi_type$)
54120 if check_this$<>"" then let setfnget_report_fin$=check_this$ : goto FOUNDIT_FNGETREPORTFINNAME
54125 let check_this$=fncorrectname$(defaultname$)
54130 if check_this$<>"" then let setfnget_report_fin$=check_this$ : goto FOUNDIT_FNGETREPORTFINNAME
54135 let fnmessagebox_("The file "&defaultname$&ext$&" does not exists.\nReports\"&defaultname$&ext$&" will be used instead.",mb_stop:=16) !:
      let setfnget_report_fin$="Reports\"&defaultname$&ext$ : goto FOUNDIT_FNGETREPORTFINNAME
54140 FOUNDIT_FNGETREPORTFINNAME: ! 
54145 let fnxlatetable(defaultname$,mat xlt_from$,mat xlt_to$)
54150 open #tmp:=fngethandle_: "Name="&setfnget_report_fin$,display,input  !:
      linput #tmp: check_this$ !:
      linput #tmp: rpt_name$ !:
      close #tmp: 
54155 let fnget_report_fin$=uprc$(setfnget_report_fin$)
54160 fnend 
54170 def fnrmit_rmt$*80(prefix$*80)
54175   let fnrmit_rmt$=srep$(srep$(prefix$,"RMIT","RMT"),"COST","CST")
54180 fnend 
54190 ! ________________fnCorrectName and fnCorrectHTMName___________________
54195 def fncorrecthtmname$*128(basename$*124,ext$)
54200   dim setfncorrecthtmname$*128
54205   let setfncorrecthtmname$=""
54210   if exists("CustRpt\"&basename$&ext$) then !:
          let setfncorrecthtmname$="CustRpt\"&basename$&ext$ !:
          goto XIT_FNCORRECTHTMNAME
54215   if exists("Reports\"&basename$&ext$) then !:
          let setfncorrecthtmname$="Reports\"&basename$&ext$ !:
          goto XIT_FNCORRECTHTMNAME
54220 XIT_FNCORRECTHTMNAME: ! 
54225   let fncorrecthtmname$=setfncorrecthtmname$
54230 fnend 
54240 def fncorrectname$*128(basename$*124)
54245   dim setfncorrectname$*128
54250   let setfncorrectname$=""
54255 ! 
54260   if exists("CustRpt\"&basename$&".rpt") then !:
          let setfncorrectname$="CustRpt\"&basename$&".rpt" !:
          goto XIT_FNCORRECTNAME
54265   if exists("Reports\"&basename$&".rpt") then !:
          let setfncorrectname$="Reports\"&basename$&".rpt" !:
          goto XIT_FNCORRECTNAME
54270 XIT_FNCORRECTNAME: ! 
54275   let fncorrectname$=setfncorrectname$
54280 fnend 
54290 def library fnfow_pic$(forw_no)
54292   if forw_no<=9999 then !:
          let fnfow_pic$=cnvrt$('PIC(####)',forw_no) else !:
          let fnfow_pic$=cnvrt$('PIC(#####)',forw_no)
54294 fnend 
54300 def fn_user_pic$(user_no)
54302   if user_no<=999 then !:
          let fn_user_pic$=cnvrt$('PIC(###)',user_no) else !:
          let fn_user_pic$=str$(user_no)
54304 fnend 
54310 def library fnuser_pic$(user_no)
54312   let fnuser_pic$=fn_user_pic$(user_no)
54314 fnend 
54320 def library fnget_edi_file$*128(edi_type$,sort$,forw1; rmit$, ext$)
54325   if ~setup_constants then gosub SETUP_CONSTANTS
54330   dim efile$*128
54335   let efile$=""
54340   if rmit$="" then let rmit$="RMIT"
54345   if ext$="" then let ext$=".edi"
54350   let efile$=""
54355   if forw1<=9999 then 
54360     let efile$="Reports\"&rmit$&cnvrt$("PIC(####)",forw1)&ext$
54365   else 
54370     let efile$="Reports\"&rmit$&cnvrt$("PIC(#####)",forw1)&ext$
54375   end if 
54380   if ~exists(efile$) and exists("Reports\"&fnrmit_rmt$(rmit$)&str$(forw1)&ext$) then 
54385     let rmit$=fnrmit_rmt$(rmit$)
54390     let efile$="Reports\"&rmit$&cnvrt$("PIC(#####)",forw1)&ext$
54395   end if 
54400   if ~exists(efile$) then let efile$="Reports\"&rmit$&trim$(sort$)&ext$
54405   if ~exists(efile$) then let efile$="Reports\"&rmit$&ext$ ! this was needed to make EDI\XML1Updt work.  it only has one template in this format.  This line was commented out - i put it back in (with approval), if you need to take this line back out - please make sure that XML1Updt/EDI still works also
54410   if ~exists(efile$) then let efile$="Reports\"&rmit$&trim$(edi_type$)&ext$
54415   if ~exists(efile$) then let efile$="Reports\"&rmit$&fn_edi_code_xlate$(edi_type$)&ext$
54420   if ~exists(efile$) then let efile$=""
54425   let ext$=""
54430   let fnget_edi_file$=uprc$(efile$)
54435 fnend  ! fnget_edi_file$
54440 def library fnget_report_single$*128(printer_name$,&rpt_name$,mat xlt_from$,mat xlt_to$; rmit$, defaultname$,printer_number)
54445   let check_this$=setfnget_report_sin$=""
54450   if printer_number=0 then let printer_number=255
54455   if fnishtml(printer_name$) and pos(uprc$(file$(printer_number)),"EXCEL_IT")>0 then let ext$=".xls" !:
        else if fnishtml(printer_name$) then let ext$=".htm" !:
        else if fnisnwp(printer_name$) then let ext$=".nwp" !:
        else let ext$=".rpt"
54460 if rmit$="" then let rmit$="Rmit" else let rmit$=trim$(rmit$)
54465 if defaultname$="" then let defaultname$=rmit$
54470 ALTERNATE_SINGLE_EXTENSIONS: ! 
54475 if ext$<>".rpt" then 
54480   let check_this$=fncorrecthtmname$(defaultname$,ext$)
54485   if check_this$<>"" then let setfnget_report_sin$=check_this$ : goto FOUNDIT_FNGETREPORTSINNAME
54490   if uprc$(ext$)=".XLS" then !:
          let ext$=".htm" !:
          goto ALTERNATE_SINGLE_EXTENSIONS !:
          ! if .xls not found, try .htm before defaulting to .rpt
54495 end if 
54500 let check_this$=fncorrectname$(defaultname$)
54505 if check_this$<>"" then let setfnget_report_sin$=check_this$ : goto FOUNDIT_FNGETREPORTSINNAME
54510 if ~exists('reports\'&defaultname$&'.rpt') then !:
        let fnmessagebox_("The file "&defaultname$&" does not exist.\nPlease Make sure the template exists.\nMost Likely the program will fail.\nPlease call 1-800-435-7257 for assistance") !:
        let setfnget_report_sin$="Reports\NOTFOUND.!!!" !:
        goto L54540
54515 let fnmessagebox_("The file "&defaultname$&" does not exist.\nReports\"&defaultname$&".rpt will be used instead.",mb_stop:=16) !:
      let setfnget_report_sin$="Reports\"&defaultname$&".rpt" : goto FOUNDIT_FNGETREPORTSINNAME
54520 FOUNDIT_FNGETREPORTSINNAME: ! 
54525 let fnxlatetable(defaultname$,mat xlt_from$,mat xlt_to$)
54530 open #tmp:=fngethandle_: "Name="&setfnget_report_sin$,display,input  !:
      let check_this$=rpt_name$="*ERR-LINE 86620*" !:
      linput #tmp: check_this$ ioerr L54535 !:
      linput #tmp: rpt_name$ ioerr L54535
54535 L54535: close #tmp: 
54540 L54540: let fnget_report_single$=uprc$(setfnget_report_sin$)
54545 fnend 
54550 ! _______________________fnAsk_WebRef$__________________________________
54555 def library fnask_webref(mat tval$,mat tdesc$; noask,user,user_init$)
54560   dim tline$(1)*512
54565   if fnsecurity_("MAST:INCL DEF WEBREF","",89,user_init$,1)<>-1 then 
54570     let fnasci_("WebRef.ini//8", mat tline$) !:
          mat tval$(udim(tline$)) : mat tdesc$(udim(tline$))
54575     let qcount=0
54580     for linecount=1 to udim(tline$)
54585       if trim$(tline$(linecount))<>"" then !:
              let tabpos=pos(tline$(linecount),chr$(9)) !:
              let tdesc$(qcount+=1)=tline$(linecount)(1:tabpos-1) !:
              let tval$(qcount)=tline$(linecount)(tabpos+1:len(tline$(linecount)))
54590     next linecount
54595   end if 
54600   mat tline$(1)=("") !:
        let fnasci_("Custom\WebRef.ini", mat tline$)
54605   if trim$(tline$(1))<>"" and trim$(tline$(1))<>rpt$("*",512) then 
54610     mat tval$(qcount+udim(tline$)) : mat tdesc$(qcount+udim(tline$))
54615     for linecount=1 to udim(tline$)
54620       if trim$(tline$(linecount))<>"" then !:
              let tabpos=pos(tline$(linecount),chr$(9)) !:
              let tdesc$(qcount+=1)=tline$(linecount)(1:tabpos-1) !:
              let tval$(qcount)=tline$(linecount)(tabpos+1:len(tline$(linecount)))
54625     next linecount
54630   end if 
54635   if noask=0 then !:
          let ask_wired_win_scroll=fnwinscroll_(mat tdesc$, presel, "TITLE=Web Reference Selection HEADING=Description")
54640   if noask=1 or fkey=99 then let setfnaskwired=0 else let setfnaskwired=ask_wired_win_scroll
54645   let fnask_webref=setfnaskwired
54650 fnend 
54660 ! ______________________fnWebRef________________________________________
54665 def library fnwebref(template$*768; parameter$*2000, tdesc$*80)
54670   dim par$(1)*512,parvar$(1)*128, parval$(1)*128, html1$*1024, url$*1024, name$(1)*100, street$(1)*100, csz$(1)*100,name$*100,csz$*99,ucsz$*999,ucsz$(1)*100
54675   let template$=trim$(template$)
54680   if template$='' then print "Your template is blank.  That is wrong." : goto WIRED_XIT
54685 ! parse out Parameter$
54690   let fnparse_csv_(parameter$,mat par$,";") !:
        let pvc=0
54695 ! pick out my favorite parameters
54700   for wiredj=1 to udim(par$)
54705     if pos(uprc$(par$(wiredj)),"PHONE=")>0 then 
54710       mat parvar$(pvc+3) : mat parval$(pvc+3) !:
            let parvar$(phone=pvc+=1)="\PHONE\" : let parval$(pvc)=fnphone_$(par$(wiredj)(7:len(par$(wiredj)))) !:
            let parvar$(pvc+=1)="\PHONE.AREA\" : let parval$(pvc)=parval$(phone)(1:3) !:
            let parvar$(pvc+=1)="\PHONE.BASE\" : let parval$(pvc)=parval$(phone)(5:12)
54715     else if pos(uprc$(par$(wiredj)),"STREET=")>0 then 
54720       mat parvar$(pvc+7) : mat parval$(pvc+7) !:
            let parvar$(street=pvc+=1)="\STREET\" : let parval$(pvc)=par$(wiredj)(8:len(par$(wiredj))) !:
            let fnparsestreet$(parval$(street),mat street$)
54725       let parvar$(pvc+=1)="\STREET.NUMBER\" : let parval$(pvc)=trim$(street$(1)) !:
            let parvar$(pvc+=1)="\STREET.DIRECTION\" : let parval$(pvc)=trim$(street$(2)) !:
            let parvar$(pvc+=1)="\STREET.NAME\" : let parval$(pvc)=trim$(street$(3)) !:
            let parvar$(pvc+=1)="\STREET.TYPE\" : let parval$(pvc)=trim$(street$(4)) !:
            let parvar$(pvc+=1)="\APT.TYPE\" : let parval$(pvc)=trim$(street$(5))
54730       let parvar$(pvc+=1)="\APT.NUMBER\" : let parval$(pvc)=trim$(street$(6))
54735     else if pos(uprc$(par$(wiredj)),"NAME=")>0 and pos(uprc$(par$(wiredj)),"_NAME=")<=0 then 
54740       gosub WIRED_GET_NAME
54745       mat parvar$(pvc+6) : mat parval$(pvc+6) !:
            let parvar$(pvc+=1)="\NAME\" : let parval$(pvc)=name$ !:
            let parvar$(pvc+=1)="\NAME.PREFIX\" : let parval$(pvc)=trim$(name$(1)) !:
            let parvar$(pvc+=1)="\NAME.FIRST\" : let parval$(pvc)=trim$(name$(2)) !:
            let parvar$(pvc+=1)="\NAME.MIDDLE\" : let parval$(pvc)=trim$(name$(3))
54750       let parvar$(pvc+=1)="\NAME.LAST\" : let parval$(pvc)=trim$(name$(4)) !:
            let parvar$(pvc+=1)="\NAME.SUFFIX\" : let parval$(pvc)=trim$(name$(5))
54755     else if pos(uprc$(par$(wiredj)),"CSZ=")>0 then 
54760       mat parvar$(pvc+5) : mat parval$(pvc+5) !:
            let parvar$(city=pvc+=1)="\CSZ\" : let parval$(pvc)=par$(wiredj)(5:len(par$(wiredj))) !:
            let fnparse_csz_$(parval$(city), mat csz$) !:
            let parvar$(pvc+=1)="\CSZ.CITY\" : let parval$(pvc)=csz$(1) !:
            let parvar$(pvc+=1)="\CSZ.STATE\" : let parval$(pvc)=csz$(2) !:
            let parvar$(pvc+=1)="\CSZ.ZIP\" : let parval$(pvc)=csz$(3) !:
            let parvar$(pvc+=1)="\CSZ.COUNTY\" : let fnzip_$(csz$(3),autozip,mat zip_results$) : let parval$(pvc)=zip_results$(6)
54765     else 
54770       mat parvar$(pvc+1) : mat parval$(pvc+1) !:
            let tmppos=pos(par$(wiredj),"=") !:
            let parvar$(pvc+=1)="\"&uprc$(trim$(par$(wiredj)(1:tmppos-1)))&"\" !:
            let parval$(pvc)=par$(wiredj)(tmppos+1:len(par$(wiredj)))
54775     end if 
54780   next wiredj
54785   open #html1:=fngethandle_: "Name="&env$("temp")&"\CM-"&session$&".htm,RecL=5000,Size=0,Replace",display,output  !:
        ! create a file ! HTML1 = output file to be launched
54790 ! PAUSE  ! XXX
54795   print #html1: '<html><head><meta http-equiv="Content-Type" content="text/htm; charset=windows-1252"><META HTTP-EQUIV="refresh" CONTENT="0;URL=';
54800   let buff$=url$=template$ !:
        ! buff$ = line being modified
54805 WIRED_PARSE_NEXT: ! 
54810   let x1=pos(buff$,"\") !:
        let x2=pos(buff$,"\",x1+1) !:
        if x2<=0 then let x2=len(buff$)+1
54815   if x1>0 then 
54820     let buff1$=buff$(x1:x2) ! something like \SOMETHING\
54825     let foundpar=srch(parvar$,buff1$)
54830     if foundpar>0 then let buff1$=fnurl_$(parval$(foundpar)) : let buff_type$="From Table" else let buff_type$=""
54835     if trim$(buff_type$)<>"" then !:
            goto WIRED_NEXT_FIELD else !:
            ! Paramater was used, but wasn't passed - BUFF1$  !:
            ! setting it to blank and continuing  !:
            let buff1$=""
54840   end if 
54845   goto L54865 ! No \ Found, so just output BUFF$!
54850 WIRED_NEXT_FIELD: ! 
54855   let buff1$=srep$(buff1$,"\","%"&unhex$("\")) !:
        let buff$(x1:x2)=fnurl_$(buff1$)
54860   if pos(buff$,"\")>0 then goto WIRED_PARSE_NEXT
54862   print #html1: buff$;
54865 L54865: if fnsecurity_("MAST:SKIP DEMOGRAPHS","",89,user_init$,1)<>-1 then 
54870     print #html1: '"></head><body><div align=center><h1>'&tdesc$&'</h1><p>Please wait, while the requested web site is contacted...</p></div>'
54875     print #html1: "<Table>"
54880     for wiredj=1 to udim(parvar$)
54885       if trim$(parval$(wiredj))<>"" and pos(parvar$(wiredj),".")<=0 then 
54886         let tmp$=parvar$(wiredj)(2:len(parvar$(wiredj))-1) !:
              let tmp$=srep$(tmp$,"-"," ") !:
              let tmp$=srep$(tmp$,"_"," ") !:
              let tmp$=fninitcap$(tmp$)
54887         if pos(parvar$(wiredj),"\SSN\")>0 then !:
                print #html1: "<tr><td>"&tmp$&"</td><td>"&fn_mask$(parval$(wiredj),-4)&"</td></tr>" !:
              else !:
                print #html1: "<tr><td>"&tmp$&"</td><td>"&parval$(wiredj)&"</td></tr>"
54889       end if  ! Trim$(Parval$(Wiredj))<>"" And Pos(Parvar$(Wiredj),".")<=0
54890     next wiredj
54895     print #html1: "</Table>"
54900     print #html1: '</body></html>'
54901   else 
54902     print #html1: '"></head></html>'
54903   end if 
54905   goto WIRED_DONE
54910 ! __
54915 WIRED_DONE: ! 
54920   let html1$=file$(html1)
54925   close #html1: 
54930   let scr_thaw: let fn_exe('-c -w','vb32\vbshell.exe',html1$)
54935 WIRED_XIT: ! 
54940 fnend 
54950 ! __________wired complicated gets
54955 WIRED_GET_NAME: ! r: 
54960 let name$=par$(wiredj)(6:len(par$(wiredj)))
54965 if pos(name$,"/")>0 then let type=1 else let type=2
54970 let fnparse_name_$(name$, type, mat name$)
54975 return ! /r
54980 ! _________________________fnURL________________________________________
54982 def library fnurl$*2000(input$*2000)
54984   let fnurl$=fnurl_$(input$)
54986 fnend 
54990 def fnurl_$*2000(input$*2000)
54995   let input$=trim$(trim$(input$,chr$(9))) ! trim tabs, then trim spaces
55000 ! allow only     =-./:;&?_%     0-9     A-Z     a-z
55005   let urlj=0
55010   do until urlj=>len(input$)
55015     let isbad=0 !:
          let decchr=ord(input$(urlj+=1:urlj))
55020     if (decchr<45) then let isbad=1
55025     if decchr=47 then let isbad=1
55030     if (decchr>=58 and decchr<=64) then let isbad=1
55035     if decchr=96 then let isbad=1
55040     if (decchr>=91 and decchr<=96) then let isbad=1
55045     if decchr>122 then let isbad=1
55050     if decchr=38 then let isbad=0 ! &
55055     if decchr=37 then let isbad=0 ! %
55060     if isbad=1 then !:
            let input$(urlj:urlj)='%'&unhex$(input$(urlj:urlj)) !:
            let urlj+=2
55065   loop 
55070   let fnurl_$=input$
55075 fnend 
55080 def library fnemail_subject$*2000(es_input$*2000)
55085 ! allow only     0-9     A-Z     a-z     same as fnurl, but also disallow:  =-./:;&?_%
55090   let es_input$=srep$(es_input$,'%','%25')
55095   let es_input$=fnurl_$(es_input$)
55100   let es_input$=srep$(es_input$,'&','%26')
55105   let es_input$=srep$(es_input$,'=','%3D')
55110   let es_input$=srep$(es_input$,'-','%2D')
55115   let es_input$=srep$(es_input$,'.','%2E')
55120   let es_input$=srep$(es_input$,'/','%2F')
55125   let es_input$=srep$(es_input$,':','%3A')
55130   let es_input$=srep$(es_input$,';','%3B')
55135   let es_input$=srep$(es_input$,'?','%3F')
55140   let es_input$=srep$(es_input$,'_','%5F')
55145   let fnemail_subject$=es_input$
55150 fnend  ! fnemail_subject$
55160 def library fnzone_security(&inzone$)
55165   if ~setup_zone_security then gosub SETUP_ZONE_SECURITY
55170   let fnzone_security=fn_zone_security(inzone$)
55175 fnend  ! fnzone_security
55180 def fn_zone_security(&inzone$)
55185   let inzone$=uprc$(inzone$)
55190   for zcount=1 to udim(mat zone_line$)
55195     if pos(inzone$,zone_from$(zcount))>0 then 
55200       if zone_mask$(zcount)='' then 
55205         let inzone$=srep$(inzone$,zone_from$(zcount),zone_to$(zcount))
55210       else 
55215         let inzone$=srep$(inzone$,zone_from$(zcount),zone_to$(zcount)&'~Mask~')
55220       end if  ! zone_mask$(zcount)=''   /   else 
55225     end if 
55230   next zcount
55235 fnend  ! fn_zone_security
55240 def library fnget_shortname$*512(longname$*512; filename$*512, returnpathalso)
55242   let fnget_shortname$=fngetshortname$(longname$, filename$,returnpathalso)
55244 fnend 
55250 def fngetshortname$*512(longname$*512; filename$*512, returnpathalso)
55255 ! LongName$ - either just the FileName or the Path and FileName !:
        ! FileName$ - either blank or the FileName !:
        ! ReturnPathAlso - if =0 fnGetShortName$ will return just the short filename if capable !:
        !                  if =1 fnGetShortName$ will return just short path and filename if capable !:
        !                  if incapable, fnGetShortName$ will return just LongName$
55260 ! 
55265   dim piece$(1)*128, ext$(1)*128, setfngetshortname$*128
55270   let longname$=srep$(longname$,"*.*","")
55275   if filename$<>"" and longname$(len(longname$):len(longname$))="\" then let longname$(9999:0)=trim$(filename$) : goto GSN_AFTER_COMBINE_PATH_FILE
55280   if filename$<>"" and longname$(len(longname$):len(longname$))<>"\" then let longname$(9999:0)="\"&trim$(filename$)
55285 GSN_AFTER_COMBINE_PATH_FILE: ! 
55290   if longname$(len(longname$):len(longname$))="\" then let hadbackslash=1 else let hadbackslash=0
55295   let setfngetshortname$="" !:
        let fnparse_csv_(longname$,mat piece$,"\") !:
        let piece$(1)=longname$(1:pos(longname$,"\")-1)
55300   mat ext$(udim(piece$))=("")
55305   for extcount=1 to udim(piece$)
55310     let dotpos=pos(piece$(extcount),".",-1)
55315     if dotpos>1 then !:
            let ext$(extcount)=piece$(extcount)(dotpos:len(piece$(extcount))) !:
            let piece$(extcount)=piece$(extcount)(1:pos(piece$(extcount),".",-1)-1) !:
          else let ext$(extcount)=""
55320   next extcount
55325   for piececount=1 to udim(piece$)
55330     if piece$(piececount)(2:2)=":" then !:
            let absolute=1 !:
          else let absolute=0
55335     if len(piece$(piececount))<=8 and len(ext$(piececount))<=4 and pos(piece$(piececount)," ")<=0 and pos(ext$(piececount)," ")<=0 then 
55340       let setfngetshortname$(9999:0)=piece$(piececount)&ext$(piececount)
55345     else 
55350       do while pos(piece$(piececount)," ")=>1
55355         let spacepos=pos(piece$(piececount)," ")
55360         let piece$(piececount)(spacepos:spacepos)=""
55365       loop 
55370       do while pos(ext$(piececount)," ")=>1
55375         let spacepos=pos(ext$(piececount)," ")
55380         let ext$(piececount)(spacepos:spacepos)=""
55385       loop 
55390       if len(piece$(piececount))>8 then 
55395         let setfngetshortname$(9999:0)=piece$(piececount)(1:6)&"~1"&ext$(piececount)(1:4)
55400       end if 
55405     end if 
55410     if piececount<>udim(piece$) then let setfngetshortname$(9999:0)="\"
55415   next piececount
55420   if hadbackslash=1 then let setfngetshortname$(9999:0)="\"
55425   if exists(setfngetshortname$) then 
55430     if returnpathalso=1 then 
55435       let fngetshortname$=setfngetshortname$
55440     else 
55445       let fngetshortname$=setfngetshortname$(pos(setfngetshortname$,"\",-1)+1:len(setfngetshortname$))
55450     end if 
55455   else 
55460     if returnpathalso=1 then 
55465       let fngetshortname$=longname$
55470     else 
55475       let fngetshortname$=longname$(pos(longname$,"\",-1)+1:len(longname$))
55480     end if 
55485   end if 
55490 ! PRINT "Absolute="&STR$(ABSOLUTE) ! XXX
55495 fnend 
55500 ! __________________fnCache_Matrix_____________________________________
55502 dim cmx_description$*60,cmx_action$*10,cmx_result$*10,cmx_sql_field$*30
55504 def library fncache_matrix(llcode$*8,fow,matrix_type$*8,sort$*5,mat action$,&edi_code$; &cmx_calling_description$,&cmx_calling_action$,&cmx_calling_result$,&cmx_calling_cost,&cmx_calling_sql_field$)
55506   let fncache_matrix=fncachematrix(llcode$,fow,matrix_type$,sort$(1:4),mat action$,edi_code$, cmx_description$:=cmx_calling_description$,cmx_action$=cmx_calling_action$,cmx_result$=cmx_calling_result$,cmx_cost=cmx_calling_cost,cmx_sql_field$=cmx_calling_sql_field$) !:
        ! CM 7.2 FOW MAY BE 32767 !:
        ! ** Sort is still 4 characters
55508   let cmx_calling_description$=cmx_description$ soflow ignore !:
        let cmx_calling_action$=cmx_action$ soflow ignore !:
        let cmx_calling_result$=cmx_result$ soflow ignore !:
        let cmx_calling_sql_field$=cmx_sql_field$ soflow ignore !:
        let cmx_calling_cost=cmx_cost
55510 fnend 
55520 def fncachematrix(llcode$*8,fow,matrix_type$*8,sort$*5,mat action$,&edi_code$; &cmx_description$, &cmx_action$,&cmx_result$,&cmx_cost,&cmx_sql_field$) ! cmx_
55525 ! fnCache_Matrix = set by SETFNCACHEMAT - 0 means no record returned - 1 means record returned
55530 ! 
55535   dim cachemat1$(1)*25,cachemat1_key$*25 ! LLCODE$ + Matrix_Type$ + FOW
55540   dim cachemat2_key$*25 ! LLCODE$ + Matrix_Type$ + Sort$
55545   dim cachemat3_key$*25 ! LLCODE$ + Matrix_Type$
55550   dim cachematnokey$(1)*25,cachematnokey$*25 ! LLCODE$ + Matrix_Type$ + FOW + Sort$
55555   dim cache_action$(1,10)*8,cache_edi_code$(1)*8
55560   dim cmx_cache_description$(1)*60,cmx_cache_action$(1)*10,cmx_cache_result$(1)*10,cmx_cache_sql_field$(1)*30
55565   let maxcachematcount=999 !:
        let maxcachematnokeycount=9999
55570   let llcode$=uprc$(rpad$(llcode$,8)) !:
        let matrix_type$=rpad$(matrix_type$,8)
55575   let cachematnokey$=llcode$&matrix_type$&rpad$(str$(fow),5)(1:5)&rpad$(sort$,4)
55580   let badone=srch(mat cachematnokey$,cachematnokey$) !:
        if badone>0 then goto CACHEMAT_RECORD_NOT_FOUND
55584   let cachemat1_key$=cachematnokey$(1:21)
55585   let gotit=srch(mat cachemat1$,cachemat1_key$)
55590   if gotit<=0 then !:
          let cachemat2_key$=cachematnokey$(1:16)&rpad$(sort$,5) !:
          let gotit=srch(mat cachemat1$,cachemat2_key$)
55595   if gotit<=0 then !:
          let cachemat3_key$=cachematnokey$(1:16)&"     " !:
          let gotit=srch(mat cachemat1$,cachemat3_key$)
55600   if gotit<=0 then ! add it
55605     gosub CACHEMAT_READ !:
          if readitwithkey=0 then gosub CACHEMAT_ADD_TO_BAD : goto CACHEMAT_RECORD_NOT_FOUND
55610     let cachematcount+=1
55615     if cachematcount>maxcachematcount then let cachematcount=1
55620     if cachematcount>udim(cachemat1$) then !:
            mat cachemat1$(cachematcount) !:
            mat cache_action$(cachematcount,10) !:
            mat cache_edi_code$(cachematcount) !:
            mat cmx_cache_description$(cachematcount) !:
            mat cmx_cache_action$(cachematcount) !:
            mat cmx_cache_result$(cachematcount) !:
            mat cmx_cache_sql_field$(cachematcount) !:
            mat cmx_cache_cost(cachematcount)
55625     let cachemat1$(cachematcount)=cachematnokey$ !:
          ! if Readitwithkey=1 then let Cachemat1$(Cachematcount)=Cachemat1_Key$ else !:
          ! if Readitwithkey=2 then let Cachemat1$(Cachematcount)=Cachemat2_Key$ else !:
          ! if Readitwithkey=3 then let Cachemat1$(Cachematcount)=Cachemat3_Key$
55630     let cache_edi_code$(cachematcount)=edi_code$ !:
          for j=1 to 10 : let cache_action$(cachematcount,j)=action$(j) : next j !:
          let cmx_cache_description$(cachematcount)=cmx_description$ !:
          let cmx_cache_action$(cachematcount)=cmx_action$ !:
          let cmx_cache_result$(cachematcount)=cmx_result$ !:
          let cmx_cache_sql_field$(cachematcount)=cmx_sql_field$ !:
          let cmx_cache_cost(cachematcount)=cmx_cost !:
          let setfncachemat=1
55635   else ! return it
55640     for j=1 to 10 : let action$(j)=cache_action$(gotit,j) : next j
55645     let edi_code$=cache_edi_code$(gotit)
55650     let cmx_description$=cmx_cache_description$(gotit) !:
          let cmx_action$=cmx_cache_action$(gotit) !:
          let cmx_result$=cmx_cache_result$(gotit) !:
          let cmx_sql_field$=cmx_cache_sql_field$(gotit) !:
          let cmx_cost=cmx_cache_cost(gotit)
55655     let setfncachemat=1
55660   end if 
55665   goto CACHEMAT_XIT
55670 ! __
55675 CACHEMAT_ADD_TO_BAD: ! 
55680   let cachematnokeycount+=1
55685   if cachematnokeycount>maxcachematnokeycount then let cachematnokeycount=1
55690   if cachematnokeycount>udim(cachematnokey$) then mat cachematnokey$(cachematnokeycount)
55695   let cachematnokey$(cachematnokeycount)=cachematnokey$
55700   return  ! CACHEMAT_ADD_TO_BAD
55705 ! __
55710 CACHEMAT_READ: ! 
55715 CACHEMAT_FORM: form pos 1,2*c 8,pos 109,c 5,pos 21,11*c 8,pos 114,c 60,2*c 10,pos 194,c 30,pos 224,pd 6.2
55720   if edimatrix=0 then !:
          mat cachematkey1$(1)=("") : mat cachematnkey$(1)=("") : let cachematcount=0 !:
          open #edimatrix:=fngethandle_: "NAME=EDIMATRX.INT/edi,KFNAME=EDIMATRX.IDX/edi,SHR",internal,input,keyed 
55725   let readitwithkey=cmx_cost=0 !:
        let tllcode$=tmatrix$=tforw$=edi_code$=cmx_description$=cmx_action$=cmx_result$=cmx_sql_field$="" !:
        mat action$=("") !:
        let llcode$=uprc$(rpad$(llcode$,8))
55730   read #edimatrix,using CACHEMAT_FORM,key=cachemat1_key$,release: tllcode$,tmatrix$,tforw$,edi_code$,mat action$,cmx_description$,cmx_action$,cmx_result$,cmx_sql_field$,cmx_cost nokey L55735 !:
        let readitwithkey=1 !:
        goto CACHEMAT_READ_XIT
55735 L55735: read #edimatrix,using CACHEMAT_FORM,key=cachemat2_key$,release: tllcode$,tmatrix$,tforw$,edi_code$,mat action$,cmx_description$,cmx_action$,cmx_result$,cmx_sql_field$,cmx_cost nokey L55740 !:
        let readitwithkey=2 !:
        goto CACHEMAT_READ_XIT
55740 L55740: read #edimatrix,using CACHEMAT_FORM,key=cachemat3_key$,release: tllcode$,tmatrix$,tforw$,edi_code$,mat action$,cmx_description$,cmx_action$,cmx_result$,cmx_sql_field$,cmx_cost nokey L55745 !:
        let readitwithkey=3 !:
        goto CACHEMAT_READ_XIT
55745 L55745: ! LET FNREAD_MATRIX=0 !:
        goto CACHEMAT_READ_XIT
55750 CACHEMAT_READ_XIT: ! 
55755 ! LET FNREAD_MATRIX=1
55760   return  ! CACHEMAT_READ
55765 ! __
55770 CACHEMAT_RECORD_NOT_FOUND: ! 
55775   mat action$=("")
55780   let edi_code$=cmx_description$=""
55785   let setfncachemat=0
55790   goto CACHEMAT_XIT ! CACHEMAT_RECORD_NOT_FOUND
55795 ! __
55800 CACHEMAT_XIT: ! 
55805 ! if cmx_soflow_was$="System" then on soflow system
55810   let fncachematrix=setfncachemat
55815 fnend 
55820 ! _____________________fnRead_Letter_Desc(...)__________________________
55822 def library fnread_letter_desc(llcode$,&ldesc$)
55824   let fnread_letter_desc=fnreadletter_desc(llcode$,ldesc$)
55826 fnend 
55830 ! fnRead_Letter_Desc = set by SetfnReadLetter - 0 means no record returned - 1 means record returned !:
      ! LLCode$ is the Key !:
      ! READLETTER_FORCEREAD removed, this debug feature affects the performance of very read of the Letters Description
55835 def fnreadletter_desc(llcode$,&ldesc$)
55840 ! this function inherrits local variable:   h_letters
55845   let setfnreadletter=-1
55850   dim readletternokey$(1)*8,readletterkey$(1)*8,readletter1_key$*8
55855   dim cache_ldesc$(1)*27
55860   let maxreadlettercount=10000 !:
        let maxreadletternokeycount=10000
55865   let readletter1_key$=uprc$(rpad$(llcode$,8)(1:8))
55870   let badone=srch(mat readletternokey$,readletter1_key$) !:
        if badone>0 then goto READLETTER_RECORD_NOT_FOUND
55875   let gotit=srch(mat readletterkey$,readletter1_key$)
55880   if gotit<=0 then ! add it
55885     gosub READLETTER_READ !:
          if readitwithkey=0 then gosub READLETTER_ADD_TO_BAD : goto READLETTER_RECORD_NOT_FOUND
55890     let readlettercount+=1
55895     if readlettercount>maxreadlettercount then let readlettercount=1
55900     if readlettercount>udim(readletterkey$) then !:
            mat readletterkey$(readlettercount) !:
            mat cache_ldesc$(readlettercount)
55905     if readitwithkey=1 then let readletterkey$(readlettercount)=readletter1_key$
55910     let cache_ldesc$(readlettercount)=ldesc$ !:
          let setfnreadletter=1
55915   else ! return it
55920     let ldesc$=cache_ldesc$(gotit)
55925     let setfnreadletter=1
55930   end if 
55935   goto READLETTER_XIT
55940 ! __
55945 READLETTER_ADD_TO_BAD: ! 
55950   let readletternokeycount+=1
55955   if readletternokeycount>maxreadletternokeycount then let readletternokeycount=1
55960   if readletternokeycount>udim(readletternokey$) then mat readletternokey$(readletternokeycount)
55965   let readletternokey$(readletternokeycount)=readletter1_key$
55970   return 
55975 ! __
55980 READLETTER_READ: ! 
55985 READLETTER_FORM: form pos 5,c 27
55990   if fn_needs_open_file(h_letters,"LETTERS.Y") then !:
          open #h_letters:=fngethandle_: "Name=Letters//6,KFName=Letters.y//6,ShrU",internal,input,keyed 
55995   let readitwithkey=0
56000   read #h_letters,using READLETTER_FORM,key=readletter1_key$,release: ldesc$ nokey READLETTER_READ_XIT ioerr READLETTER_IOERR !:
        let readitwithkey=1 !:
        goto READLETTER_READ_XIT
56005 READLETTER_IOERR: let ldesc$=readletter1_key$&" "&str$(err)&" "&file$(h_letters)
56010 READLETTER_READ_XIT: ! 
56015   return 
56020 ! __
56025 READLETTER_RECORD_NOT_FOUND: ! 
56030   let setfnreadletter=0
56035   goto READLETTER_XIT
56040 ! __
56045 READLETTER_XIT: ! 
56050 !    if SETFNReadLetter=-1 THEN print "There is a problem in fnRead_Letter_Desc" : PAUSE ! XXX
56055   let fnreadletter_desc=setfnreadletter
56060 fnend 
56070 def library fnlast_edi_code_date
56072 ! this fn returns the date associated with the fnlast_edi_code$ previously returned.
56074   let fnlast_edi_code_date=lec_active_trans_date_passed
56076 fnend  ! fnlast_edi_code_date
56080 def library fnlast_edi_code$(fileno$*8,h_active,matrix_type$,mat acceptable$; fow,sort$,last_action_code$,mat lec_filter_date) ! Lec_
56085 ! Lec_Filter_Date(1) - Starting Transaction Date Range (optional) - CCYYMMDD format required
56090 ! Lec_Filter_Date(2) - Ending Transaction Date Range (optional) - CCYYMMDD format required
56095   dim nfileno$*8
56100   let false=lec_active_trans_date_passed=0
56105 LEC_FORM_ACVTIVE: form c 8,x 56,c 8,pos 9,bh 4
56110   let matrix_type$ = fnedi_type_to_matrix_type_$(matrix_type$) ! if function is passed EDI type, this converts it to the appropriate Matrix Type
56115 ! Set Nfileno to next possibity
56120   let fileno$=rpad$(trim$(fileno$),8) !:
        let nfileno$=fileno$(1:7)&chr$(ord(fileno$(8:8))+1)
56125 ! 
56130   let llcode$=edi_code$=""
56135   read #h_active,search>=nfileno$,release: nokey LEC_READLAST
56140 LEC_READ: ! 
56145   read #h_active,using LEC_FORM_ACVTIVE,prior,release: newfileno$,llcode$,lec_active_data_trans_date eof LEC_FAILURE
56150   if udim(mat lec_filter_date)=>1 and lec_filter_date(1)>0 and lec_active_data_trans_date<lec_filter_date(1) then goto LEC_READ
56155   if udim(mat lec_filter_date)=>2 and lec_filter_date(2)>0 and lec_active_data_trans_date>lec_filter_date(2) then goto LEC_READ
56160   if newfileno$<>fileno$ then goto LEC_FAILURE
56165   if fncachematrix(llcode$,fow,matrix_type$,sort$, mat action$,edi_code$)=0 then goto LEC_READ
56170   if trim$(acceptable$(1))<>"" and srch(mat acceptable$,uprc$(trim$(edi_code$)))<=0 then !:
          goto LEC_READ
56175   if trim$(last_action_code$)<>"" and srch(mat action$,last_action_code$)<=0 then !:
          goto LEC_READ
56180   let lec_active_trans_date_passed=lec_active_data_trans_date
56185   goto LEC_DONE
56190 ! 
56195 LEC_FAILURE: ! 
56200   goto LEC_XIT
56205 ! 
56210 LEC_DONE: ! 
56215   let fnlast_edi_code$=edi_code$
56220   goto LEC_XIT
56225 ! 
56230 LEC_READLAST: ! 
56235   read #h_active,last,release: 
56240   goto LEC_READ
56245 ! 
56250 LEC_XIT: ! 
56255 fnend 
56260 !_____
56265 def library fnread_letter_akbe(llcode$,&base_extra$,mat add_key$)
56270 ! fnRead_Letter_AKBE = set by SetFnReadAKBE - 0 means no record returned - 1 means record returned !:
        ! LLCode$ is the Key
56275   dim readakbenokey$(1)*8,readakbekey$(1)*8,readakbe1_key$*8
56280   dim cache_base_extra$(1)*27,cache_add_key$(1,19)*32
56285   let akbe_forceread=0 ! xxx
56290   let readakbe1_key$=uprc$(rpad$(llcode$,8))
56295   if akbe_forceread then gosub READAKBE_READ
56300   if (akbe_forceread and readakbewithkey=0) then goto READAKBE_RECORD_NOT_FOUND else !:
          if (akbe_forceread and readakbewithkey<>0) then let setfnreadakbe=1 : goto READAKBE_XIT
56305   let maxreadakbecount=1500 !:
        let maxreadakbenokeycount=10000
56310   let badone=srch(mat readakbenokey$,readakbe1_key$) !:
        if badone>0 then goto READAKBE_RECORD_NOT_FOUND
56315   let gotit=srch(mat readakbekey$,readakbe1_key$)
56320   if gotit<=0 then ! add it
56325     gosub READAKBE_READ !:
          if readakbewithkey=0 then gosub READAKBE_ADD_TO_BAD : goto READAKBE_RECORD_NOT_FOUND
56330     if (readakbecount+=1)>maxreadakbecount then let readakbecount=1
56335     if readakbecount>udim(readakbekey$) then !:
            mat readakbekey$(readakbecount) !:
            mat cache_base_extra$(readakbecount) !:
            mat cache_add_key$(readakbecount,19)
56340     let readakbekey$(readakbecount)=readakbe1_key$
56345     let cache_base_extra$(readakbecount)=base_extra$ !:
          for j=2 to 19 : let cache_add_key$(readakbecount,j)=add_key$(j) : next j !:
          let setfnreadakbe=1
56350   else ! return it
56355     let base_extra$=cache_base_extra$(gotit) !:
          for j=2 to 19 : let add_key$(j)=cache_add_key$(gotit,j) : next j
56360     let setfnreadakbe=1
56365   end if 
56370   goto READAKBE_XIT
56375 ! __
56380 READAKBE_ADD_TO_BAD: ! 
56385   if (readakbenokeycount+=1)>maxreadakbenokeycount then let readakbenokeycount=1
56390   if readakbenokeycount>udim(readakbenokey$) then mat readakbenokey$(readakbenokeycount)
56395   let readakbenokey$(readakbenokeycount)=readakbe1_key$
56400   return 
56405 ! __
56410 READAKBE_READ: ! 
56415 READAKBE_FORM: form pos 5,c 27,pos 922,12*c 30,6*c 14
56420   if h_letters=0 then !:
          open #h_letters:=fngethandle_: "Name=Letters//6,KFName=Letters.y//6,ShrU",internal,input,keyed 
56425   let readakbewithkey=0
56430   read #h_letters,using READAKBE_FORM,key=readakbe1_key$,release: base_extra$,mat add_key$(2:19) nokey READAKBE_READ_XIT !:
        let readakbewithkey=1
56435 READAKBE_READ_XIT: ! 
56440   return 
56445 ! __
56450 READAKBE_RECORD_NOT_FOUND: ! 
56455   let setfnreadakbe=0
56460   goto READAKBE_XIT
56465 ! __
56470 READAKBE_XIT: ! 
56475   let fnread_letter_akbe=setfnreadakbe
56480 fnend 
56490 !_____
56492 def library fnnextdebt(fileno$,h_debtor)
56494   let fnnextdebt=fnnextdebt_(fileno$,h_debtor)
56496 fnend 
56500 def fnnextdebt_(fileno$,h_debtor)
56502 ! This function returns the Total # of Debtor already on the case !:
        ! So Technically "NEXTDEBT" would be FNNEXTDEBT+1
56504 !  LET BEFOREREC=REC(H_DEBTOR) ! in case I want to restore back to that record after the function has done it's thing.
56506   let fileno$=rpad$(trim$(fileno$),8)
56508   let debtorcount=0
56510   restore #h_debtor,key>=fileno$&"   ": nokey NEXTDEBT_EOF
56512   do 
56514     read #h_debtor,using "Form Pos 1,C 8,N 3",release: nextfileno$,debt_number eof NEXTDEBT_EOF
56516     let debtorcount+=1
56518   loop while trim$(nextfileno$)=trim$(fileno$)
56520   let debtorcount-=1
56522 NEXTDEBT_EOF: ! 
56524   let fnnextdebt_=debtorcount
56526 fnend 
56530 ! _______________________fnGetDir_MinusBee______________________________________________
56535 def fngetdir_minusbee(dir_path$*256,mat dirs$,mat files$,mat size,mat dait$)
56540 ! this function will take the results of a LONG$="Y" and convert the names to really long names
56545   dim longname32$(1)*32,longname$(1)*256
56550 ! PRINT ' if you want to screw this function up by adding a file to the directory specified, than do it now.' : INPUT FIELDS "1,1,C 1,AE": PAUSE$
56555   execute '*dir "'&trim$(dir_path$)&'" -b -o >[Temp]DIR-[Session].TXT' ioerr GDMB_XIT
56560   let fnasci_('[Temp]DIR-[Session].TXT',mat longname$)
56565 ! LET FC=0 ! FC - file count   DC - dir count
56570   mat longname32$(udim(longname$)) : for j=1 to udim(longname$) : let longname32$(j)=trim$(uprc$(longname$(j)(1:32))) : next j
56575   for j=1 to udim(files$) : let files$(j)=trim$(uprc$(files$(j)(1:32))) : next j
56580   for ic=2 to udim(longname$)-1 ! ic - item count    -   starting at 4 skips Title, '.' and '..' items    -    and the -1 skips the total record
56585     if trim$(longname$(ic))<>"." and trim$(longname$(ic))<>".." then 
56590       let dirsrch=srch(mat dirs$,longname32$(ic))
56595       let filsrch=srch(mat files$,longname32$(ic))
56600       if dirsrch>0 then 
56605         let dirs$(dirsrch)=longname$(ic)
56610       end if 
56615       if filsrch>0 then 
56620         let files$(filsrch)=longname$(ic)
56625       end if 
56630       if filsrch<=0 and dirsrch<=0 then 
56635         if uprc$(env$("Debug"))="YES" then !:
                print str$(ic)&" Neither a file nor a dir could be found" !:
                print "LongName$("&str$(ic)&")="&longname$(ic) !:
                ! pause ! INPUT FIELDS "1,1,C 1,AE": PAUSE$
56640       else if filsrch>0 and dirsrch>0 then 
56645         if uprc$(env$("Debug"))="YES" then !:
                print str$(ic)&"BOTH a file AND a dir were found" !:
                print "LongName$("&str$(ic)&")="&longname$(ic) !:
                ! pause ! INPUT FIELDS "1,1,C 1,AE": PAUSE$
56650       end if 
56655     end if  ! if Trim$(LongName$(IC))<>"." and Trim$(LongName$(IC))<>".."
56660   next ic
56665   execute '*Free [Temp]DIR-[Session].TXT -n'
56670 GDMB_XIT: ! 
56675 fnend 
56680 !_____
56682 def library fnsql_key(skbuff$*512,skfileno$*8,mat sk$)
56684   let setfnsql_key=0
56686   let skbuff$=trim$(trim$(skbuff$),"\")
56688   let dotpos=pos(skbuff$,".") : if dotpos<1 then goto SK_ERROR
56690   let sk_pos1=fnfirstnumber(skbuff$) !:
        if sk_pos1=-1 then let sk_pos1=dotpos-1 !  SK_pos1=position of the first number or the first dot-1
56692 ! print 'SK_POS1=';SK_POS1 : pause
56694   let sk_num=val(skbuff$(sk_pos1:dotpos-1)) conv SK_NUM_CONV
56696 SK_NUM_CONV: ! 
56698   if sk_num=0 then let sk_num=1
56700   let sk$(1)=rpad$(trim$(uprc$(skfileno$)),8)&cnvrt$('pic(ZZZ)',sk_num) conv SK_ERROR
56702   let sk$(2)=skbuff$(1:dotpos-1)
56704   let setfnsql_key=sk_num
56706   goto SK_XIT
56708 SK_ERROR: ! 
56710   let setfnsql_key=-1
56712 SK_XIT: ! 
56714   let fnsql_key=setfnsql_key
56716 fnend 
56720 !_____
56722 def fnfirstnumber(firnumstr$*512)
56724 ! this function returns the position of the first number in a string, or -1 if none are found
56726   let setfnfirstnumber=-1
56728   for j=1 to len(firnumstr$)
56730     let frnumord=ord(firnumstr$(j:j))
56732     if frnumord=>48 and frnumord<=57 then let setfnfirstnumber=j : goto XIT_FNFIRSTNUMBER
56734   next j
56736 XIT_FNFIRSTNUMBER: ! 
56738   let fnfirstnumber=setfnfirstnumber
56740 fnend 
56750 !_____
56755 def library fnptime$(ptime$)
56760   let ptime$=trim$(ptime$)
56765   if trim$(ptime$)="" then let ptime$="08:00:00"
56770   if len(ptime$)=4 then let ptime$=ptime$(1:2)&":"&ptime$(3:4)&":"&"00"
56775   if len(ptime$)=3 then let ptime$="0"&ptime$(1:1)&":"&ptime$(2:3)&":"&"00"
56780   if len(ptime$)=6 then let ptime$=ptime$(1:2)&":"&ptime$(3:4)&":"&ptime$(5:6)
56785   let fnptime$=ptime$
56790 fnend 
56800 !_____
56802 def library fnremove_pk_part$*80(&pk$; how_many)
56804   let fnremove_pk_part$=fnremovepk_part$(pk$, how_many)
56806 fnend 
56810 def fnremovepk_part$*80(&pk$; how_many)
56815   if how_many=0 then let how_many=1
56820   for j=1 to how_many
56825     let pk$=pk$(1:pos(pk$,"-",-1)-1)
56830   next j
56835   let fnremovepk_part$=pk$
56840 fnend 
56850 ! _______________fnS7_Changes_____________________________________________
56852 def library fns7_changes(changes_h,active_handle,fileno$,user_id,mat before_u$,mat after_u$,paperlesscode)
56854   let fns7_changes=fns7changes(changes_h,active_handle,fileno$,user_id,mat before_u$,mat after_u$,paperlesscode)
56856 fnend 
56860 def fns7changes(changes_h,active_handle,fileno$,user_id,mat before_u$,mat after_u$,paperlesscode)
56865 ! Changes_H     = Handle of Open Changes file (use fnOpen_Changes from Library\OpenFile) !:
        ! Active_Handle = Handle of Open Paperless file !:
        ! FileNo$       = Key to Master file for record which this entry/set of entries will apply to !:
        ! User_ID       = 3 digit User ID (pretty standard throughout system) !:
        ! mat Before_U$ = Screen 7 Field Values before modification
56870 ! mat After_U$  = Screen 7 Field Values after modification !:
        ! PaperlessCode ={1=Itemize | 2=Summarize | 0=None }
56875   dim before$*80,after$*80,changes_formall$*128,active_form$*128,paperless_desc$*80
56880   dim changes_data$(7)*60,changes_data(6)
56885   let changes_fileno=1: let changes_type=2: let changes_table_name=3: let changes_field=4: let changes_value=5: let changes_code=6 !:
        let changes_trans_type=7: let changes_trans_date=1: let changes_trans_time=2: let changes_debtor_no=3: let changes_relation=4: let changes_user_id=5: let changes_recno=6
56890   let changes_formall$=cform$("Form Pos 1,C 8,Pos 23,2*C 10,C 15,C 60,C 8,C 1,Pos 9,2*BH 4,2*N 3,Pos 127,BH 2,BH 4") !:
        let active_form$=cform$("Form Pos 1,C 8,2*BH 4,C 28,C 20,C 8,C 1,BH 2,2*BH 4,2*BH 4.2") !:
        let paperlesscode_itemize=1 : let paperlesscode_summarize=2 : let paperlesscode_none=0
56895   let trans_date=date("CCYYMMDD") !:
        let trans_time=fnstime_(time$) !:
        let type$="D" !:
        let changes_count=0
56900   for field_count=1 to udim(after_u$)
56905     let before$=trim$(before_u$(field_count)) !:
          let after$=trim$(after_u$(field_count)) !:
          let field_name$=cnvrt$("Pic(##)",field_count) !:
          let code$="U"&lpad$(str$(field_count),2,"0")
56910     if after$<>"" and before$<>"" and after$<>before$ then 
56915       let changes_count+=1
56920       if paperlesscode=paperlesscode_itemize then !:
              let paperless_desc$=before$ ! "User Field "&str$(Field_Count)&" Changed from "&Before$&" to "&After$&"."  !:
              let active_data_recno=lrec(active_handle)+1 !:
              write #active_handle,using active_form$: fileno$,trans_date,trans_time,paperless_desc$(21:48),paperless_desc$(1:20),code$,type$,user_id,0,active_data_recno,0,0
56925       let active_h_lrec=lrec(active_h)
56930       let changes_data$(changes_fileno)=fileno$ !:
            let changes_data(changes_trans_date)=trans_date !:
            let changes_data(changes_trans_time)=trans_time !:
            let changes_data(changes_debtor_no)=0 !:
            let changes_data(changes_relation)=0
56935       let changes_data$(changes_type)="" !:
            let changes_data$(changes_table_name)="USERDEF" !:
            let changes_data$(changes_field)=field_name$ !:
            let changes_data$(changes_value)=before$ !:
            let changes_data$(changes_code)=code$
56940       let changes_data$(changes_trans_type)=type$ !:
            let changes_data(changes_user_id)=user_id !:
            let changes_data(changes_recno)=active_h_lrec
56945       write #changes_h,using changes_formall$: mat changes_data$,mat changes_data
56950     end if 
56955   next field_count
56960   if paperlesscode=paperlesscode_summarize and changes_count>0 then !:
          let code$="*SCREEN7" !:
          let paperless_desc$="Screen7: "&str$(changes_count)&" Fields Changed" !:
          let active_data_recno=lrec(active_handle)+1 !:
          write #active_handle,using active_form$: fileno$,trans_date,trans_time,paperless_desc$(21:48),paperless_desc$(1:20),code$,type$,user_id,0,active_data_recno,0,0
56965 fnend 
56970 !
56975 def library fnsql2finsum(mat finsum_data$,mat finsum_data,&fileno$; &dait$,mat f_filerec,mat f_frec,mat line1,mat line2,mat daily,&refno,&atty_no,&secy_no,&coll_no,&forwr,&took,&c0de,&masco,&accrual_flag$,&comm_inv_bill,&comm_inv_paid,&sfee_inv_bill,&sfee_inv_paid,&kept_int,&bpj$,&sales_no,&status$,&subcode,&trans_time,&type$,&code$,&recno,&ta_prin,&ta_contract,&ta_legal,&line3_4,&line3_5,&line3_6,&line3_7,&line3_8,&comment$,&add_bill)
56980   if ~setup_sql then gosub SETUP_SQL
56985   mat f_filerec(20)=(0) : mat f_frec(20)=(0) : mat line1(6)=(0) : mat line2(8)=(0) : mat daily(18)=(0) !:
        let refno=forwr=took=c0de=masco=comm_inv_bill=comm_inv_paid=sfee_inv_bill=sfee_inv_paid=kept_int=sales_no=subcode=trans_time=recno=ta_prin=ta_contract=ta_legal=line3_4=line3_5=line3_6=line3_7=line3_8=add_bill=0 !:
        let fileno$=dait$=bpj$=accrual_flag$=comment$=type$=code$=status$="" !:
        let atty_no=secy_no=coll_no=sales_no=0
56990   let fileno$=finsum_data$(finsum_fileno) !:
        let dait$=finsum_data$(finsum_date) !:
        let f_filerec(1)=finsum_data(finsum_acc_orig_amt) !:
        let f_filerec(2)=finsum_data(finsum_acc_suit_amt) !:
        let f_filerec(3)=finsum_data(finsum_acc_stat_fee)
56995   let f_filerec(4)=finsum_data(finsum_acc_j_amt) !:
        let f_filerec(5)=finsum_data(finsum_acc_d1_bal) !:
        let f_filerec(6)=finsum_data(finsum_acc_cost_bal) !:
        let f_filerec(7)=finsum_data(finsum_acc_coll_hold) !:
        let f_filerec(8)=finsum_data(finsum_acc_princ_coll)
57000   let f_filerec(9)=finsum_data(finsum_acc_int_coll) !:
        let f_filerec(10)=finsum_data(finsum_acc_merch_pre) !:
        let f_filerec(11)=finsum_data(finsum_acc_merch_post) !:
        let f_filerec(12)=finsum_data(finsum_acc_dpay_pre) !:
        let f_filerec(13)=finsum_data(finsum_acc_dpay_post)
57005   let f_filerec(14)=finsum_data(finsum_acc_cost_rcvd) !:
        let f_filerec(15)=finsum_data(finsum_acc_cost_rtnd) !:
        let f_filerec(16)=finsum_data(finsum_acc_recov_exp) !:
        let f_filerec(17)=finsum_data(finsum_acc_cost_recov) !:
        let f_filerec(18)=finsum_data(finsum_cc_comm_earn)
57010   let f_filerec(19)=finsum_data(finsum_acc_sfee_earn) !:
        let f_filerec(20)=finsum_data(finsum_acc_stat_earn) !:
        let acc_int_accrued=finsum_data(finsum_acc_int_accrued) !:
        let f_frec(1)=finsum_data(finsum_acc_cost_jdg) !:
        let f_frec(2)=finsum_data(finsum_acc_aff_amt)
57015   let f_frec(3)=finsum_data(finsum_acc_dpay_pstjdg) !:
        let f_frec(4)=finsum_data(finsum_acc_non_rec_exp) !:
        let f_frec(5)=finsum_data(finsum_acc_tot_cst_exp) !:
        let f_frec(6)=finsum_data(finsum_acc_dp_nfee_pre) !:
        let f_frec(7)=finsum_data(finsum_acc_dp_nfee_pst)
57020   let f_frec(8)=finsum_data(finsum_acc_dp_nfee_jdg) !:
        let f_frec(9)=finsum_data(finsum_acc_merch_jdg) !:
        let f_frec(10)=finsum_data(finsum_acc_firm_cost) !:
        let f_frec(11)=finsum_data(finsum_acc_dp_pre_suit) !:
        let f_frec(12)=finsum_data(finsum_acc_dp_suit)
57025   let f_frec(13)=finsum_data(finsum_acc_dp_post_jdg) !:
        let f_frec(14)=finsum_data(finsum_acc_pre_jdg_int) !:
        let f_frec(15)=finsum_data(finsum_acc_cst_rtn_dp) !:
        let f_frec(16)=finsum_data(finsum_acc_coco_pre) !:
        let f_frec(17)=finsum_data(finsum_acc_coco_post)
57030   let f_frec(18)=finsum_data(finsum_acc_coco_jdg) !:
        let f_frec(19)=finsum_data(finsum_acc_cst_to_coco) !:
        let f_frec(20)=finsum_data(finsum_acc_sales_tax) !:
        let line1(1)=finsum_data(finsum_ta_firm_coll) !:
        let line1(2)=finsum_data(finsum_ta_cost_recov)
57035   let line1(3)=finsum_data(finsum_ta_stat_fee) !:
        let line1(4)=finsum_data(finsum_ta_net_client) !:
        let line1(5)=finsum_data(finsum_ta_d1_balance) !:
        let line1(6)=finsum_data(finsum_ta_amt_recvd) !:
        let line2(1)=finsum_data(finsum_ta_prin_coll)
57040   let line2(2)=finsum_data(finsum_ta_int_coll) !:
        let line2(3)=finsum_data(finsum_ta_cumm_coll) !:
        let line2(4)=finsum_data(finsum_ta_cost_refund) !:
        let line2(5)=finsum_data(finsum_ta_cost_inc) !:
        let line2(6)=finsum_data(finsum_ta_cost_recv)
57045   let line2(7)=finsum_data(finsum_ta_sfee_earn) !:
        let line2(8)=finsum_data(finsum_ta_comm_earn) !:
        let daily(1)=finsum_data(finsum_eod_refno) !:
        let daily(2)=finsum_data(finsum_eod_amt_rcv) !:
        let daily(3)=finsum_data(finsum_eod_comm_earned)
57050   let daily(4)=finsum_data(finsum_eod_suit_fee) !:
        let daily(5)=finsum_data(finsum_eod_stat_fees) !:
        let daily(6)=finsum_data(finsum_eod_net_client) !:
        let daily(7)=finsum_data(finsum_eod_costs_recov) !:
        let daily(8)=finsum_data(finsum_eod_costs_disb)
57055   let daily(9)=finsum_data(finsum_eod_costs_ret) !:
        let daily(10)=finsum_data(finsum_eod_misc_cost) !:
        let daily(11)=finsum_data(finsum_eod_adjust) !:
        let daily(12)=finsum_data(finsum_eod_collhold) !:
        let daily(13)=finsum_data(finsum_eod_remithold)
57060   let daily(14)=finsum_data(finsum_eod_ret_net_rec) !:
        let daily(15)=finsum_data(finsum_eod_ret_costs) !:
        let daily(16)=finsum_data(finsum_eod_ret_earn) !:
        let daily(17)=finsum_data(finsum_eod_check_amt) !:
        let daily(18)=finsum_data(finsum_eod_sales_tax)
57065   let refno=finsum_data(finsum_ta_chk_no) !:
        let atty_no=(finsum_data(finsum_atty_no)) !:
        let secy_no=(finsum_data(finsum_secy_no)) !:
        let coll_no=(finsum_data(finsum_coll_no)) !:
        let forwr=finsum_data(finsum_forw_no)
57070   let took=finsum_data(finsum_withheld_agent) !:
        let c0de=finsum_data(finsum_trans_code) !:
        let masco=finsum_data(finsum_coco_no) !:
        let accrual_flag$=finsum_data$(finsum_filler1) !:
        let comm_inv_bill=finsum_data(finsum_comm_cst_billed)
57075   let comm_inv_paid=finsum_data(finsum_comm_cst_inv_pd) !:
        let sfee_inv_bill=finsum_data(finsum_comm_fee_billed) !:
        let sfee_inv_paid=finsum_data(finsum_comm_fee_inv_pd) !:
        let kept_int=finsum_data(finsum_interest_kept) !:
        let bpj$=finsum_data$(finsum_bpj)
57080   let sales_no=finsum_data(finsum_sales_no) !:
        let status$=finsum_data$(finsum_status) !:
        let subcode=finsum_data(finsum_subcode) !:
        let trans_time=finsum_data(finsum_trans_time) !:
        let type$=finsum_data$(finsum_type)
57085   let code$=finsum_data$(finsum_code) !:
        let recno=finsum_data(finsum_recno) !:
        let ta_prin=finsum_data(finsum_ta_prin) !:
        let ta_contract=finsum_data(finsum_ta_contract) !:
        let ta_legal=finsum_data(finsum_ta_legal)
57090   let line3_4=finsum_data(finsum_line3_4) !:
        let line3_5=finsum_data(finsum_line3_5) !:
        let line3_6=finsum_data(finsum_line3_6) !:
        let line3_7=finsum_data(finsum_line3_7) !:
        let line3_8=finsum_data(finsum_line3_8)
57095   let comment$=finsum_data$(finsum_comment) !:
        let add_bill=finsum_data(finsum_add_bill)
57100 fnend 
57110 !
57115 def library fnxbyst$(st$,date_jdg$)
57120 ! This function looks a a number from StJdgDt.ini//8 or Custom\*.* and adds it (as Years) to the Date_Jdg$ and returns that. !:
        ! ST$ is a two letter state designation (not case sensitive) !:
        ! Date_Jdg$ is a date in either CCYYMMDD format or YYMMDD format.  Other formats are not supported!!! !:
        ! if the state is not found, than a DEFAULT of 7 YEARS will be added to the date.
57125   dim xbyst_st$(1),xbyst_addyear(1),common_line$(1)*80,custom_line$(1)*80,custom_field$(1),common_field$(1)
57130   if trim$(date_jdg$)="" then let set_fnxbyst$="" : goto XIT_FNXBYST
57135   let date_jdg$=fndate10_$(date_jdg$)
57140   let set_fnxbyst$=date_jdg$ !:
        let st$=uprc$(trim$(st$))
57145   if ~xbyst_setup then 
57150 ! add Common Table
57155     let ini_delimiter$=chr$(9) : mat xbyst_st$(0) : mat xbyst_addyear(0)
57160     if exists("StJdgDt.ini//8") then 
57165       let fnasci_("StJdgDt.ini//8",mat common_line$)
57170       for line_count=1 to udim(common_line$)
57175         let fnparse_csv_(common_line$(line_count),mat common_field$,ini_delimiter$)
57180         mat common_field$(2) !:
              if trim$(common_field$(2))="" then !:
                let common_field$(2)="7"
57185         mat xbyst_st$(udim(xbyst_st$)+1) : let xbyst_st$(udim(xbyst_st$))=common_field$(1) !:
              mat xbyst_addyear(udim(xbyst_addyear)+1) : let xbyst_addyear(udim(xbyst_addyear))=fnval_(common_field$(2))
57190       next line_count
57195     end if 
57200     if exists("Custom\StJdgDt.ini") then 
57205 ! add Custom Table
57210       let fnasci_("Custom\StJdgDt.ini",mat custom_line$)
57215       for line_count=1 to udim(custom_line$)
57220         let fnparse_csv_(custom_line$(line_count),mat custom_field$,ini_delimiter$) !:
              mat custom_field$(2)
57225         let rightone=srch(mat xbyst_st$,custom_field$(1))
57230         if rightone<=0 then 
57235 ! if it's not there add it
57240           mat xbyst_st$(udim(xbyst_st$)+1) : let xbyst_st$(udim(xbyst_st$))=custom_field$(1) !:
                mat xbyst_addyear(udim(xbyst_addyear)+1) : let xbyst_addyear(udim(xbyst_addyear))=fnval_(custom_field$(2))
57245         else 
57250 ! it is there, update it
57255           let xbyst_st$(rightone)=custom_field$(1) !:
                let xbyst_addyear(rightone)=fnval_(custom_field$(2))
57260         end if 
57265       next line_count
57270     end if 
57275     let xbyst_setup=1
57280   end if  ! (XbyST_Setup)
57285 ! pause
57290   let rightone=srch(mat xbyst_st$,st$)
57295   if rightone<=0 then 
57300 ! it's not there, so default to 7 years
57305     let rightone=udim(xbyst_st$)+1
57310     mat xbyst_st$(rightone) : let xbyst_st$(rightone)=st$ !:
          mat xbyst_addyear(rightone) : let xbyst_addyear(rightone)=7
57315   end if 
57320   let ccyy=val(date_jdg$(1:4))+xbyst_addyear(rightone)
57325   let set_fnxbyst$=cnvrt$("Pic(####)",ccyy)&date_jdg$(5:len(date_jdg$))
57330 XIT_FNXBYST: ! 
57335   if set_fnxbyst$(5:10)="/02/29" and fndate10_$(set_fnxbyst$)="" then !:
          let set_fnxbyst$(5:10)="/02/28"
57340   let fnxbyst$=set_fnxbyst$
57345 fnend 
57350 !
57355 def library fnis_holiday(d)
57360   mat holidays(12)
57365   let year$=fndate10_$(str$(d))(1:4)
57370   let start$=year$&"0101"
57375   let holidays(1)=fndate10_(start$)
57380   let start=days(holidays(1))-1
57385 ! 3rd Monday in Jan = Martin Luther King
57390   let _monday=0
57395   do until _monday=3
57400     if fndow_(date(start+=1))=2 then let _monday+=1
57405   loop 
57410   let holidays(2)=date(start,"CCYYMMDD")
57415   let start$=year$&"0201"
57420   let start=days(val(start$))-1
57425 ! 3rd Monday in Feb = President's day
57430   let _monday=0
57435   do until _monday=3
57440     if fndow_(date(start+=1))=2 then let _monday+=1
57445   loop 
57450   let holidays(3)=date(start,"CCYYMMDD")
57455   let start$=year$&"0601"
57460   let start=days(val(start$))
57465 ! Last Monday in May = Memorial Day
57470   let _monday=0
57475   do until _monday=1
57480     if fndow_(date(start-=1))=2 then let _monday+=1
57485   loop 
57490   let holidays(4)=date(start,"CCYYMMDD")
57495   let start$=year$&"0704"
57500   let start=days(val(start$))
57505   let holidays(5)=date(start,"CCYYMMDD")
57510   let start$=year$&"0901"
57515   let start=days(val(start$))-1
57520 ! 1st Monday in Sep = Labor Day
57525   let _monday=0
57530   do until _monday=1
57535     if fndow_(date(start+=1))=2 then let _monday+=1
57540   loop 
57545   let holidays(6)=date(start,"CCYYMMDD")
57550   let start$=year$&"1111"
57555   let start=days(val(start$))
57560   let holidays(7)=date(start,"CCYYMMDD")
57565   let start$=year$&"1101"
57570   let start=days(val(start$))-1
57575 ! 4th Thursday in Nov = Thanksgiving
57580   let _thursday=0
57585   do until _thursday=4
57590     if fndow_(date(start+=1))=5 then let _thursday+=1
57595   loop 
57600   let holidays(8)=date(start,"CCYYMMDD")
57605   let holidays(9)=date(start+1,"CCYYMMDD")
57610   let start$=year$&"1224"
57615   let start=days(val(start$))
57620   let holidays(10)=date(start,"CCYYMMDD")
57625   let holidays(11)=date(start+1,"CCYYMMDD")
57630   let holidays(12)=date(start+7,"CCYYMMDD")
57635   if srch(holidays,d)>0 then let fnis_holiday=1 !:
        else let fnis_holiday=0
57640 fnend 
57650 !
57652 def library fnchanges(changes_handle,active_handle,trans_date,trans_time,fileno$,debtor_no,relation,type$,changes_code$,changes_desc$*11,user_id,recno,mat before_data$,mat before_data,mat after_data$,mat after_data,mat fieldsc$,mat fieldsn$,table_name$,account)
57654   let fnchanges=fnchanges_(changes_handle,active_handle,trans_date,trans_time,fileno$,debtor_no,relation,type$,changes_code$,changes_desc$,user_id,recno,mat before_data$,mat before_data,mat after_data$,mat after_data,mat fieldsc$,mat fieldsn$,table_name$,account)
57656 fnend 
57660 FNCHANGE: ! ___________________________________________________________
57662 def library fnchange(c1_changes_handle,c1_active_handle,c1_trans_date,c1_trans_time,c1_fileno$*8,c1_debtor_no,c1_relation,c1_type$*10,c1_changes_code$*8,c1_changes_desc$*11,c1_user_id,c1_recno,c1_before_data$*80,c1_before_data,c1_after_data$*80,c1_after_data,c1_field_c$*20,c1_field_n$*20,c1_table_name$*11,c1_account)
57664   let fnchange=fn_change(c1_changes_handle,c1_active_handle,c1_trans_date,c1_trans_time,c1_fileno$,c1_debtor_no,c1_relation,c1_type$,c1_changes_code$,c1_changes_desc$,c1_user_id,c1_recno,c1_before_data$,c1_before_data,c1_after_data$,c1_after_data,c1_field_c$,c1_field_n$,c1_table_name$,c1_account)
57666 fnend  ! Fn_Change
57670 def fn_change(c1_changes_handle,c1_active_handle,c1_trans_date,c1_trans_time,c1_fileno$*8,c1_debtor_no,c1_relation,c1_type$*10,c1_changes_code$*8,c1_changes_desc$*11,c1_user_id,c1_recno,c1_before_data$*80,c1_before_data,c1_after_data$*80,c1_after_data,c1_field_c$*20,c1_field_n$*20,c1_table_name$*11,c1_account) ! C1_
57672 ! Fn_Change is to uses fnchanges for just one field in the simplest way possible
57674   let c1_field_c$=uprc$(trim$(c1_field_c$)) !:
        let c1_field_n$=uprc$(trim$(c1_field_n$)) !:
        let c1_return=fnchanges_(c1_changes_handle,c1_active_handle,c1_trans_date,c1_trans_time,c1_fileno$,c1_debtor_no,c1_relation,c1_type$,c1_changes_code$,c1_changes_desc$,c1_user_id,c1_recno,c1_before_data$,c1_before_data,c1_after_data$,c1_after_data,c1_field_c$,c1_field_n$,c1_table_name$,c1_account)
57676   let fn_change=c1_return
57678 fnend  ! Fn_Change
57680 def library fnichanges(ichanges_handle,internal_file_number,internal_handle,relation,type$,changes_code$,changes_desc$*11,mat old_internal_data$,mat old_internal_data,mat internal_data$,mat internal_data,mat internal_fieldsc$,mat internal_fieldsn$; recno,user_id,trans_date,trans_time)
57685   let fnfc_menu(mat internal_table_name$,mat internal_table_desc$)
57690   if user_id=0 then let user_id=fnget_user
57695   if trans_date=0 then let trans_date=date("CCYYMMDD")
57700   if trans_time=0 then let trans_time=fnstime_(time$)
57705   if recno=0 then let recno=rec(internal_handle)
57710   if recno=0 and file(internal_file_number)=-1 then !:
          print 'Invalid call to fnChanges - RecNo=0 and the INTERNAL_FILE_NUMBER passed is not even open' : pause  !:
        else !:
          if recno=0 then print 'Invalid call to fnIChanges - RecNo=0' : pause 
57715   let fnchanges_(ichanges_handle,active_handle=0,trans_date,trans_time,cnvrt$("PIC(########)",recno),debt_number=0,internal_file_number,type$,changes_code$,changes_desc$,user_id,recno,mat old_internal_data$,mat old_internal_data,mat internal_data$,mat internal_data,mat internal_fieldsc$,mat internal_fieldsn$,internal_table_name$(internal_file_number),account=1)
57720 fnend 
57730 !
57735 def library fnthere(there_text$*256, there_file$*256; allow_partial_match)
57740 ! 
57745 ! There_Text$ = the text to search for !:
        ! There_File$ = the file to search !:
        ! allow_partial_match = 0 means whole line matches only =1 means allow partial matches (ie 10 is a partial match with 203102) !:
        ! this search is always case insensitive, and always ignores begining and trailing white space.
57750   let there_text$=lwrc$(trim$(there_text$))
57755   dim hold_there_file$*256,there_line$(1)*512,hold_there_line$(1)*512
57760   if uprc$(trim$(hold_there_file$))=uprc$(trim$(there_file$)) then 
57765 ! print 'using cached information rather than re-reading it'
57770     mat there_line$(udim(hold_there_line$))=hold_there_line$
57775   else 
57780 ! print 'reading the file - not cached'
57785     let fnasci_(there_file$,mat there_line$) !:
          for j=1 to udim(there_line$) : let there_line$(j)=lwrc$(trim$(there_line$(j))) : next j !:
          mat hold_there_line$(udim(there_line$))=there_line$ !:
          let hold_there_file$=there_file$
57790   end if 
57795   if allow_partial_match=1 then 
57800 ! print 'partial match allowed'
57805     for there_count=1 to udim(there_line$)
57810       if pos(lwrc$(there_line$(there_count)),there_text$)>0 then ! print 'YEAH' !:
              goto THERE_FOUNDIT
57815     next there_count
57820 ! print 'NEIGH' !:
          goto THERE_NO_FOUNDIT
57825   else 
57830 ! print 'NO partial matches allowed'
57835     if srch(there_line$,there_text$)>0 then goto THERE_FOUNDIT else goto THERE_NO_FOUNDIT
57840   end if 
57845 THERE_FOUNDIT: ! 
57850 ! print '__found it'
57855   let setfnthere=1 : goto THERE_XIT
57860 THERE_NO_FOUNDIT: ! 
57865 ! print '__found it NOT'
57870   let setfnthere=0 : goto THERE_XIT
57875 THERE_XIT: ! 
57880   let fnthere=setfnthere
57885 fnend 
57890 !
57895 def library fntheren(theren_text, theren_file$*256; allow_partial_match)
57900 ! 
57905 ! THEREN_Text = the number to search for !:
        ! THEREN_File$ = the file to search !:
        ! allow_partial_match = 0 means whole line matches only =1 means allow partial matches (ie 10 is a partial match with 203102) !:
        ! this search is always case insensitive, and always ignores begining and trailing white space.
57910   let theren_text$=str$(theren_text)
57915   dim hold_theren_file$*256,theren_line$(1)*512,hold_theren_line$(1)*512
57920   if uprc$(trim$(hold_theren_file$))=uprc$(trim$(theren_file$)) then 
57925 ! print 'using cached information rather than re-reading it'
57930     mat theren_line$(udim(hold_theren_line$))=hold_theren_line$
57935   else 
57940 ! print 'reading the file - not cached'
57945     let fnasci_(theren_file$,mat theren_line$) !:
          for j=1 to udim(theren_line$) : let theren_line$(j)=lwrc$(trim$(theren_line$(j))) : next j !:
          mat hold_theren_line$(udim(theren_line$))=theren_line$ !:
          let hold_theren_file$=theren_file$
57950   end if 
57955   if allow_partial_match=1 then 
57960 ! print 'partial match allowed'
57965     for theren_count=1 to udim(theren_line$)
57970       if pos(lwrc$(theren_line$(theren_count)),theren_text$)>0 then ! print 'YEAH' !:
              goto THEREN_FOUNDIT
57975     next theren_count
57980 ! print 'NEIGH' !:
          goto THEREN_NO_FOUNDIT
57985   else 
57990 ! print 'NO partial matches allowed'
57995     if srch(theren_line$,theren_text$)>0 then goto THEREN_FOUNDIT else goto THEREN_NO_FOUNDIT
58000   end if 
58005 THEREN_FOUNDIT: ! 
58010 ! print '__found it'
58015   let setfnthere=1 : goto THEREN_XIT
58020 THEREN_NO_FOUNDIT: ! 
58025 ! print '__found it NOT'
58030   let setfnthere=0 : goto THEREN_XIT
58035 THEREN_XIT: ! 
58040   let fntheren=setfnthere
58045 fnend 
58050 !
58060 def library fnread_screen7(mastorhist,key$*8,mat data$; userdefint)
58062   let fnread_screen7=fnreadscreen7(mastorhist,key$,mat data$, userdefint)
58064 fnend 
58070 def fnreadscreen7(mastorhist,key$*8,mat data$; userdefint)
58075 ! requires fnGetHandle
58080 ! UserDefInt - Handle of Open UserDef.Int !:
        ! MastOrHist - Handle of Open Master (or History) file with File Number index !:
        ! Key$ - FileNumber !:
        ! mat Data$ - read Data returned !:
        ! the Function itself returns a -1 if NoKey
58085   if ~userdefint then 
58090     open #userdefint_handle:=fngethandle_: "Name=UserDef.Int//6,KFName=UserDef.Idx//6,Shr",internal,outin,keyed 
58095   else 
58100     let userdefint_handle=userdefint
58105   end if 
58110   let setfnreadscreen7=0
58115   let fileno$="" : mat data$=("") : let key$=rpad$(key$,kln(mastorhist))
58120   if ~screen7_setup then 
58125     dim field_pos$(1)*32,field_type$(1)*8,fhelp$*1024,formr$*1024
58130     open #userdeffil_h:=fngethandle_: "Name=UserDef.Fil//9",internal,input,relative 
58135 FORM_USERDEFFIL: form pos 1,b 4,datar*v 32,datar*v 8,v 1024,v 1024
58140     read #userdeffil_h,using FORM_USERDEFFIL,rec=1,release: datar
58145     mat field_pos$(datar)=("") : mat field_type$(datar)=("") : mat data$(datar)=("")
58150     read #userdeffil_h,using FORM_USERDEFFIL,rec=1,release: datar,mat field_pos$,mat field_type$,fhelp$,formr$
58155     close #userdeffil_h: 
58160     let screen7_setup=1
58165   end if 
58170 READ_FNREADSCREEN7: ! 
58175   read #userdefint_handle,using formr$, key=key$: fileno$,mat data$ nokey NEWREC_FNREADSCREEN7
58180   goto XIT_FNREADSCREEN7
58185 NOKEY_FNREADSCREEN7: ! else report an Error
58190   let setfnreadscreen7=-1
58195   goto XIT_FNREADSCREEN7
58200 NEWREC_FNREADSCREEN7: ! 
58205   read #mastorhist,key=key$,release: nokey NOKEY_FNREADSCREEN7 ! don't add if it doesn't exist
58210   write #userdefint_handle, using formr$: key$, mat data$ error NOKEY_FNREADSCREEN7 ! write the new file so that READ_UserDefInt recognizes it
58215   goto READ_FNREADSCREEN7
58220 XIT_FNREADSCREEN7: ! 
58225   if userdefint=0 then close #userdefint_handle: 
58230   let fnreadscreen7=setfnreadscreen7
58235 fnend 
58240 ! ___________________ fnMyDoc$ _________________________________________
58245 def library fnmydoc$*256
58250   dim mydoc_temp$*256, mydoc_cached$*256
58255   if mydoc_cached$="" then 
58260     if uprc$(env$("CLIENT_SERVER"))="YES" then 
58261       let mydoc_temp$="N:" !:
            if exists("@::"&trim$(fn_client_env$("UserProfile"))&"\Documents\")=1 then !:
              let mydoc_temp$="@::"&trim$(fn_client_env$("UserProfile"))&"\Documents\" else !:
              if exists("@::"&trim$(fn_client_env$("UserProfile"))&"\My Documents\")=1 then !:
                let mydoc_temp$="@::"&trim$(fn_client_env$("UserProfile"))&"\My Documents\"
58262     else 
58263       let mydoc_temp$="N:" !:
            if exists(trim$(env$("UserProfile"))&"\Documents\")=1 then !:
              let mydoc_temp$=trim$(env$("UserProfile"))&"\Documents\" else !:
              if exists(trim$(env$("UserProfile"))&"\My Documents\")=1 then !:
                let mydoc_temp$=trim$(env$("UserProfile"))&"\My Documents\"
58264     end if  ! myDoc_Cached!
58265     let mydoc_cached$=mydoc_temp$ !:
          if pos(mydoc_cached$," ")>0 then !:
            let mydoc_cached$=fngetshortname$(mydoc_temp$,"",yes=1)
58270     open #mydoctest_handle:=fngethandle_: "Name="&mydoc_cached$&"Kill-"&session$&".$$$,Replace",display,output ioerr MYDOCTEST_FAILURE
58275     close #mydoctest_handle,free: 
58280   end if 
58285 ! if LEN(MYDOC_CACHED$)>53 THEN GOTO MYDOCTEST_FAILURE ! 53=66(max path length)-12(8.3 file name to be added still)-1(slash between previous two) ! expanded to 256
58290   goto MYDOCTEST_XIT
58295 MYDOCTEST_FAILURE: ! 
58300   let mydoc_cached$="N:"
58305   goto MYDOCTEST_XIT
58310 MYDOCTEST_XIT: ! 
58315   let fnmydoc$=mydoc_cached$
58320 fnend 
58330 def library fnremove_arrayitem$(mat x$,remove_this_item)
58332   let fnremove_arrayitem$=fnremovearrayitem$(mat x$,remove_this_item)
58334 fnend 
58336 def fnremovearrayitem$(mat x$,remove_this_item)
58338   if remove_this_item=udim(x$) then 
58340     mat x$(remove_this_item-1)
58342   else 
58344     mat x$(remove_this_item:udim(x$)-1)=x$(remove_this_item+1:udim(x$))
58346     mat x$(udim(x$)-1)
58348   end if 
58350 fnend 
58360 ! __________________________________________
58362 def library fnremove_arrayitem(mat x,remove_this_item)
58364   let fnremove_arrayitem=fnremovearrayitem(mat x,remove_this_item)
58366 fnend 
58370 def fnremovearrayitem(mat x,remove_this_item)
58372   if remove_this_item=udim(x) then 
58374     mat x(remove_this_item-1)
58376   else 
58378     mat x(remove_this_item:udim(x)-1)=x(remove_this_item+1:udim(x))
58380     mat x(udim(x)-1)
58382   end if 
58384 fnend 
58390 !
58392 def library fnquote$*1024(in$*1024)
58394   let fnquote$=fnquote_$(in$)
58396 fnend 
58400 def fnquote_$*1024(in$*1024)
58405 ! safely encapsulate data within quotes
58410   let quote_char$='"' !:
        let other_quote_char$="'"
58415   if pos(in$,quote_char$)>0 then !:
          let quote_char$="'" !:
          let other_quote_char$='"'
58420   let in$=srep$(in$,quote_char$,other_quote_char$) ! remove bad qoutes (")
58425   let fnquote_$=quote_char$&trim$(in$)&quote_char$
58430 fnend 
58440 def library fnmenu_autonumber(mat ma_menu_option$; ma_delimiter$)
58442   let fnmenu_autonumber=fn_menu_autonumber(mat ma_menu_option$, ma_delimiter$)
58444 fnend  ! FnMenu_Autonumber
58450 def fn_menu_autonumber(mat ma_menu_option$; ma_delimiter$)
58455 ! shares local: G_Use_Fnmenu2
58460   let ma_menu_option_count=udim(mat ma_menu_option$)
58465   if ma_delimiter$='' then let ma_delimiter$="."
58470   if g_use_fnmenu2 then 
58475     let ma_menu_option_len=len(str$(udim(mat ma_menu_option$)))
58480     if ma_menu_option_count<=35 then 
58485       let ma_menu_option_len=0
58490     end if  ! Ma_Menu_Option_Count<=35
58495   else 
58500     let ma_menu_option_len=1
58505   end if  ! G_Use_Fnmenu2   /   else 
58510   for ma_menu_option_item=1 to ma_menu_option_count
58515     if ma_menu_option_item=ma_menu_option_count and uprc$(trim$(ma_menu_option$(ma_menu_option_item)))="CANCEL" or uprc$(trim$(ma_menu_option$(ma_menu_option_item)))(1:10)="RETURN TO " then 
58520       let ma_menu_option$(ma_menu_option_item)(0:0)=rpt$(" ",ma_menu_option_len-1)&"0"&ma_delimiter$&" "
58525     else 
58530       if g_use_fnmenu2 then 
58535         let ma_menu_option$(ma_menu_option_item)(0:0)=fnmitem_$(ma_menu_option_item,ma_menu_option_len)&ma_delimiter$&" "
58540       else 
58545         let ma_menu_option$(ma_menu_option_item)(0:0)=fnmitem_$(ma_menu_option_item,0)&ma_delimiter$&" "
58550       end if  ! G_Use_Fnmenu2
58555     end if  ! Ma_Menu_Option_Item=Ma_Menu_Option_Count And Uprc$(Trim$(Ma_Menu_Option$(Ma_Menu_Option_Item)))="CANCEL" Or Uprc$(Trim$(Ma_Menu_Option$(Ma_Menu_Option_Item)))(1:10)="RETURN TO "
58560   next ma_menu_option_item
58565   let fn_menu_autonumber=ma_menu_option_len
58570 fnend  ! Fn_Menu_Autonumber
58580 def library fngui_pr$(screen$*160,scrn$*80;gui_handle)
58582   let fngui_pr$=fngui_print_$(screen$,scrn$,gui_handle)
58584 fnend 
58590 def library fngui_print$(mat screen$,mat scrn$;gui_handle)
58592   let fngui_print$=fngui_print_$(mat screen$,mat scrn$,gui_handle)
58594 fnend 
58600 def fngui_print_$(mat screen$,mat scrn$;gui_handle)
58605   dim gui_screen$(1)*160,gui_scrn$(1)*32,scrn$*32,screen$*160,gui_screen$*160,gui_scrn$*32,gui_lines$*160
58610   if ~xlate_setup then let fnxlate_setup
58615 ! mat SCREEN$ contains the screen information to be displayed !:
        ! mat SCRN$ contains the FORM STATEMENTS TO BE USED
58620   if udim(mat scrn$)=10 and trim$(scrn$(10))="" then 
58625     for j=9 to 2 step -1
58630       if trim$(scrn$(j))="" then mat scrn$(j-1) : mat screen$(j-1)
58635     next j
58640   end if 
58645   if env$("GUIMODE")="OFF" then !:
          print #gui_handle,fields mat scrn$: mat screen$ !:
          goto L58850
58650   let gui_screen=0
58655   for nline=1 to udim(screen$)
58660     let screen$=screen$(nline) !:
          let scrn$=scrn$(nline)
58665 RESCAN_LINE: let first_gui_type=0: let first_gui_pos=len(screen$)+1
58670     let npos1=pos(scrn$,",") !:
          let npos2=pos(scrn$,",",npos1+1) !:
          let npos3=pos(scrn$,'['): let npos4=pos(scrn$,']',npos3+1) !:
          let scrn_attr$='[W]'
58675     if npos3>0 then let scrn_attr$=scrn$(npos3:99)
58680     let yline=val(scrn$(1:npos1-1)) !:
          let xline=val(scrn$(npos1+1:npos2-1))
58685     if yline=0 or xline=0 then !:
            let fnmessagebox_("Warning, SCRN$ contains:"&scrn$,64,"Check FNGUI_PRINT$ for syntax") !:
            let yline=max(yline,1): let xline=max(xline,1)
58690 ! if TRIM$(SCREEN$)="" THEN GOTO 1900 !:
          ! ** if There is nothing to display, then just skip it!
58695 SCAN_LINE: let nleft_bracket=pos(screen$,"[") !:
          let ncolon=pos(screen$,":")
58700     let nlines=0 !:
          let ncount=0
58705     let gui_lines$ = xlate$(screen$, spec_char_xlate$) !:
          let nlines=pos(gui_lines$,"*")
58710     if nlines>0 and nlines<first_gui_pos then !:
            let first_gui_type=1: let first_gui_pos=nlines
58715     if ncolon>0 and ncolon<first_gui_pos then !:
            let first_gui_type=2: let first_gui_pos=ncolon
58720     if nleft_bracket>0 and nleft_bracket<first_gui_pos then !:
            let first_gui_type=3: let first_gui_pos=nleft_bracket
58725     if first_gui_pos<>1 and first_gui_pos<>ncolon then !:
            let first_gui_type=99 !:
            ! if THERE ARE "NORMAL CHARACTERS" BEFORE THE SPECIAL ONE !:
            ! PROCESS THE NORMAL FIRST!
58730     on first_gui_type+1 goto NOGUI,LINES,COLON,LEFT_BRACKET none NORMAL
58735 NOGUI: let gui_screen+=1 !:
          mat gui_screen$(gui_screen): mat gui_scrn$(gui_screen) !:
          let gui_screen$(gui_screen)=screen$ !:
          let gui_scrn$(gui_screen)=scrn$ !:
          goto L58840
58740 LINES: let last_gui_pos=len(screen$)
58745     let gui_lines$ = xlate$(screen$, spec_char_xlate$)
58750     let nlast_count=nlines+1
58755     let gui_lines$ = xlate$(screen$, spec_char_xlate$) !:
          let nlast_count=pos(gui_lines$," ")-1 !:
          if nlast_count>0 then let last_gui_pos=nlast_count
58760 ! LET GUI_SCREEN$(GUI_SCREEN)="ICONS\COMBAR.JPG"
58765     let gui_len=last_gui_pos-first_gui_pos+1 !:
          let fnnext_field(screen$(first_gui_pos:last_gui_pos),str$(yline)&","&str$(xline)&",C "&str$(gui_len)&",[W]") !:
          ! LET GUI_SCRN$(GUI_SCREEN)=STR$(YLINE)&","&STR$(XLINE)&",P 1/"&STR$(GUI_LEN)&",[W]"
58770     goto RESCAN_LINE
58775 COLON: let last_gui_pos=first_gui_pos !:
          let first_gui_pos=1 !:
          ! Having found a Colon, Treat the entire "SCREEN$" as a screen label, right justify at the ":" !:
          ! ** Option 39
58780     let nspace_colon=pos(screen$(1:last_gui_pos),":") !:
          if nspace_colon>0 then !:
            let screen$(1:last_gui_pos)=rpad$(lpad$(trim$(srep$(screen$(1:last_gui_pos),":",""))&":",nspace_colon),last_gui_pos) !:
            ! ** Remove The Gap Between the ":" and the Label !:
            ! Then Right Align the text, so the ":" is Right Justified
58785     let gui_len=last_gui_pos-first_gui_pos+1 !:
          let fnnext_field(screen$(1:last_gui_pos),str$(yline)&","&str$(xline)&",CR "&str$(gui_len)&",[W]")
58790     goto RESCAN_LINE
58795 LEFT_BRACKET: let last_gui_pos=len(screen$) !:
          let nright_bracket=pos(screen$,"]") !:
          if nright_bracket>0 then let last_gui_pos=nright_bracket
58800     let gui_screen$=trim$(screen$(first_gui_pos:last_gui_pos)) !:
          let gui_screen$=srep$(gui_screen$,"[","") !:
          let gui_screen$=srep$(gui_screen$,"[","") !:
          let gui_screen$=srep$(gui_screen$,"]","")
58805     let gui_len=last_gui_pos-first_gui_pos+1 !:
          let fnnext_field(gui_screen$,str$(yline)&","&str$(xline)&",CC "&str$(gui_len)&",[N]")
58810     goto RESCAN_LINE
58815 NORMAL: ! THERE IS NORMAL TEXT BEFORE A GUI ENTRY!
58820     let last_gui_pos=first_gui_pos-1 !:
          let first_gui_pos=1
58825     let gui_len=last_gui_pos-first_gui_pos+1 !:
          let fnnext_field(rtrm$(screen$(first_gui_pos:last_gui_pos)),str$(yline)&","&str$(xline)&",C "&str$(gui_len)&","&scrn_attr$)
58830 ! 
58835     goto RESCAN_LINE
58840 L58840: next nline
58845   if gui_screen>0 then !:
          print #gui_handle,fields mat gui_scrn$: mat gui_screen$
58850 L58850: fnend 
58860 def fnnext_field(next_screen$*180,next_scrn$*32)
58865   if trim$(next_scrn$)="" then pause 
58870   let gui_screen+=1 !:
        mat gui_screen$(gui_screen): mat gui_scrn$(gui_screen) !:
        let gui_screen$(gui_screen)=next_screen$ !:
        let gui_scrn$(gui_screen)=next_scrn$
58875   let gui_new_len=max(len(screen$)-gui_len,1) !:
        let scrn$=str$(yline)&","&str$(xline+gui_len)&",C "&str$(gui_new_len)&","&scrn_attr$ !:
        let screen$(first_gui_pos:last_gui_pos)=""
58880 fnend 
58890 def library fnpap_date$*10(active_handle, fileno$, pf_code$; search_up_or_down)
58895   if pap_date_active_form$="" then let pap_date_active_form$=cform$("Form Pos 1,C 8,BH 4,Pos 65,C 8")
58900   let set_fnpap_date=0
58905   let fileno$=rpad$(trim$(fileno$),8)
58910   let pf_code$=uprc$(trim$(pf_code$))
58915   if search_up_or_down=-1 then ! search down (from end of matching filenos)
58920     let fileno_above$=fileno$(1:7)&chr$(ord(fileno$(8:8))+1)
58925     read #active_handle,using pap_date_active_form$,search>=fileno_above$,release: pfileno$,pdate,pcode$ nokey PD_RESTORE_LAST
58930 !   let pcode$=uprc$(trim$(pcode$))
58935     do 
58940       if pfileno$=fileno$ and pcode$=pf_code$ then let set_fnpap_date=pdate
58945       read #active_handle,using pap_date_active_form$,prior,release: pfileno$,pdate,pcode$ eof PAP_DATE_XIT
58950       let pcode$=uprc$(trim$(pcode$))
58955     loop until pfileno$<>fileno$ or set_fnpap_date<>0
58960   else ! search up (from beginning of matching filenos)
58965     read #active_handle,using pap_date_active_form$,key=fileno$,release: pfileno$,pdate,pcode$ nokey PAP_DATE_XIT
58970     let pcode$=uprc$(trim$(pcode$))
58975     do until pfileno$<>fileno$ or set_fnpap_date<>0
58980       if pfileno$=fileno$ and pcode$=pf_code$ then let set_fnpap_date=pdate
58985       read #active_handle,using pap_date_active_form$,release: pfileno$,pdate,pcode$ eof PAP_DATE_XIT
58990       let pcode$=uprc$(trim$(pcode$))
58995     loop 
59000   end if 
59005   goto PAP_DATE_XIT
59010 PD_RESTORE_LAST: ! 
59015   restore #active_handle,last: ioerr PAP_DATE_XIT
59020   continue  ! PD_RESTORE_LAST
59025 PAP_DATE_XIT: ! 
59030   let fnpap_date$=fndate10_$(date$(days(set_fnpap_date)))
59035 fnend 
59040 def library fnkeybuild_by_buff$*512(kbbb_file_number,&kbbb_record$) !:
        let fnkeybuild_by_buff$=fnkeybuildby_buff$(kbbb_file_number,kbbb_record$) !:
      fnend 
59045 def fnkeybuildby_buff$*512(kbbb_file_number,&kbbb_record$)
59050 ! This function returns a Key bulit from KBBB_Record$, determined by KLn and KPs of KBBB_File_Number !:
        ! KBBB_File_Number - should be a file that is opened Keyed
59055   dim kbbb_key$*256
59060   mat kbbb_kps(6)=(0) : mat kbbb_kln(6)=(0) : let kbbb_key$="" : let key_part_count=0
59065   do 
59070     let key_part_count+=1
59075     let kbbb_kps(key_part_count)=kps(kbbb_file_number,key_part_count)
59080     let kbbb_kln(key_part_count)=kln(kbbb_file_number,key_part_count)
59085   loop until kps(kbbb_file_number,key_part_count+1)=-1
59086   mat kbbb_kps(key_part_count) : mat kbbb_kln(key_part_count)
59090   for kbbb_key_portion=1 to udim(kbbb_kps)
59095     let kbbb_key$=kbbb_key$&kbbb_record$(kbbb_kps(kbbb_key_portion):kbbb_kps(kbbb_key_portion)+kbbb_kln(kbbb_key_portion)-1)
59100   next kbbb_key_portion
59105   let fnkeybuildby_buff$=kbbb_key$
59110 fnend 
59120 !
59122 def library fnkeybuild_by_recno$*512(kbbr_file_number_1,kbbr_dr_record_number) !:
        let fnkeybuild_by_recno$=fnkeybuildby_recno$(kbbr_file_number_1,kbbr_dr_record_number) !:
      fnend 
59130 def fnkeybuildby_recno$*512(kbbr_file_number_1,kbbr_dr_record_number)
59135   dim kbbr_record$*4096
59140   let form_generic_c_len=min(rln(kbbr_file_number_1),32767) ! necessary for FORM_GENERIC_C
59145 !  OPEN #KBBR_FILE_HANDLE_2:=FNGETHANDLE_: "Name="&FILE$(KBBR_FILE_NUMBER_1)&",Shr",INTERNAL,INPUT,RELATIVE
59150   read #kbbr_file_number_1,using FORM_GENERIC_C,rec=kbbr_dr_record_number,release: kbbr_record$ norec NOREC_FNKEYBUILDBY_RECNO
59155   let fnkeybuildby_recno$=fnkeybuildby_buff$(kbbr_file_number_1,kbbr_record$)
59160   goto XIT_FNKEYBUILDBY_RECNO
59165 NOREC_FNKEYBUILDBY_RECNO: ! 
59170   let fnkeybuildby_recno$=""
59175   goto XIT_FNKEYBUILDBY_RECNO
59180 XIT_FNKEYBUILDBY_RECNO: ! 
59185 !  CLOSE #KBBR_FILE_HANDLE_2:
59190 fnend 
59200 FORM_GENERIC_C: form pos 1,c form_generic_c_len ! you must set    form_generic_c_len=min(rln(file_handle),32767)    , before using this form statement        this line is used by fnkeybuildby_recno$ and fndelrec
59210 !
59212 def library fndait$(tdait$;dait_format$, y2k_setting$,dait_listprint_win)
59214   let fndait$=fndait_$(tdait$,dait_format$, y2k_setting$, dait_listprint_win)
59216 fnend 
59220 def fndait_$(tdait$;dait_format$, y2k_setting$, dait_listprint_win)
59225 ! Dait_ListPrint_Win - if =-1, do not display Y2K warnings !:
        ! DAIT_FORMAT$ is the Output date format (Do not Change this!!!) !:
        ! Y2k_Setting$ - specifies the incoming date format  !:
        ! Dait_ListPrint_Win - if -1 than don't report to user, if 0 messagebox it, else fnlist_print it.
59230 L59230: let tdait$=trim$(tdait$) !:
        let lf$=chr$(10) !:
        if ~cls_setup then let fnclssetup
59235   if pos(tdait$,":")>0 then !:
          let pos_space=pos(tdait$&" "," ") : let tdait$=tdait$(1:pos_space-1) !:
          ! LET TDAIT$=FNCHOP1_$(TDAIT$," ") ! chop off time
59240   let y2k_problem=0 !:
        let slash1=pos(trim$(tdait$),"/") !:
        let slash2=pos(trim$(tdait$),"/",slash1+1) !:
        let date_len=len(trim$(tdait$)) !:
        if trim$(dait_format$)="" then let dait_format$="YY/MM/DD"
59245   if y2k_setting$="YYJJJ" then let tdait$=claimz$=fnjulian_$(tdait$) !:
        else !:
          if (y2k_setting$="MM/DD/CCYY" or slash2=date_len-4) and date_len<10 and slash1 then !:
            let tdait$=claimz$=fnpad_date_$(tdait$)
59250   if slash1=5 and date_len<10 then !:
          let tdait$=claimz$=fnpadccyy_date_$(tdait$)
59255   let tdait$=srep$(tdait$,"-","/") !:
        if len(tdait$)=8 or (len(tdait$)=6 and pos(tdait$,"/")=0) or (len(tdait$)=10 or len(tdait$)=0) then goto DATE_CHECK1 else !:
          if trim$(tdait$)="" then goto XIT_FNDAIT
59260   let td1=pos(tdait$,"/") !:
        if td1=0 then goto DATE_CHECK1
59265   let td2=pos(tdait$,"/",td1+1) !:
        let tdait$=cnvrt$('PIC(##)',val(tdait$(1:td1-1)))&"/"&cnvrt$('PIC(##)',val(tdait$(td1+1:td2-1)))&"/"&cnvrt$('PIC(##)',val(tdait$(td2+1:8))) conv DATE_CHECK_Y2K
59270 DATE_CHECK1: let tdait$=srep$(tdait$,"/","")
59275   let tdait=val(tdait$) conv DATE_CHECK2
59280   if trim$(y2k_setting$)<>"" and days(tdait,y2k_setting$) then !:
          let fndait_$=date$(days(tdait,y2k_setting$),dait_format$) !:
          goto DATE_CHECK_Y2K
59285   if trim$(y2k_setting$)<>"" then let y2k_problem=9
59290   if tdait=0 then let y2k_problem=0 !:
          goto DATE_CHECK_Y2K
59295   if days(tdait,"CYMD") then !:
          let fndait_$=date$(days(tdait,"CYMD"),dait_format$) !:
          let y2k_problem=1 : goto DATE_CHECK_Y2K
59300   if days(tdait,"MDCY") then !:
          let fndait_$=date$(days(tdait,"MDCY"),dait_format$) !:
          let y2k_problem=2 : goto DATE_CHECK_Y2K
59305   if days(tdait,"YMD") then !:
          let fndait_$=date$(days(tdait,"YMD"),dait_format$) !:
          let y2k_problem=3 : goto DATE_CHECK_Y2K
59310   if days(tdait,"MDY") then !:
          let fndait_$=date$(days(tdait,"MDY"),dait_format$) !:
          let y2k_problem=4 : goto DATE_CHECK_Y2K
59315   goto DATE_CHECK_Y2K
59320 DATE_CHECK2: let tdait$=uprc$(srep$(tdait$,"-","/")) !:
        let tdait=val(srep$(tdait$,"/","")) conv DATE_CHECK3 !:
        goto DATE_CHECK1
59325 DATE_CHECK3: let td1=pos(tdait$,"/") !:
        let td2=pos(tdait$,"/",td1+1) !:
        let td3=pos(tdait$," ")
59330   let month=srch(mat monthu$,tdait$(td1+1:td3-1))
59335   if month<=0 then goto DATE_CHECK_Y2K
59340   let tdait$=trim$(tdait$(td3+1:99)) !:
        let tdait$=srep$(tdait$,","," ") !:
        let day=fnval_(tdait$(1:2)) !:
        let tdait$=trim$(tdait$(3:99)) !:
        let year=fnval_(tdait$)
59345   let tdait$=cnvrt$('PIC(####)',year)&"/"&cnvrt$('PIC(##)',month)&"/"&cnvrt$('PIC(##)',day) conv DATE_VALUE_PROBLEM
59350   goto L59230
59355   let tdait$=cnvrt$('PIC(##)',val(tdait$(td2+1:99)))&"/"&cnvrt$('PIC(##)',month)&"/"&cnvrt$('PIC(##)',val(tdait$(1:td1-1))) conv DATE_CHECK_Y2K !:
        goto DATE_CHECK1
59360 DATE_CHECK_Y2K: ! THIS WAS fnend
59362   if trim$(y2k_setting$)<>"" and y2k_problem>2 and dait_listprint_win>0 then !:
          let fn_list_print(claimz$&" should be in "&y2k_setting$&" Format","Y2K Issue(s)",dait_listprint_win,1) else !:
          if y2k_problem>3 and dait_listprint_win>0 then let fn_list_print(claimz$&" is in an ambiguous date format will fail in 2001!","Y2K Issue(s)",dait_listprint_win,1)
59364   if y2k_1st or dait_listprint_win=-1 then goto XIT_FNDAIT else !:
          ! CHECK FOR Y2K PROBLEMS
59366     if trim$(y2k_setting$)<>"" then goto DATE_Y2K_PROBLEM !:
            ! THIS SECTIONS TESTS STANDARDS THAT ARE NOT DEFINED!
59368     if y2k_problem<2 then goto XIT_FNDAIT !:
            ! Don't worry if date had century
59370     if y2k_problem=3 then !:
            let fnmessagebox_("Dates Are Ambiguous, but in YY/MM/DD format"&lf$&"Dates Should continue to work correctly."&lf$&"Contact CLS to enhance for Y2K.",48,"CM - Warning Y2k issue") !:
            let y2k_1st=1 !:
            goto XIT_FNDAIT
59372     if y2k_problem=4 then !:
            let fnmessagebox_("Dates Are Ambiguous, but in MM/DD/YY format"&lf$&"Dates Will only work until 12/31/2000."&lf$&"Contact CLS to enhance for Y2K.",48,"CM - Warning Y2k issue") !:
            let y2k_1st=1 !:
            goto XIT_FNDAIT
59374     if y2k_problem>4 then !:
            let fnmessagebox_("Dates Are Ambiguous, unknown format"&lf$&"Dates may not work properly."&lf$&"Contact CLS to enhance for Y2K.",48,"CM - Warning Y2k issue") !:
            let y2k_1st=1 !:
            goto XIT_FNDAIT
59380 DATE_Y2K_PROBLEM: ! Y2K Date Formate Defined, but Data does not comply
59382 ! Check for Deviation from Defined Date Standard
59384     if y2k_problem<2 then goto XIT_FNDAIT !:
            ! Don't worry if date had century
59386     if y2k_problem=3 then !:
            let fnmessagebox_("Dates Are Ambiguous, but in YY/MM/DD format"&lf$&"Standard was defined as:"&y2k_setting$&lf$&"Dates should continue to work correctly."&lf$&"Contact CLS to enhance for Y2K.",48,"CM - Warning Y2k issue") !:
            let y2k_1st=1 !:
            goto XIT_FNDAIT
59388     if y2k_problem=4 then !:
            let fnmessagebox_("Dates Are Ambiguous, and in MM/DD/YY format"&lf$&"Standard was defined as:"&y2k_setting$&lf$&"Dates will only work until 12/31/2000."&lf$&"Contact CLS to enhance for Y2K.",48,"CM - Warning Y2k issue") !:
            let y2k_1st=1 !:
            goto XIT_FNDAIT
59390     if y2k_problem>4 then !:
            let fnmessagebox_("Dates Are Ambiguous, and in an unknown format"&lf$&"Standard was defined as:"&y2k_setting$&lf$&"Dates may not work properly."&lf$&"Contact CLS to enhance for Y2K.",48,"CM - Warning Y2k issue") !:
            let y2k_1st=1 !:
            goto XIT_FNDAIT
59400 DATE_VALUE_PROBLEM: ! Invalid Data Passed to function
59402     if dait_listprint_win>=0 then 
59404       let fnmessagebox_("Invalid date value passed:"&tdait$&"\nDates are expected as:"&y2k_setting$&"\nYear  = "&str$(year)&"\nMonth = "&str$(month)&"\nDay   = "&str$(day),48,"Invalid Date Value")
59406     end if  ! Dait_Listprint_Win>=0  (
59408     goto XIT_FNDAIT
59430 XIT_FNDAIT: ! 
59435   fnend 
59440   def fnjulian_$(julian$)
59442     if len(trim$(julian$))<>5 then goto XIT_FNJULIAN
59444     let jyy=val(julian$(1:2)) conv XIT_FNJULIAN
59446     let jdays=val(julian$(3:5)) conv XIT_FNJULIAN
59448     let julian=days(val(julian$(1:2)&"0101"))+jdays-1
59450     let fnjulian_$=fndate10_$(date$(julian))
59452 XIT_FNJULIAN: ! 
59454   fnend 
59460   def fndait_(tdait$)
59462     let fndait_=val(srep$(fndait_$(trim$(tdait$)),"/","")) conv ignore
59464   fnend 
59470   def library fndait(tdait$)
59472     let fndait=fndait_(tdait$)
59474   fnend 
59480   def fnpad_date_$(pad$)
59482     if pad$(3:3)<>"/" then let pad$(1:0)="0"
59484     if pad$(6:6)<>"/" then let pad$(4:3)="0"
59486     let fnpad_date_$=pad$
59488   fnend 
59490   def fnpadccyy_date_$(pad$)
59492 PADCCYY_DATE_1: if pad$(5:5)<>"/" then let pad$(1:0)="0" !:
            goto PADCCYY_DATE_1
59494     if pad$(8:8)<>"/" then let pad$(6:5)="0"
59496     if len(pad$)<10 then let pad$(9:8)="0"
59498     let fnpadccyy_date_$=pad$
59500   fnend 
59510   def library fnread_oc(&roc_key$,mat roc_data$,mat roc_datan,&roc_oc$,roc_h_open,roc_h_closed,roc_form_c$*512; roc_form_n$*512,roc_form_all$*1024)
59512     let fnread_oc=fn_read_oc(roc_key$,mat roc_data$,mat roc_datan,roc_oc$,roc_h_open,roc_h_closed,roc_form_c$, roc_form_n$,roc_form_all$)
59514   fnend  ! fnread_oc
59520   def fn_read_oc(&roc_key$,mat roc_data$,mat roc_datan,&roc_oc$,roc_h_open,roc_h_closed,roc_form_c$*512; roc_form_n$*512,roc_form_all$*1024) ! roc_
59522 ! This function returns one of the following:
59524 ! Read_OC_Nokey=-1 : Read_OC_Open=1 : Read_OC_Closed=2 ! fnRead_OC Response Enumerations
59526 ! roc_oc$ will return "Open" if successfully read from roc_h_open or "Closed" if read from roc_h_closed or "" if NoKey on both.
59528 ! roc_form_all$ - if provided it'll be used instead of roc_form_c$ and roc_form_n$
59530     let roc_oc$="" : mat roc_data$=("") : mat roc_datan=(0) : let roc_return=0
59532     let roc_key$=rpad$(trim$(roc_key$)(1:kln(roc_h_open)),kln(roc_h_open))
59534     if roc_form_all$='' then 
59536       read #roc_h_open,using roc_form_c$,key=roc_key$,release: mat roc_data$ nokey ROC_READ_CLOSED
59538       if roc_form_n$<>'' then 
59540         reread #roc_h_open,using roc_form_n$,release: mat roc_datan
59542       end if  ! roc_form_n$<>''
59544     else 
59546       read #roc_h_open,using roc_form_all$,key=roc_key$,release: mat roc_data$,mat roc_datan nokey ROC_READ_CLOSED
59548     end if  ! roc_form_all$=''   /   else 
59550     let roc_oc$="Open"
59552     goto ROC_FINIS
59554 ROC_READ_CLOSED: ! 
59555     if roc_h_closed=0 then goto ROC_FINIS ! if this function is called without a "Closed File Handle" then just skip closed part
59556     if roc_form_all$='' then 
59558       read #roc_h_closed,using roc_form_c$,key=roc_key$,release: mat roc_data$ nokey ROC_FINIS
59560       if roc_form_n$<>'' then 
59562         reread #roc_h_closed,using roc_form_n$,release: mat roc_datan
59564       end if  ! roc_form_n$<>''
59566     else 
59568       read #roc_h_closed,using roc_form_all$,key=roc_key$,release: mat roc_data$,mat roc_datan nokey ROC_FINIS
59570     end if  ! roc_form_all$=''   /   else 
59572     let roc_oc$="Closed"
59574     goto ROC_FINIS
59576 ROC_FINIS: ! 
59578     if roc_oc$="Open" then let roc_return=1 else if roc_oc$="Closed" then let roc_return=2 else let roc_return=-1
59580   let fn_read_oc=roc_return
59582 fnend  ! fn_read_oc
59590 def library fnstring_len_max(&slm_string$)
59592   let fnstring_len_max=fn_string_len_max(slm_string$)
59594 fnend  ! FnString_Len_Max
59600 def fn_string_len_max(&slm_string$) ! Slm_
59602   let buff$=slm_string$
59604   let slm_soflow_was$=fn_soflow_state$
59606   on soflow ignore 
59608   let slm_string$=rpt$('#',32767)
59610   if slm_soflow_was$="System" then on soflow system 
59612   let fn_string_len_max=len(slm_string$)
59614   let slm_string$=buff$
59616 fnend  ! Fn_String_Len_Max
59620 def library fnask_file1(&data_fil$,cap$*80; prompt$*80,default_filter$*128,footer$*80,fhelp$*1024)
59622   let fnask_file1=fnaskfile1(data_fil$,cap$, prompt$,default_filter$,footer$,fhelp$)
59624 fnend 
59630 def fnaskfile1(&data_fil$,cap$*80; prompt$*80,default_filter$*128,footer$*80,fhelp$*1024)
59635 ! function returns 99 if Cancel
59640   if ~ask_file1_setup then 
59645     dim af1_data_fil_prior$*256
59650     let screen_width=max(80,fnval_(env$("Session_Cols")))
59655     let ask_file1_setup=1
59660   end if 
59665   let data_fil_max_len=fn_string_len_max(data_fil$)
59670   let af1_data_fil_prior$=data_fil$
59675   let set_fnask_file1=0
59680   gosub SETUP_MESSAGEBOX ! LET MB_OK=1 : LET MB_CANCEL=2 : LET MB_ABORT=3 : LET MB_RETRY=4 : LET MB_IGNORE=5 : LET MB_YES=6 : LET MB_NO=7 ! fnMessageBox Response Enumerations
59685   if trim$(default_filter$)="" then let default_filter$="N:*.*"
59690   if trim$(prompt$)="" then let prompt$="File Name:"
59695   if trim$(footer$)="" then let footer$= "Enter Name of ASCII File  [F5] for List "
59700   let data_fil$=default_filter$
59705   let rin_pos=len(prompt$)+3 : let rin_len=40 !:
        let button_browse_pos=rin_pos+rin_len+2 : let button_browse_len=3 !:
        let button_cancel_len=8 : let button_cancel_pos=button_browse_pos+button_browse_len-button_cancel_len !:
        let button_ok_len=button_cancel_len : let button_ok_pos=button_cancel_pos-button_ok_len-2 !:
        let af1_win_width=button_cancel_pos+button_cancel_len+2 : let af1_win_pos_x=int((screen_width-af1_win_width)/2)
59710   let cap$=srep$(cap$,","," ") !:
        open #af1_win:=fngethandle_: "SRow=5,SCol="&str$(af1_win_pos_x)&",Rows=4,Cols="&str$(af1_win_width)&",Border=S,Tab="&cap$,display,outin 
59715   print #af1_win: newpage
59720   if trim$(cap$)<>"" then !:
          print fields "1,1,Cc 80,[S]": cap$
59725   print #af1_win,fields "2,2,Cr "&str$(len(prompt$))&",[W]": prompt$
59730   if env$("GUIMODE")="ON" then !:
          print #af1_win,fields "2,"&str$(button_browse_pos+button_browse_len-2)&",P 1/2,,5": "Icons\Open.gif:isotropic" !:
        else !:
          print #af1_win,fields "2,"&str$(button_browse_pos)&",Cr "&str$(button_browse_len)&",,5": "..." ! CHR$(254)
59735   print #af1_win,fields "4,"&str$(button_ok_pos)&",Cc "&str$(button_ok_len)&",[P]S,B0;4,"&str$(button_cancel_pos)&",Cc "&str$(button_cancel_len)&",[P]S,B99": "OK","Cancel"
59740   print fields "24,1,CC 80,[S]": footer$
59745 ASK_FILE1_ASK: ! 
59750   do 
59755     rinput #af1_win,fields "2,"&str$(rin_pos)&",V "&str$(rin_len)&"/"&str$(data_fil_max_len)&",[D]ST", help fhelp$: data_fil$
59760     if data_fil$="" and fkey=0 or fkey=93 then !:
            let fkey(99) ! when this function is implemented globally we can change the behavior to not cancel on blank entry, just by removing this line.
59765     if fkey=99 then let set_fnask_file1=99 : goto ASK_FILE1_XIT
59770     if data_fil$(len(data_fil$):len(data_fil$))="\" then let data_fil$=data_fil$&"*.*"
59775     if exists(data_fil$)=1 then let data_fil$=data_fil$&"\*.*" !:
            ! note EXISTS=1 if it does exist and it is a Directory
59780     if trim$(data_fil$)="" then !:
            let data_fil$=fnopen_$(default_filter$) !:
            goto ASK_FILE1_ASK !:
          else if fkey=5 or pos(data_fil$,"*")>0 or pos(data_fil$,"?")>0 then !:
            let data_fil$=fnopen_$(trim$(data_fil$)) !:
            goto ASK_FILE1_ASK
59785 loop until fkey=0
59790 ASK_FILE1_TEST_EXIST: ! 
59791 let data_fil$=fn_br_filename$(data_fil$)
59795 if ~exists(data_fil$) then 
59800   let temp_messagebox_response=fnmessagebox_("The file you specified does not exist.\n"&data_fil$, 48+5,cap$)
59805   if temp_messagebox_response=mb_retry then goto ASK_FILE1_TEST_EXIST else goto ASK_FILE1_ASK
59810 end if 
59815 ASK_FILE1_XIT: ! 
59820 let default_filter$=prompt$=""
59825 close #af1_win: 
59830 print fields "24,1,CC 80,[W]": '' ! remove the Footer$
59835 if set_fnask_file1=99 then let data_fil$=af1_data_fil_prior$
59840 let fnaskfile1=set_fnask_file1
59845 fnend  ! Fnaskfile1
59850 !
59860 def library fnygc_multi_calc$*20(ygc_id$*20,claim_type$*10)
59870   let ygc_id$=srep$(ygc_id$,".*CTYPE","."&claim_type$)
59880   let ygc_id$=srep$(ygc_id$,".*CTYP","."&claim_type$)
59890   let ygc_id$=trim$(ygc_id$)
59900   let ygc_id$=trim$(ygc_id$,".")
59910   let fnygc_multi_calc$=ygc_id$
59920 fnend 
59930 !
59932 def library fnclient_system32$*256
59934   let fnclient_system32$=fn_client_system32$
59936 fnend  ! fnclient_system32$*256
59940 def fn_client_system32$*256
59942   dim cs32_windir$*256,cs32_return$*256
59944   if uprc$(env$("Client_Server"))='YES' then 
59946     let cs32_windir$='@::'&env$("CS_WinDir")
59948   else 
59950     let cs32_windir$=env$("WinDir")
59952   end if  ! env Client_Server=YES   /   else 
59954   if exists(cs32_windir$&'\SysWow64') then 
59956     let cs32_return$=cs32_windir$&'\SysWow64'
59958   else 
59960     let cs32_return$=cs32_windir$&'\System32'
59962   end if 
59964   let fn_client_system32$=cs32_return$
59966 fnend  ! fn_client_system32$
59970 def fnguipush
59972   if env$("GUI_POP")="" then let setenv("GUI_POP",env$("GUIMODE"))
59974   execute "*Config GUI Off"
59976 fnend 
59980 ! FNGUI_PUSH_ON - Force GUIMODE = ON !:
      ! ** This is for features that ONLY WORK  in GUI MODE !:
      ! ** FNGUIPOP WILL RETURN TO THE 'DEFAULT MODE'
59982 def library fngui_push_on
59984   if env$("GUI_POP")="" then let setenv("GUI_POP",env$("GUIMODE"))
59986   execute "*Config GUI On"
59988 fnend 
59990 def library fngui_push
59992   let fnguipush
59994 fnend 
60000 def fnguipop
60002   if env$("GUI_POP")<>"" then !:
          execute "*Config GUI "&env$("GUI_POP") !:
          let setenv("GUI_POP","")
60004 fnend 
60010 def library fngui_pop
60012   let fnguipop
60014 fnend 
60020 !
60025 def fnmenu_lowercase_enforcer(mat lce_item$)
60030 ! this function fixes problems with menu options like "1. App; A. Other" to "1. app; A. Other"
60035   dim fcletter$(1)*1 ! Array built parallel to mat LCE_Item$ contains the First Capital Alpha-Character of the selection description (after the .)
60040   dim fcletter_pos(1) ! Array built parallel to mat LCE_Item$ contains the POSITION of the First Capital Alpha-Character of the selection description (after the .)
60045   dim option_letter$(1)*1 ! Array built (not parallel to anything) contains all used Option Letters (before the .)
60050   dim lce_test_char$*1,lce_item$*128 ! temp use variables
60055 ! get first Capital Letter of each LCE_Item$
60060   for x=1 to udim(lce_item$) : let lce_item$(x)=trim$(lce_item$(x)) : next x
60065   do 
60070     let fcletter_count=udim(lce_item$) : mat fcletter_pos(fcletter_count)=(0) : mat fcletter$(fcletter_count)=("") : mat option_letter$(0) : let option_letter_count=0
60075     for lce_item_count=1 to fcletter_count
60080       let lce_item$=lce_item$(lce_item_count) : let lce_item_len=len(trim$(lce_item$)) !:
            let fcletter$(lce_item_count)="" : let pos_count=pos(lce_item$,".")+1
60085       if pos_count<=0 then print "Menu Item does not have a period in it...  This function will probably fail. Menu Item="&lce_item$ : pause 
60090       if ord(lce_item$(1:1))>=65 and ord(lce_item$(1:1))<=90 then mat option_letter$(option_letter_count+=1) : let option_letter$(option_letter_count)=lce_item$(1:1)
60095       do 
60100         do 
60105           let pos_count+=1 : let lce_test_char$=lce_item$(pos_count:pos_count)
60110         loop until (ord(lce_test_char$)>=65 and ord(lce_test_char$)<=90) or pos_count>=lce_item_len
60115         if lce_test_char$=uprc$(lce_test_char$) then let fcletter$(lce_item_count)=lce_test_char$ : let fcletter_pos(lce_item_count)=pos_count
60120       loop until fcletter$(lce_item_count)<>"" or pos_count>lce_item_len
60125     next lce_item_count
60130 ! now let's lower case anything that needs it
60135     let lowercase_enforcement_count=0
60140     for lce_item_count=1 to fcletter_count
60145       let lce_test_char$=fcletter$(lce_item_count) !:
            let lce_char_pos=fcletter_pos(lce_item_count)
60150       let lce_match=srch(mat option_letter$,lce_test_char$)
60155       if lce_match>0 and lce_char_pos=fnfirstcapital_position(lce_item$(lce_item_count)) then 
60160         let lce_item$(lce_item_count)(lce_char_pos:lce_char_pos)=lwrc$(lce_test_char$) : let lowercase_enforcement_count+=1
60165       end if 
60170     next lce_item_count
60175   loop until lowercase_enforcement_count=0
60180 fnend  ! fnmenu_lowercase_enforcer
60190 def library fnchr_count(string_to_search$*10480,chr_to_count$*1)
60192   let fnchr_count=fn_chr_count(string_to_search$,chr_to_count$)
60194 fnend  ! Fnchr_Count
60200 def fn_chr_count(string_to_search$*10480,chr_to_count$*1)
60202   let chr_count=0
60204   do 
60206     let cc_pos_chr=pos(string_to_search$,chr_to_count$,cc_pos_chr+1)
60208     if cc_pos_chr>0 then let chr_count+=1
60210   loop until cc_pos_chr<=0
60212   let fn_chr_count=chr_count
60214 fnend  ! Fn_chr_Count
60220 def fnfirstcapital_position(fcp_item$*1024)
60222   let set_fnfirstcapital_position=0
60224   for pos_look=1 to len(fcp_item$)
60226     if fcp_item$(pos_look:pos_look)=uprc$(fcp_item$(pos_look:pos_look)) and ord(fcp_item$(pos_look:pos_look))>=65 and ord(fcp_item$(pos_look:pos_look))<=90 then let set_fnfirstcapital_position=pos_look : goto XIT_FNFIRSTCAPITAL_POSITION
60228   next pos_look
60230   let set_fnfirstcapital_position=-1
60232 XIT_FNFIRSTCAPITAL_POSITION: ! 
60234   let fnfirstcapital_position=set_fnfirstcapital_position
60236 fnend 
60240 def library fnpreclose(h_diary)
60250   dim qini$*256
60260   mat qarray$(0)
60270 F_DIARY1: form pos 1,c 8,pos 49,c 8
60280 F_PRECLOSE: form pos 1,c 8
60290   if not exists("PreClosedQueue.ini/custom") then !:
          goto X_PRECLOSE
60300   let fn_ini_open("PreClosedQueue.ini/custom")
60309   if h_preclose then !:
          close #h_preclose: ioerr L60310
60310 L60310: open #h_preclose:=fngethandle_: "Name=[wbwork]PreClose.int,kfname=[wbwork]PreClose.idx,kps=1,kln=8,recl=8,replace",internal,outin,keyed 
60320   if v_preclose:=version(h_preclose)=days(date) then !:
          goto X_PRECLOSE
60330   let qini$ = fn_ini_read$("[Pre-Closed]","Pre-Closed Queues")
60340   if pos(qini$,chr$(9))>0 then !:
          let str2mat(qini$,mat qarray$,chr$(9)) !:
        else !:
          let str2mat(qini$,mat qarray$,",")
60350   for nextitem=1 to udim(qarray$)
60360     let qarray$(nextitem)=rpad$(qarray$(nextitem),8)
60370     let q_len=len(trim$(qarray$(nextitem))) !:
          read #h_diary,using F_DIARY1,search>=qarray$(nextitem),release: fileno$, qcode$ eof NEXT_QUE nokey NEXT_QUE
60380 PC_TOL: ! 
60390     if qcode$(1:q_len)=qarray$(nextitem)(1:q_len) then 
60400       write #h_preclose, using F_PRECLOSE: fileno$
60410       read #h_diary,using F_DIARY1,next,release: fileno$, qcode$ eof NEXT_QUE
60420       goto PC_TOL
60430     end if 
60440 NEXT_QUE: ! 
60450   next nextitem
60460 X_PRECLOSE: ! 
60470   if lrec(h_preclose)>0 then !:
          let version(h_preclose,days(date))
60480   let fnpreclose=h_preclose
60490 fnend 
60500 !
60502 def library fnsetmatcnc(mat c1$,mat n1,mat c2$, c1_delimited$*4096,n1_delimited$*4096,c2_delimited$*4096; shutup)
60504   let fnsetmatcnc=fnsetmatcnc_(mat c1$,mat n1,mat c2$, c1_delimited$,n1_delimited$,c2_delimited$,shutup)
60506 fnend 
60510 def fnsetmatcnc_(mat c1$,mat n1,mat c2$, c1_delimited$*4096,n1_delimited$*4096,c2_delimited$*4096; shutup)
60512 ! this function sets arrays mat C1$, mat N1, and mat C2$ !:
        ! from the Semi-Colon (";") delimited strings C1_Delimited$, N1_Delimited$, and C2_Delimited$ !:
        ! further more if they are not parallel, it will warn you.  Unless you set ShutUp True value
60514   let c1_count=str2mat(c1_delimited$,mat c1$,";")
60516   if udim(c1$)=0 then mat c1$(1)
60518   let n1_count=fnsetmatn(mat n1,n1_delimited$)
60520   let c2_count=str2mat(c2_delimited$,mat c2$,";")
60522 ! PRINT 'n1_count='&STR$(N1_COUNT)&'      on  line 96091' : PAUSE  ! XXX
60524   if c1_count<>n1_count or n1_count<>c2_count then 
60526     if not shutup then 
60528       open #cnc_error_win:=fngethandle_: "SRow=08,SCol=10,Rows=7,Cols=50,Border=S,Caption=<fnSetMatCNC",display,outin 
60530       print #cnc_error_win,fields "1,2,C 48,[W]": "Arrays a not parallel!"
60532       print #cnc_error_win,fields "2,2,C 48,[W]": "Character Array 1 contains "&str$(c1_count)&" items."
60534       print #cnc_error_win,fields "3,2,C 48,[W]": "Numberic Array 1 contains "&str$(n1_count)&" items."
60536       print #cnc_error_win,fields "4,2,C 48,[W]": "Character Array 2 contains "&str$(c2_count)&" items."
60538       print #cnc_error_win,fields "6,2,Cc 48,[W]": "Press any key to continue anyway."
60540       input #cnc_error_win,fields "7,1,C 1,AE": pause$
60542       close #cnc_error_win: 
60544     end if 
60546     let fnsetmatcnc_=-1
60548   else 
60550     let fnsetmatcnc_=c1_count
60552   end if 
60554 fnend 
60560 !
60562 def fnsetmatn(mat n,n_delimited$*4096)
60564   dim setmatn_c$(1)*80
60566 ! LET N_DELIMITED$=TRIM$(N_DELIMITED$) !:
        ! if N_DELIMITED$(LEN(N_DELIMITED$):LEN(N_DELIMITED$))<>";" THEN LET N_DELIMITED$=N_DELIMITED$&";"
60568   let setmatn_c_count=str2mat(n_delimited$,mat setmatn_c$,";")
60570   mat n(setmatn_c_count)
60572   for temp_count=1 to setmatn_c_count
60574     let n(temp_count)=fnval_(setmatn_c$(temp_count))
60576   next temp_count
60578   let fnsetmatn=setmatn_c_count
60580 fnend 
60590 !
60592 FNGRID_SETUP: ! 
60594 def library fngrid_setup(gs_heading$*4096,width$*4096,form$*4096,mat gs_heading$,mat width,mat form$; width_default)
60596   let fngrid_setup=fngridsetup(gs_heading$,width$,form$,mat gs_heading$,mat width,mat form$, width_default)
60598 fnend 
60600 def fngridsetup(gs_heading$*4096,width$*4096,form$*4096,mat gs_heading$,mat width,mat form$; width_default)
60605 ! this function sets arrays mat GS_Heading$, mat Width, and mat Form$ !:
        ! from the Semi-Colon (";") delimited strings GS_Heading$, Width$, and Form$ !:
        ! further more if Format fields are left blank, they will automatically be set to "80/C [Width]" and !:
        ! if Width$ Fields are set blank they will automatically be set to the the Width_Default (below) !:
        ! Width_Default - defaults to 8 if not set.
60610   if width_default=0 then let width_default=8
60615 ! LET FORM$=SREP$(FORM$,"N","Cr")
60620   let fnsetmatcnc_(mat gs_heading$,mat width,mat form$,gs_heading$,width$,form$,1)
60625   let array_size=max(udim(mat gs_heading$),udim(mat width),udim(mat form$)) !:
        mat gs_heading$(array_size) !:
        mat width(array_size) !:
        mat form$(array_size)
60630   for count=1 to array_size
60635 !   if GS_HEADING$(COUNT)="" AND ARRAY_SIZE>1 THEN LET GS_HEADING$(COUNT)=CHR$(64+COUNT)
60640     if width(count)=0 then let width(count)=width_default
60641     if width(count)<0 then let width(count)=0
60645     if uprc$(form$(count))="DATE10" then let form$(count)="Date("&fn_date10_dis_fmt$&"),[T]LAE"
60650     if pos(uprc$(form$(count)),"DATE10")>0 then let form$(count)=srep$(uprc$(form$(count)),"DATE10","Date("&fn_date10_dis_fmt$&")")
60655     if env$("GUIMODE")="ON" then 
60660       if form$(count)="" then let form$(count)="C 256,[T]LAE" ! "&STR$(WIDTH(COUNT))&",[T]LAE"
60665       if uprc$(form$(count))="C" then let form$(count)="C 256,[T]LAE"
60670       if uprc$(form$(count))="CR" then let form$(count)="Cr 256,[T]LAE"
60675     else 
60680       if form$(count)="" then let form$(count)="C 80,[T]LAE" ! "&STR$(WIDTH(COUNT))&",[T]LAE"
60685       if uprc$(form$(count))="C" then let form$(count)="C "&str$(width(count))&",[T]LAE"
60690       if uprc$(form$(count))="CR" then let form$(count)="Cr "&str$(width(count))&",[T]LAE"
60695     end if 
60700   next count
60705 fnend 
60710 !
60715 def fnsection_get$*1024(cap_etc$*4096,section_identifier$*80,mat delimiter$)
60720 ! this function returns the section identified starting at Section_Identifier= and continuing until it meets the next (any of mat Delimiter$)= or the end of the string.
60725   dim section_text$*1024,section_pos(1)
60730 ! dim cap_etc_backup$*512 ! XXX
60735 ! cap_etc_backup$=cap_etc$ ! XXX
60740   let section_pos_start=pos(uprc$(cap_etc$),uprc$(trim$(section_identifier$))&"=")
60745   let section_data_pos_start=pos(uprc$(cap_etc$),uprc$(trim$(section_identifier$))&"=")+1+len(trim$(section_identifier$))
60750   let section_count=udim(delimiter$)
60755   mat section_pos(section_count)=(0)
60760   for section_counter=1 to section_count
60765     if uprc$(trim$(section_identifier$))=uprc$(trim$(delimiter$(section_counter))) then !:
            let section_pos(section_counter)=-2 !:
          else !:
            let section_pos(section_counter)=pos(uprc$(cap_etc$),uprc$(trim$(delimiter$(section_counter))&"="))-1
60770   next section_counter
60775   mat section_pos_ascending_sequence(section_count)=aidx(section_pos)
60780   mat section_pos_unsorted(section_count)=section_pos
60785   for section_counter=1 to section_count !:
          let section_pos(section_counter)=section_pos_unsorted(section_pos_ascending_sequence(section_counter)) !:
        next section_counter
60790   let section_counter=0
60795   do 
60800     if (section_counter+=1)>section_count then 
60805       let section_pos_end=len(cap_etc$)
60810     else 
60815       let section_pos_end=section_pos(section_counter)
60820     end if 
60825   loop until section_pos_end>section_pos_start
60830   if section_pos_start>0 then 
60835     let section_text$=trim$(cap_etc$(section_data_pos_start:section_pos_end))
60840 ! Cap_Etc$(Section_Pos_Start-Len(Trim$(Section_Identifier$)):Section_Pos_End)=""
60845   else 
60850     let section_text$=""
60855   end if 
60860   let fnsection_get$=section_text$
60865 ! PRINT "    Section_Identifier$="&SECTION_IDENTIFIER$ !:
        ! PRINT "          Section_Text$="&SECTION_TEXT$ !:
        ! PRINT "      Section_Pos_Start="&STR$(SECTION_POS_START) !:
        ! PRINT " Section_Data_Pos_Start="&STR$(SECTION_DATA_POS_START) !:
        ! PRINT "        Section_Pos_End="&STR$(SECTION_POS_END) !:
        ! PRINT "cap_etc_backup$="&CAP_ETC_BACKUP$ !:
        ! PAUSE  ! XXX
60870 fnend 
60880 !
60882 def library fnmat_1d_to_2d(mat array_source$, mat array_destination$, dimension_two)
60884   let fnmat_1d_to_2d=fnmat_1dto2d(mat array_source$, mat array_destination$, dimension_two)
60886 fnend 
60890 def fnmat_1dto2d(mat array_source$, mat array_destination$, dimension_two)
60895 ! this function parses a 1-D Array (Array_Source), which should contain chr$(179) ("") delimited items into a 2-D array (Array_Destination$), which will add a new Dimension equal to Dimension_Two !:
        ! Remove_Blank_Lines = if <>0 then this will remove any completely blank lines
60900   dim cell_data$(1)*256
60905   let array_source_udim=udim(array_source$) !:
        mat array_destination$(array_source_udim,dimension_two)
60910   for line_count=1 to array_source_udim
60915     if dimension_two=1 then 
60920       let array_destination$(line_count,1)=array_source$(line_count)(1:256) ! (1:80) !:
            ! ** Note: Each Element is limited to 80 characters
60925     else 
60930       mat cell_data$(dimension_two)=("") !:
            let cell_count=delimiter_pos_last=delimiter_pos=0
60935       do until (cell_count+=1)>dimension_two ! * Loop through a max of Dimension_Two
60940         let delimiter_pos=pos(array_source$(line_count),"",delimiter_pos_last+1) !:
              if delimiter_pos<=0 then let delimiter_pos=len(array_source$(line_count))+1
60945         let cell_data$(cell_count)=array_source$(line_count)(delimiter_pos_last+1:delimiter_pos-1) !:
              let delimiter_pos_last=delimiter_pos
60950         if cell_count<=dimension_two then !:
                let array_destination$(line_count,cell_count)=cell_data$(cell_count) else !:
                let array_destination$(line_count,dimension_two)(9999:0)=cell_data$(cell_count)
60955       loop  ! ** Loop Through each cell
60960     end if 
60965   next line_count
60970 fnend 
60980 !
60982 def library fnlist_print(item$*2048; handle,lp_cache_disable, cap_etc$*1400,listprint_srow,listprint_scol,listprint_rows,listprint_cols,listprint_border$)
60984   let fnlist_print=fn_list_print(item$, handle,lp_cache_disable, cap_etc$,listprint_srow,listprint_scol,listprint_rows,listprint_cols,listprint_border$)
60986 fnend 
61000 def fn_list_print(item$*2048; handle,lp_cache_disable, cap_etc$*1400,listprint_srow,listprint_scol,listprint_rows,listprint_cols,listprint_border$)
61010 ! LET SCR_FREEZE
61020 ! LP_Cache_Disable = 1=Disabled else Enabled.  if enabled - you may not use multiple windows via this function - only one!  When enabled, calls to this function will only update the screen every 1 second, it goes much much faster this way, but the last few entries may never be displayed.
61030 ! Print #Handle: NewPage  or  Close #Handle:   -  if you do these in your program, this function does not support multiple grids.  It could - all you'd need to do is cache about 9 more variables and tie them to Handle, like mat LP_Width_Text$ or mat ListPrint_Header$
61040 ! Cap_Etc$ = begins with the heading parameters separated by pipes ("|"), one of those parameters Contain "Caption=" specifying that it is the Window Caption instead of a column heading. !:
        !        note that forward slashes ("/") in Captions may cause problems caused by the use of fnParse_CSV below
61050   dim listprint_line$(1)*256
61060   dim listprint_gui_field$(1) ! Array containing (GUI ON) Base Field for Prints, Inputs, etc.
61070   dim listprint_guioff_form$(1)*400 ! Array containing (GUI OFF) Form for Print mat LP_Heading$
61080   dim listprint_heading_tmp$(1)*80
61090   dim listprint_cap_etc$(1)*400 !  Column Headings will be parsed into this
61100   dim listprint_column_count(1) ! stores the number of Columns for each list.
61110   dim listprint_line_2d$(1,1)*256 ! Temporary variable used for parsing mat ListPrint_Line$ to a 2-D Array, just before adding items to the grid.
61120   dim title_text$*1024 ! Window Caption section (specified by Title=) to be taken from Cap_Etc$
61130   dim heading_text$*1024 ! List Column Headings section (specified by Heading=) to be taken from Cap_Etc$
61140   dim lp_width_text$*1024 ! List Column LP_Width section (specified by LP_Width=) to be taken from Cap_Etc$
61150   dim lp_form_text$*1024 ! List Column LP_Form section (specified by LP_Form=) to be taken from Cap_Etc$
61160   dim lp_heading$(1)*80 ! List Column Headings parsed from Heading_Text$, which is delimited by semi-colons (";")
61170   dim lp_width(1) ! List Column LP_Widths parsed from LP_Width_Text$, which is delimited by semi-colons (";")
61180   dim lp_form$(1)*80 ! List Column LP_Forms parsed from LP_Form_Text$, which is delimited by semi-colons (";")
61190   dim lp_section$(4) ! Different sections that might be contained in the Cap_Etc$ Parameter
61200   dim use_handle_zero ! if =LP_True then a handle of zero was passed to this function, if =LP_False then a handle other than 0 was passed
61210   let session_rows=max(24,fnval_(env$("Session_Rows"))) !:
        let session_cols=max(80,fnval_(env$("Session_Cols"))) !:
        let lp_true=1 : let lp_false=~lp_true
61220 LP_TOP: ! 
61230   if trim$(listprint_border$)="" and listprint_scol+listprint_srow+listprint_rows+listprint_cols=0 then let listprint_scol=2 : let listprint_srow=14 : let listprint_cols=78 : let listprint_rows=09 : let listprint_border$="S"
61240   if trim$(listprint_border$)="" then 
61250     let listprint_border$="" : let listprint_scol_min=1 : let listprint_srow_min=1
61260   else 
61270     let listprint_border$=",Border="&listprint_border$ : let listprint_scol_min=2 : let listprint_srow_min=2
61280   end if 
61290 ! TOP OF Enforce minimum and maximums on ListPrint_SRow, ListPrint_SCol, ListPrint_Rows, and ListPrint_Cols
61300   let listprint_scol=max(listprint_scol,listprint_scol_min)
61310   if listprint_border$="" then let listprint_cols_max=session_cols-listprint_scol+1 else let listprint_cols_max=session_cols-listprint_scol-1
61320   let listprint_srow=max(listprint_srow,listprint_srow_min)
61330   if listprint_border$="" then let listprint_rows_max=session_rows-listprint_srow+1 else let listprint_rows_max=session_rows-listprint_srow-1
61340   let listprint_cols=min(listprint_cols,listprint_cols_max)
61350   let listprint_rows=min(listprint_rows,listprint_rows_max)
61360 ! END OF Enforce minimum and maximums on ListPrint_SRow, ListPrint_SCol, ListPrint_Rows, and ListPrint_Cols
61370   let listprint_scol$="SCol="&str$(listprint_scol)
61380   let listprint_srow$=",SRow="&str$(listprint_srow)
61390   let listprint_cols$=",Cols="&str$(listprint_cols)
61400   let listprint_rows$=",Rows="&str$(listprint_rows)
61410   if handle=0 and handle_zero=0 then let handle_zero=handle=fngethandle_ : let use_handle_zero=lp_true else if handle=0 and handle_zero>0 then let handle=handle_zero : let use_handle_zero=lp_true else let use_handle_zero=lp_false
61420 if udim(listprint_column_count)<handle then mat listprint_column_count(handle)
61430 if udim(listprint_gui_field$)<handle then mat listprint_gui_field$(handle)
61440 if udim(listprint_guioff_form$)<handle then mat listprint_guioff_form$(handle)
61450 if udim(listprint_initialized)<handle then mat listprint_initialized(handle)
61460 if udim(listprint_cap_etc$)<handle then mat listprint_cap_etc$(handle)
61470 if listprint_gui_field$(handle)="" then let listprint_gui_field$(handle)="1,1,List "&str$(listprint_rows)&"/"&str$(listprint_cols)
61480 if file(handle)=-1 then let listprint_initialized(handle)=lp_false
61490 ! ------- Initialization: Top -----------
61500 if not listprint_initialized(handle) then ! it needs to be initialized
61510 ! Initialize - Both
61520   let listprint_initialized(handle)=lp_true ! flag so that it does not initialize again.
61530   let lp_section$(1)="Title" : let lp_section$(2)="Heading" : let lp_section$(3)="Width" : let lp_section$(4)="Form"
61540   let listprint_cap_etc$(handle)=cap_etc$
61550   if trim$(cap_etc$)="" then 
61560     let title_text$=""
61570   else 
61580     let title_text$=fnsection_get$(cap_etc$,"Title",mat lp_section$)
61590     let heading_text$=fnsection_get$(cap_etc$,"Heading",mat lp_section$)
61600     let lp_width_text$=fnsection_get$(cap_etc$,"Width",mat lp_section$)
61610     let lp_form_text$=fnsection_get$(cap_etc$,"Form",mat lp_section$)
61620   end if 
61630   let fngridsetup(heading_text$,lp_width_text$,lp_form_text$,mat lp_heading$,mat lp_width,mat lp_form$)
61640   let listprint_column_count(handle)=udim(mat lp_heading$)
61650   if title_text$="" then let title_text$=srep$(srep$(srep$(cap_etc$,heading_text$,""),lp_width_text$,""),lp_form_text$,"")
61660   let title_text$=srep$(title_text$,",","")
61670   if file(handle)=-1 then 
61680     open #handle: listprint_scol$&listprint_srow$&listprint_cols$&listprint_rows$&listprint_border$&",N=[T],Tab="&title_text$,display,outin 
61690     print #handle: newpage
61700   end if 
61710 ! Initialize GUI Off
61720   if env$("GUIMode")="OFF" then 
61730     if listprint_guioff_form$(handle)="" then 
61740       let listprint_guioff_form$(handle)="Form Pos 1,"
61750       for xy=1 to listprint_column_count(handle)-1
61760         let lpfxy_pos_end=pos(lp_form$(xy),",")-1 : if lpfxy_pos_end<0 then let lpfxy_pos_end=len(lp_form$(xy))
61770         let listprint_guioff_form$(handle)=listprint_guioff_form$(handle)&lp_form$(xy)(1:lpfxy_pos_end)&',"",'
61780       next xy
61790       let xy=listprint_column_count(handle)
61800       if xy>0 then let listprint_guioff_form$(handle)=listprint_guioff_form$(handle)&lp_form$(xy)(1:pos(lp_form$(xy),",")-1) ! leave last comma off
61810 ! LET LISTPRINT_GUIOFF_FORM$(HANDLE)=SREP$(UPRC$(LISTPRINT_GUIOFF_FORM$(HANDLE)),",CR ",",Cc ")
61820 ! LET LISTPRINT_GUIOFF_FORM$(HANDLE)=SREP$(UPRC$(LISTPRINT_GUIOFF_FORM$(HANDLE)),",C ",",Cc ")
61830     end if 
61840     mat listprint_heading_tmp$(udim(lp_heading$))
61850     for xy=1 to listprint_column_count(handle)
61860       let listprint_heading_tmp$(xy)=trim$(lp_heading$(xy))(1:val(lp_form$(xy)(pos(lp_form$(xy)," ")+1:pos(lp_form$(xy),",")-1)))
61870     next xy
61880 ! open #Handle2:=fnGetHandle_: "Parent="&str$(Handle)&",SRow=1,SCol=1,Rows=1,Cols="&str$(ListPrint_Cols),Display,Outin
61890 ! print #Handle2,using ListPrint_GUIOff_Form$(Handle): mat listprint_heading_tmp$
61900     print #handle,using listprint_guioff_form$(handle): mat listprint_heading_tmp$
61910   else ! Initialize GUI On
61920     print #handle, fields listprint_gui_field$(handle)&",Headers,[Tabs]": (mat lp_heading$,mat lp_width,mat lp_form$)
61930   end if 
61940 end if 
61950 ! ------- initialization: End -----------
61960 ! ------- Add Line:       Top -----------
61970 if env$("GUIMode")="OFF" then 
61980   if item$<>"" then print #handle: item$
61990 ! input #handle2,fields "1,1,C 1,G":nowait$
62000 else 
62010   if udim(listprint_line$)=1 and listprint_line$(1)="" then mat listprint_line$(0)
62020   if item$<>"" then !:
          let listprint_line_dim=udim(listprint_line$)+1 !:
          mat listprint_line$(listprint_line_dim) !:
          let listprint_line$(listprint_line_dim)=item$(1:256) !:
          ! ** There is a MAX 256 Character Limit per Line Item !:
          ! ** Note: There is still an 80 character field limit!
62030   if time$<>time_last_display$ or listprint_line_dim>500 or lp_cache_disable=1 or item$="" then 
62040     let fnmat_1dto2d(mat listprint_line$,mat listprint_line_2d$,listprint_column_count(handle))
62050     if udim(listprint_line_2d$,1)>0 then print #handle, fields listprint_gui_field$(handle)&",+": mat listprint_line_2d$
62060     gosub LP_GUI_ADD_LINE_SET_CURFLD
62070   end if  ! Time$<> etc
62080 end if 
62090 ! ------- Add Line:       End -----------
62100 goto LISTPRINT_XIT
62110 LP_GUI_ADD_LINE_SET_CURFLD: ! 
62120 input #handle,fields listprint_gui_field$(handle)&",RowCnt,All,NoWait": gui_base ioerr XIT_LP_GUI_ADD_LINE_SET_CURFLD
62130 let curfld(1,gui_base)
62140 input #handle,fields listprint_gui_field$(handle)&",Rowsub,SelOne,NoWait": choice
62150 let time_last_display$=time$
62160 mat listprint_line$(0)
62170 XIT_LP_GUI_ADD_LINE_SET_CURFLD: ! 
62180 return 
62190 LP_INPUT_IOERR: ! 
62200 if err=870 then let listprint_initialized(handle)=lp_false : goto LP_TOP
62210 print "fnList_Print encountered Error (number "&str$(err)&" on line "&str$(line)&")."
62220 pause 
62230 LISTPRINT_XIT: ! 
62240 let scr_thaw !:
      !  if LAST_SCR$<>TIME$ OR LP_CACHE_DISABLE=1 THEN LET LAST_SCR$=TIME$ !:
      !   LET SCR_THAW
62250 fnend 
62260 def library fnscreen7_setup(mat field_pos$,mat field_type$)
62262   gosub SCREEN7_SETUP !:
        let screen7_setup=0 ! this is loafing, i know. needed to do a complete S7 setup later, just need mat field_pos$ now.
62264 fnend 
62270 !
62275 SCREEN7_SETUP: ! r: 
62280 ! library : FNS7_WRITE
62285 dim field_pos$(1)*32,field_type$(1)*8,fhelp$*1024,formr$*1024
62290 open #userdeffil_h:=fngethandle_: "Name=UserDef.Fil//9",internal,outin,relative 
62295 read #userdeffil_h,using FORM_USERDEFFIL,rec=1: datar
62300 mat field_pos$(datar)=("") : mat field_type$(datar)=("") : mat data$(datar)=("")
62305 read #userdeffil_h,using FORM_USERDEFFIL,rec=1: datar,mat field_pos$,mat field_type$,fhelp$,formr$
62310 close #userdeffil_h: 
62315 let screen7_setup=1
62320 return ! /r
62330 def library fns7_field_put(fileno$*8,field_number,value$*40,userdefint_handle,changes_handle,active_handle,master_handle,user)
62335   dim new_data$(1)*40,data$(1)*40
62340   read #master_handle,key=fileno$: nokey S7_FIELD_PUT_BAD_FILENO
62345   if field_number<=0 then let set_fns7_field_put=-10002 : goto XIT_S7_FIELD_PUT
62350   let read_good=fnreadscreen7(master_handle,fileno$,mat data$, userdefint_handle)
62355   if read_good=-1 then !:
          let set_fns7_field_put=-10004 !:
          goto XIT_S7_FIELD_PUT
62360   if field_number>udim(data$) then let set_fns7_field_put=-10003 : goto XIT_S7_FIELD_PUT
62365   mat new_data$(udim(data$)) : mat new_data$=data$ : let new_data$(field_number)=value$
62370   let set_fns7_field_put=fns7_write_(fileno$,mat new_data$,userdefint_handle,formr$,master_handle)
62375   if set_fns7_field_put<=0 then goto XIT_S7_FIELD_PUT
62380   let fns7changes(changes_handle,active_handle,fileno$,user,mat data$,mat new_data$,paperlesscode_none=0)
62385   goto XIT_S7_FIELD_PUT
62390 S7_FIELD_PUT_BAD_FILENO: ! 
62395   let set_fns7_field_put=-err
62400   goto XIT_S7_FIELD_PUT
62405 XIT_S7_FIELD_PUT: ! 
62410   let fns7_field_put=set_fns7_field_put
62415 fnend 
62420 def library fns7_write(fileno$,mat data$,userdefint_handle,&formr$,master_handle)
62422   let fns7_write=fns7_write_(fileno$,mat data$,userdefint_handle,formr$,master_handle)
62424 fnend 
62430 def fns7_write_(fileno$,mat data$,userdefint_handle,&formr$,master_handle)
62435   let set_fns7_write=0
62440   rewrite #userdefint_handle,using formr$,key=fileno$: fileno$,mat data$ nokey S7_WRITE_WRITE ioerr S7_WRITE_ERR
62445   let set_fns7_write=1
62450   goto XIT_S7_WRITE
62455 S7_WRITE_WRITE: ! 
62460   read #master_handle,key=fileno$: nokey S7_WRITE_ERR
62465   write #userdefint_handle,using formr$: fileno$,mat data$
62470   let set_fns7_write=2
62475   goto XIT_S7_WRITE
62480 S7_WRITE_ERR: ! 
62485   let set_fns7_write=-err
62490   goto XIT_S7_WRITE
62495 XIT_S7_WRITE: ! 
62500   let fns7_write_=set_fns7_write
62505 fnend 
62510 def library fns7_field_valid(field_number,&value$)
62515 ! retruns 1 if valid or 0 if invalid
62520   dim original_value$*40
62525   let original_value$=value$
62530   if ~screen7_setup then gosub SCREEN7_SETUP !:
          ! this gets mat Field_Type$ and mat Field_Pos$
62535   if field_number>udim(field_type$) then !:
          let value$="" : goto S7_FIELD_VALID_FINIS
62540   if field_type$(field_number)(1:1)="N" then !:
          let value$=trim$(fnnumber_input_$(value$,field_type$(field_number)),"0")
62545   if pos(field_pos$(field_number),"PIC(##/##/##)")>0 then !:
          let value$=fndate_inp8_$(value$)
62550   if pos(field_pos$(field_number),"PIC(####/##/##)")>0 then !:
          let value$=fndate_inp10_$(value$)
62555 S7_FIELD_VALID_FINIS: ! 
62560   if original_value$<>"" and value$="" then let set_fns7_field_valid=0 else let set_fns7_field_valid=1
62565   let fns7_field_valid=set_fns7_field_valid
62570 fnend 
62580 !_____________
62582 def library fnkfname$*256(filenumber)
62584   dim name_file$(1)*256,kfname_file$(1)*256,use_file$(1)*256
62586   let fnstatusfile(mat name_file$,mat kfname_file$,mat use_file$)
62588   let fnkfname$=kfname_file$(filenumber)
62590 fnend 
62600 !_____________
62605 def library fndbt_is_prop$(fileno$,debt_number,property_handle)
62610 ! This function returns a " " or a "P" or a "L" !:
        ! FileNo$ - !:
        ! Debt_Number - !:
        ! Property_Handle - Open Property File Handle (Keyed on FileNo - only Input necessary)
62615 PROPERTY_FORM_5A: form pos 1,c 8,n 3,n 3,pos 439,bh 4
62620   let is_prop$=" " : let fileno$=rpad$(fileno$,8)
62625   if lpfileno$<>fileno$ then 
62630     let lpfileno$=fileno$ : mat p_dbt(0) : mat p_lien_dt(0)
62635     read #property_handle,using PROPERTY_FORM_5A,search>=fileno$,release: property_data_fileno$,property_data_number,property_data_dbt_no,property_data_lien_date nokey EXIT_D_I_P
62640     do while property_data_fileno$=fileno$
62645       let prop_ele=fnstretch_n_(mat p_dbt) !:
            mat p_lien_dt(prop_ele) !:
            let p_dbt(prop_ele)=property_data_dbt_no !:
            let p_lien_dt(prop_ele)=property_data_lien_date
62650       read #property_handle,using PROPERTY_FORM_5A,release: property_data_fileno$,property_data_number,property_data_dbt_no,property_data_lien_date eof EXIT_D_I_P
62655     loop 
62660   end if 
62665 EXIT_D_I_P: let dn_p=srch(p_dbt,debt_number) !:
        if dn_p>0 then 
62670     if p_lien_dt(dn_p)>0 then !:
            let is_prop$="L" !:
          else let is_prop$="P"
62675   end if 
62680   let fndbt_is_prop$=is_prop$
62685 fnend 
62690 !__
62692 def library fnadd_one(mat add_to, one; no_add_zeros, no_add_duplicates)
62694   let fnadd_one=fn_add_one(mat add_to, one, no_add_zeros, no_add_duplicates)
62696 fnend 
62700 def fn_add_one(mat add_to, one; no_add_zeros, no_add_duplicates)
62702 ! must dim an array to 0 before you can add a first item !:
        ! mat Add_To - the array to add One item to !:
        ! One - the One item to add to mat Add_To !:
        ! No_Add_Zeros - if =1 than only add One if One<>0 !:
        ! No_Add_Duplicates - if =1 than only add One if One is not yet in mat Add_To !:
        ! This function returns the number of items in the array after any add
62704   if no_add_zeros=0 or (no_add_zeros and one<>0) then 
62706     if no_add_duplicates=0 or (no_add_duplicates and srch(mat add_to,one)=-1) then 
62708       let add_to_udim=udim(add_to) : mat add_to(add_to_udim+1) : let add_to(add_to_udim+1)=one
62710     end if 
62712   end if 
62714   let fn_add_one=udim(mat add_to)
62716 fnend 
62720 def library fnadd_one$(mat add_to$, one$*2048; no_add_blanks, no_add_duplicates)
62722   let fnadd_one$=fn_add_one$(mat add_to$, one$, no_add_blanks, no_add_duplicates)
62724 fnend 
62730 def fn_add_one$(mat add_to$, one$*2048; no_add_blanks, no_add_duplicates)
62735 ! must dim an array to 0 before you can add a first item !:
        ! mat Add_To$ - the array to add One$ item to !:
        ! One$ - the One$ item to add to mat Add_To$ !:
        ! No_Add_Blanks - if =1 than only add One$ if Trim$(One$)<>"" !:
        ! No_Add_Duplicates - if =1 than only add One$ if One$ is not yet in mat Add_To$ !:
        ! This function returns the number of items in the array after any add
62740   if no_add_blanks=0 or (no_add_blanks and trim$(one$)<>"") then 
62745     if no_add_duplicates=0 or (no_add_duplicates and srch(mat add_to$,one$)=-1) then 
62750       let add_to_udim=udim(mat add_to$) : mat add_to$(add_to_udim+1) : let add_to$(add_to_udim+1)=one$
62755     end if 
62760   end if 
62765   let fn_add_one$=str$(udim(mat add_to))
62770 fnend 
62780 !__
62782 def library fnedi_finis(mat file_number,cap$*80; edi_finis_messagebox_text$*2048,edi_finis_mb_icon,auto_flag,edi_finis_autolaunch)
62784   if ~setup then let fn_setup
62786   let fnedi_finis=fn_edi_finis(mat file_number,cap$, edi_finis_messagebox_text$,edi_finis_mb_icon,auto_flag,edi_finis_autolaunch)
62788 fnend  ! fnedi_finis
62790 def fn_edi_finis(mat file_number,cap$*80; edi_finis_messagebox_text$*2048,edi_finis_mb_icon,auto_flag,edi_finis_autolaunch)
62800   dim file_list$(1)*128
62810   mat file_list$(udim(file_number))=('')
62820   if edi_finis_mb_icon=0 then let edi_finis_mb_icon=64
62830   for file_count=1 to udim(file_number)
62840     if file_number(file_count)>0 then 
62850       let file_list$(file_count)=trim$(file$(file_number(file_count)))
62860       close #file_number(file_count): ioerr ignore
62870     end if 
62880   next file_count
62890   let fn_edi_finis$(mat file_list$,cap$, edi_finis_messagebox_text$,edi_finis_mb_icon,auto_flag,edi_finis_autolaunch)
62900 fnend  ! fn_edi_finis
62910 def library fnedi_finis$(mat file_virtual_name$,cap$*80; edi_finis_messagebox_text$*2048,edi_finis_mb_icon,auto_flag,edi_finis_autolaunch)
62912   if ~setup then let fn_setup
62914   let fnedi_finis$=fn_edi_finis$(mat file_virtual_name$,cap$, edi_finis_messagebox_text$,edi_finis_mb_icon,auto_flag,edi_finis_autolaunch)
62916 fnend  ! fnedi_finis$
62920 def fn_edi_finis$(mat file_virtual_name$,cap$*80; edi_finis_messagebox_text$*2048,edi_finis_mb_icon,auto_flag,edi_finis_autolaunch)
62930 ! todo: fnedi_finis should just call this function after building mat File_Virtual_Name$ and closeing it's files
62940   if edi_finis_mb_icon=0 then let edi_finis_mb_icon=64
62950   if ~auto_flag and env$("WBStart")='' then 
62960     if trim$(edi_finis_messagebox_text$)="" and (udim(mat file_virtual_name$)=0 or fn_array_empty(mat file_virtual_name$)) then 
62970       let edi_finis_messagebox_text$="No files were created."
62980     else if trim$(edi_finis_messagebox_text$)="" and udim(file_virtual_name$)=1 then 
62990       let edi_finis_messagebox_text$="The following file has been created:\n(Virtual Path)\n"
63000     else if trim$(edi_finis_messagebox_text$)="" and udim(file_virtual_name$)>1 then 
63010       let edi_finis_messagebox_text$="The following files have been created:\n(Virtual Paths)\n"
63020     else if trim$(edi_finis_messagebox_text$)<>"" and udim(file_virtual_name$)=1 then 
63030       let edi_finis_messagebox_text$=srep$(edi_finis_messagebox_text$,"file(s)","file")
63040       let edi_finis_messagebox_text$=srep$(edi_finis_messagebox_text$,"have/has","has")
63050       let edi_finis_messagebox_text$=srep$(edi_finis_messagebox_text$,"is/are","is")
63060       let edi_finis_messagebox_text$=edi_finis_messagebox_text$&"\n(Virtual Path)\n"
63070     else if trim$(edi_finis_messagebox_text$)<>"" and udim(file_virtual_name$)>1 then 
63080       let edi_finis_messagebox_text$=srep$(edi_finis_messagebox_text$,"file(s)","files")
63090       let edi_finis_messagebox_text$=srep$(edi_finis_messagebox_text$,"have/has","have")
63100       let edi_finis_messagebox_text$=srep$(edi_finis_messagebox_text$,"is/are","are")
63110       let edi_finis_messagebox_text$=edi_finis_messagebox_text$&"\n(Virtual Paths)\n"
63120     end if  ! TRIM$(EDI_FINIS_MESSAGEBOX_TEXT$)="" and (udim(File_Virtual_Name$)=0 or File_Virtual_Name$(1)=0)   /   TRIM$(EDI_FINIS_MESSAGEBOX_TEXT$)="" and UDIM(File_Virtual_Name$)=1   /   TRIM$(EDI_FINIS_MESSAGEBOX_TEXT$)<>"" and UDIM(File_Virtual_Name$)=1   /   TRIM$(EDI_FINIS_MESSAGEBOX_TEXT$)<>"" and UDIM(File_Virtual_Name$)>1
63130     if udim(mat file_virtual_name$)=>1 and ~fn_array_empty(mat file_virtual_name$) then 
63140       for mb_add_line_count=1 to udim(mat file_virtual_name$)
63150         if file_virtual_name$(mb_add_line_count)<>"" then 
63160           let edi_finis_messagebox_text$=trim$(edi_finis_messagebox_text$)&file_virtual_name$(mb_add_line_count)&"\n"
63170           if edi_finis_autolaunch then 
63180             let fn_exe("-c -M QUOTE=NONE",'vb32\Winshell',file_virtual_name$(mb_add_line_count)) ! Winshell is better than START.
63190           end if  ! edi_finis_autolaunch
63200         end if  ! file_virtual_name$(mb_add_line_count)<>""
63210       next mb_add_line_count
63220     end if  ! UDim(File_Virtual_Name$)>1
63230     let fnmessagebox_(edi_finis_messagebox_text$, edi_finis_mb_icon+0,cap$)
63240   end if  ! ~Auto_Flag and env$("WBStart")=''
63250 fnend  ! fn_edi_finis$
63251 def fn_array_empty(mat ae_x$)
63252   let ae_return=1
63253   for ae_x_item=1 to udim(mat ae_x$)
63254     if trim$(ae_x$(ae_x_item))='' then let ae_blank_count+=1
63255   next ae_x_item
63256   if ae_blank_count=udim(mat ae_x$) then let ae_return=1 else let ae_return=0
63257   let fn_array_empty=ae_return
63258 fnend 
63260 def library fnscr_freeze
63262   let scr_freeze ! if ENV$("GUIMode")="ON" THEN LET SCR_FREEZE
63264 fnend 
63270 def library fnscr_thaw
63272   let scr_thaw ! if ENV$("GUIMode")="ON" THEN LET SCR_THAW
63274 fnend 
63280 !__
63282 def library fnordinal$(oridnal_number)
63284   let ordinal_suffix$(1)="th" : let ordinal_suffix$(2)="st" : let ordinal_suffix$(3)="nd" : let ordinal_suffix$(4)="rd" : for ordinal_suffix_count=5 to 10 : let ordinal_suffix$(ordinal_suffix_count)="th" : next ordinal_suffix_count
63286   if mod(oridnal_number,100)=>10 and mod(oridnal_number,100)<=14 then let ordinal_suffix$="th" else let ordinal_suffix$=ordinal_suffix$(mod(oridnal_number,10)+1)
63288   let fnordinal$=str$(oridnal_number)&ordinal_suffix$
63290 fnend 
63300 !__
63302 def library fndiv(numberator,denominator)
63304   let fndiv=numberator/denominator zdiv ignore
63306 fnend 
63310 !__
63312 def library fnlist_print_handle$(lp_handle)
63314   let fnlist_print_handle$=fn_list_print_handle$(lp_handle)
63316 fnend 
63320 def fn_list_print_handle$(lp_handle) ! relies on local variables: mat ListPrint_GUI_Field$, Use_Handle_Zero, Handle_Zero (all from fnListPrint)
63325   let lp_true=1 : let lp_false=~lp_true
63330   let set_fn_list_print_handle$=""
63335   if lp_handle=0 and use_handle_zero=lp_true then 
63340     let set_fn_list_print_handle$=listprint_gui_field$(handle_zero)
63345   else if lp_handle>0 and lp_handle<=udim(listprint_gui_field$) then 
63350     let set_fn_list_print_handle$=listprint_gui_field$(lp_handle)
63355   end if 
63360   let fn_list_print_handle$=set_fn_list_print_handle$
63365 fnend 
63370 !_
63372 def library fnmerge_pool_utilize$
63374   let fnmerge_pool_utilize$=fnmergepool_utilize$
63376 fnend 
63378 def fnmergepool_utilize$
63380   if ~cls_setup then let fnclssetup
63382   let fnmergepool_utilize$=uprc$(merge_pool$)
63384 fnend 
63386 !_
63388 def library fntrue_path$*256(filewb_name$*256)
63390   let fntrue_path$=fntruepath_$(filewb_name$)
63392 fnend 
63394 !_
63396 def library fnlist_print_newpage(lp_handle)
63398   gosub SETUP_CONSTANTS
63400   let fnlist_print_newpage=fn_list_print_newpage(lp_handle)
63402 fnend 
63404 def fn_list_print_newpage(lp_handle)
63406   print #lp_handle,fields fn_list_print_handle$(lp_handle)&",=": mat empty$
63408 fnend 
63410 !_
63420 def library fncheck_trust
63422   dim path$*256,acct_name$*28,new_path$*256,des1$*80
63425   open #h_account:=fngethandle_: "NAME=ACCOUNT//7,SHR",display,input 
63430   linput #h_account: des1$ !:
        linput #h_account: cur_trust$
63435   let new_path$=file$(h_account)(3:999)
63440   close #h_account: 
63445   let new_path$=fn_path_root$(new_path$)
63450   open #h_trust:=fngethandle_: "name=trustact/common/5,shr",internal,outin,relative 
63455   for trust_cnt=1 to lrec(h_trust) !:
          read #h_trust,using "FORM POS 1,C 40,C 28,C 2,C 4",rec=trust_cnt,release: path$,acct_name$,type$,acct_code$ !:
          if rtrm$(uprc$(des1$))=rtrm$(uprc$(acct_name$)) then !:
            let this_mnu$=acct_code$ !:
            let trust=val(type$)
63460   next trust_cnt : close #h_trust: 
63465   if trust<>0 or trim$(this_mnu$)<>"" then let fncheck_trust=1 else let fncheck_trust=0
63470 ! if Trust=0 Or Trim$(This_Mnu$)="" then let fncheck_Trust=0
63475 fnend 
63480 def fn_path_root$*256(path$*256)
63485   let path$=srep$(path$,"\ACCOUNT","") !:
        let _backslash=pos(path$,"\",-1)
63490   let path$=path$(1:_backslash)
63495   let fn_path_root$=path$
63599 fnend 
63609 ! FREC(41) = Last Date Per_Diem_Int was Calculated!:
      ! FREC(42) = Daily Interest (Per Diem).!:
      ! FREC(45) = Amount of Interest Last Calculated.
63610 def library fnper_diem_int(mat frec)
63620   let per_diem_int_days=days(date)-days(frec(41))
63630   let fnper_diem_int=round( frec(45) + (frec(42)*per_diem_int_days) , 2)
63699 fnend 
63700 def library fnrecalc_int(ri_suit_date$,ri_j_date$,ri_forwarder,ri_venue,ri_dbt_state$*60,ri_claim_collord$,ri_idate$,ri_stored_int,mat ri_rates,ri_contract_fee,mat ri_filerec,mat ri_frec;ri_thrudat$,&ri_days_,&ri_trate,&ri_base_interest,&ri_collord$,&ri_bpj$,&ri_state$,&ri_fileno$)
63701   let fnrecalc_int=fn_recalc_int(ri_suit_date$,ri_j_date$,ri_forwarder,ri_venue,ri_dbt_state$,ri_claim_collord$,ri_idate$,ri_stored_int,mat ri_rates,ri_contract_fee,mat ri_filerec,mat ri_frec,ri_thrudat$,ri_days_,ri_trate,ri_base_interest,ri_collord$,ri_bpj$,ri_state$,ri_fileno$)
63709 fnend 
63710 def fn_recalc_int(ri_suit_date$,ri_j_date$,ri_forwarder,ri_venue,ri_dbt_state$*60,ri_claim_collord$,ri_idate$,ri_stored_int,mat ri_rates,ri_contract_fee,mat ri_filerec,mat ri_frec;ri_thrudat$,&ri_days_,&ri_trate,&ri_base_interest,&ri_collord$,&ri_bpj$,&ri_state$,&ri_fileno$)
63720   if ~setup_recalc_int then 
63730     let fnclssetup
63740     if setup_states=0 then let fnsetup_states
63750     let setup_recalc_int=1
63760   end if  ! Setup_Recalc_int
63770   mat filerec=ri_filerec(1:20) !:
        mat frec=ri_frec !:
        let amt6=ri_contract_fee
63780   mat i_charges=(0) : mat i_credits=(0) : mat i_balance=(0) : mat i_base=(0) !:
        let ri_thrudat=date("CCYYMMDD") !:
        if trim$(ri_thrudat$)<>"" then let ri_thrudat=fndate_val(ri_thrudat$)
63790   let ri_bpj$=ri_clerkf_state$=ri_clerkf_csz$="" : let ri_state$=hs$
63800   let ri_dbt_state$=trim$(uprc$(ri_dbt_state$))
63810   let ri_dbt_state=srch(mat st$,ri_dbt_state$)
63820   if ri_dbt_state<0 then !:
          let fnparse_csz_$(ri_dbt_state$,mat csz_results$) !:
          let ri_dbt_state$=uprc$(trim$(csz_results$(2))) !:
          let ri_dbt_state=srch(mat st$,ri_dbt_state$)
63830   if ri_dbt_state>0 then !:
          let ri_state$=ri_dbt_state$
63840   let ri_clerkf_csz$=fnclerkf_data$("CLERK_CSZ",ri_venue)
63850   let fnparse_csz_$(ri_clerkf_csz$,mat csz_results$) !:
        let ri_clerkf_state$=uprc$(trim$(csz_results$(2))) !:
        let ri_clerkf_state=srch(mat st$,ri_clerkf_state$)
63860   if ri_clerkf_state>0 then let ri_state$=ri_clerkf_state$
63870   if trim$(ri_claim_collord$)<>"" then 
63880     let ri_collord$=fn_collord$(ri_claim_collord$)
63890   else 
63900     let ri_collord$=fn_collord$(fnmasforw_data$("COLL_ORDER",ri_forwarder))
63910   end if  ! trim$(ri_claim_collord$)<>"" THEN
63920   let ri_days_=ri_trate=ri_base_interest=0
63930   if trim$(ri_j_date$)<>"" then 
63940     mat i_bpj=i_judgment
63950     let ri_trate=ri_rates(2)/365
63960     let ri_bpj$="J"
63970   else if trim$(ri_suit_date$)<>"" then 
63980     mat i_bpj=i_post
63990     let ri_trate=ri_rates(1)/365
64000     let ri_bpj$="P"
64010   else 
64020     mat i_bpj=i_before
64030     let ri_trate=ri_rates(1)/365
64040     let ri_bpj$="B"
64050   end if  ! I_BPJ populated with the Correct Setup & Interest Rates
64060   let i_charges(i_1100)=fnvcharges_
64070   let i_charges(i_3100)=amt6
64080   let i_charges(i_4100)=filerec(16)
64090   let i_charges(i_6100)=filerec(3)
64100   let i_charges(i_9100)=0 ! ?? Other We should Should be able to calculate this
64110 ! 
64120   let i_credits(i_1100)=vcalc_prin_coll ! Principal_COLL
64130   let i_credits(i_3100)=frec(27) ! CONTRACT_COLL
64140   let i_credits(i_4100)=filerec(17)
64150   let i_credits(i_6100)=frec(28)+filerec(20) ! Stat_Earn + FEES_COLL
64160   let i_credits(i_9100)=frec(30) ! OTHER_COLL
64170 ! 
64180   let i_balance(i_1100)=i_charges(i_1100)-i_credits(i_1100)
64190   let i_balance(i_3100)=i_charges(i_3100)-i_credits(i_3100)
64200   let i_balance(i_4100)=fnplus_(i_charges(i_4100)-i_credits(i_4100))
64205   let i_charges(i_5100)=frec(10) ! EXP_COST ** Note: This bucket really depends on Collection Order !:
        let i_credits(i_5100)=frec(29) ! Charges_COLL
64210   if pos(ri_collord$,"F")>0 then !:
          let i_balance(i_5100)=(fnplus_(i_charges(i_5100)-i_credits(i_5100)))*i_bpj(i_5100) !:
          ! ** Note: F or Firms Costs will be part of the Interest Base or "I_BALANCE", only if "F" is in COLLORD
64220   let i_balance(i_6100)=i_charges(i_6100)-i_credits(i_6100)
64230   let i_balance=sum(mat i_balance)
64240   let i_charges(i_9100)=filerec(5)+i_credits(i_9100)-i_balance ! Other is the difference between FILEREC(5) and the calculated Balance.
64250   let i_balance(i_9100)=i_charges(i_9100)-i_credits(i_9100)
64260   if uprc$(o_attyfee$)="N" and ri_bpj$="B" and i_charges(i_9100)<0 and i_charges(i_3100)>0 then 
64262     let c_9100_to_3100=min(-i_charges(i_9100),i_charges(i_3100)) ! Credit Other Against Contract
64264     let i_charges(i_9100)+=c_9100_to_3100
64265     let i_balance(i_9100)+=c_9100_to_3100
64266     let i_charges(i_3100)-=c_9100_to_3100
64267     let i_balance(i_3100)-=c_9100_to_3100
64268   end if  ! Credit (-) Other if Pre-J & Contract Not Part Of Dbal
64270   if i_balance(i_9100)<0 and i_bpj(i_9100)=0 then 
64272 ! PRINT "V is <0 and not accruing interest."
64274 ! Apply V (9100) to P (1100)
64276     let c_9100_to_1100=min(fnplus_(i_balance(i_1100)),-i_balance(i_9100))
64278     let i_credits(i_9100)-=c_9100_to_1100 : let i_balance(i_9100)+=c_9100_to_1100
64280     let i_credits(i_1100)+=c_9100_to_1100 : let i_balance(i_1100)-=c_9100_to_1100
64282 ! Apply V (9100) to O (3100)
64284     let c_9100_to_3100=min(fnplus_(i_balance(i_3100)),-i_balance(i_9100))
64286     let i_credits(i_9100)-=c_9100_to_3100 : let i_balance(i_9100)+=c_9100_to_3100
64288     let i_credits(i_3100)+=c_9100_to_3100 : let i_balance(i_3100)-=c_9100_to_3100
64290 ! Apply V (9100) to C (4100)
64292     let c_9100_to_4100=min(fnplus_(i_balance(i_4100)),-i_balance(i_9100))
64294     let i_credits(i_9100)-=c_9100_to_4100 : let i_balance(i_9100)+=c_9100_to_4100
64296     let i_credits(i_4100)+=c_9100_to_4100 : let i_balance(i_4100)-=c_9100_to_4100
64298 ! Apply V (9100) to S/L (6100)
64300     let c_9100_to_6100=min(fnplus_(i_balance(i_6100)),-i_balance(i_9100))
64302     let i_credits(i_9100)-=c_9100_to_6100 : let i_balance(i_9100)+=c_9100_to_6100
64304     let i_credits(i_6100)+=c_9100_to_6100 : let i_balance(i_6100)-=c_9100_to_6100
64306 ! PAUSE
64308   end if  ! I_9100<0
64350 ! Calc
64352   for _i_base=1 to udim(i_base) !:
          let i_base(_i_base)=i_balance(_i_base)*i_bpj(_i_base) !:
        next _i_base
64354   let ri_base_interest=sum(mat i_base) !:
        let ri_base_interest=fnplus_(min(ri_base_interest,filerec(5)+i_balance(i_5100))) !:
        ! Interest_BASE cannot be more than Dbal + "F" Due. (Also Interest_BASE can never be (-)
64356   let ri_days_=days(ri_thrudat) - days(fndate_val(ri_idate$))
64358   let ri_per_diem=fnplus_(ri_base_interest*ri_trate)/100
64360   let ri_int_amt=ri_stored_int + ri_days_ * ri_per_diem
64362   let ri_frec(41)=date("CCYYMMDD") !:
        let ri_frec(42)=ri_per_diem !:
        let ri_frec(43)=round(ri_trate*365,2) !:
        let ri_frec(44)=round(ri_base_interest,2) !:
        let ri_frec(45)=ri_int_amt ! Per_DIEM_Int should never be rounded.
64364   let fn_recalc_int=round(ri_int_amt,2)
64366 ! if Test_Int_Amt<>Ri_Int_Amt THEN PAUSE
64370 fnend 
64499 ! FnDiary_Time$ !:
      ! Ntime$        = HH:MM in 24 Military Time !:
      ! Exit_Prog     = 1 - When nTime$ is Blank,  simply return default time @@:@@ !:
      ! Function will return Properly formated Diary Time, (Or use "?" to indicate problems)
64500 ! Leave this gap for New Interest Routine!
64600 ! -----
64610 def library fnint_chargeable_balance(icb_suit_date$,icb_j_date$,icb_forwarder,icb_venue,icb_dbt_state$,icb_claim_collord$,prin_i_1100,contract_i_3100,costs_i_4100,firm_i_5100,stat_i_6100,other_i_9100)
64620   if ~setup_icb then 
64630     let fnclssetup
64640     if setup_states=0 then let fnsetup_states
64650     let setup_icb=1
64660   end if  ! Setup_ICB
64670   mat i_balance=(0) : mat i_base=(0)
64680   let i_balance(i_1100)=prin_i_1100
64690   let i_balance(i_3100)=contract_i_3100
64700   let i_balance(i_4100)=costs_i_4100
64710   let i_balance(i_5100)=firm_i_5100
64720   let i_balance(i_6100)=stat_i_6100
64730   let i_balance(i_9100)=other_i_9100
64740   let icb_bpj$=icb__clerkf_state$=icb_clerkf_csz$="" : let icb_state$=hs$
64750   let icb_dbt_state$=trim$(uprc$(icb_dbt_state$))
64760   let icb_dbt_state=srch(mat st$,icb_dbt_state$)
64770   if icb_dbt_state<0 then !:
          let fnparse_csz_$(icb_dbt_state$,mat csz_results$) !:
          let icb_dbt_state$=uprc$(trim$(csz_results$(2))) !:
          let icb_dbt_state=srch(mat st$,icb_dbt_state$)
64780   if icb_dbt_state>0 then !:
          let icb_state$=icb_dbt_state$
64790   let icb_clerkf_csz$=fnclerkf_data$("CLERK_CSZ",icb_venue)
64800   let fnparse_csz_$(icb_clerkf_csz$,mat csz_results$) !:
        let icb_clerkf_state$=uprc$(trim$(csz_results$(2))) !:
        let icb_clerkf_state=srch(mat st$,icb_clerkf_state$)
64810   if icb_clerkf_state>0 then let icb_state$=icb_clerkf_state$
64820   if trim$(icb_claim_collord$)<>"" then 
64830     let icb_collord$=fn_collord$(icb_claim_collord$)
64840   else 
64850     let icb_collord$=fn_collord$(fnmasforw_data$("COLL_ORDER",icb_forwarder))
64860   end if  ! trim$(ICB_claim_collord$)<>"" THEN
64870   let icb_trate=icb_base_interest=0
64880   if trim$(icb_j_date$)<>"" then 
64890     mat i_bpj=i_judgment
64900     let icb_trate=icb_rates(2)/365
64910     let icb_bpj$="J"
64920   else if trim$(icb_suit_date$)<>"" then 
64930     mat i_bpj=i_post
64940     let icb_trate=icb_rates(1)/365
64950     let icb_bpj$="P"
64960   else 
64970     mat i_bpj=i_before
64980     let icb_trate=icb_rates(1)/365
64990     let icb_bpj$="B"
65000   end if  ! I_BPJ populated with the Correct Setup & Interest Rates
65010   if pos(icb_collord$,"F")<=00 then !:
          let i_balance(i_5100)=0 !:
          ! ** Note: F or Firms Costs will be part of the Interest Base or "I_BALANCE", only if "F" is in COLLORD
65011 ! (-) Components should offest "Other", (-) Costs are ultimately collected as a Credit to Principal.
65012   if i_balance(i_3100)<0 then !:
          let i_balance(i_9100)+=i_balance(i_3100) !:
          let i_balance(i_3100)=0
65013   if i_balance(i_4100)<0 then !:
          let i_balance(i_9100)+=i_balance(i_4100) !:
          let i_balance(i_4100)=0
65014   if i_balance(i_5100)<0 then !:
          let i_balance(i_9100)+=i_balance(i_5100) !:
          let i_balance(i_5100)=0
65015   if i_balance(i_6100)<0 then !:
          let i_balance(i_9100)+=i_balance(i_6100) !:
          let i_balance(i_6100)=0
65020   let i_balance=sum(mat i_balance)
65030   for _i_base=1 to udim(i_base) !:
          let i_base(_i_base)=i_balance(_i_base)*i_bpj(_i_base) !:
        next _i_base
65040   let icb_base_interest=sum(mat i_base)
65050   let fnint_chargeable_balance=icb_base_interest
65060 ! if Test_Int_Amt<>ICB_Int_Amt THEN PAUSE
65070 fnend 
65500 ! Leave this gap for New Interest Routine!
65510 ! ------------
66000 def library fnget_inf_claim(gic_inf_handle,gic_fileno$,mat inf_code$,mat inf_type$,mat inf_value$,mat inf_value)
66002   mat inf_value$(999)=("") : mat inf_value(999)=(0) : mat inf_type$(999)=("") : mat inf_code$(999)=("")
66004   dim gic_inf_fileno$,gic_inf_type$,gic_inf_data$*70
66006   let inf_matches=0
66008 GIC_INFINITY: form pos 1,2*c 8,c 1,pos 27,c 70
66010   let gic_fileno$=rpad$(gic_fileno$,8)
66012   read #gic_inf_handle,using GIC_INFINITY,search>=gic_fileno$,release: gic_inf_fileno$,gic_inf_code$,gic_inf_type$,gic_inf_data$ nokey XIT_GET_INF_CLAIM
66014   do while gic_inf_fileno$=gic_fileno$
66016     if gic_inf_type$="C" or gic_inf_type$="F" then 
66018       let buff$=gic_inf_data$
66020     else if gic_inf_type$="N" or gic_inf_type$="I" then 
66022       let buff$=str$(buff:=val(gic_inf_data$))
66024     else if gic_inf_type$="D" then 
66026       let buff$=trim$(gic_inf_data$) !:
            let buff=val(srep$(buff$,"/","")) !:
            let buff=days(buff)
66028     end if  ! GIC_INF_TYPE$=C/F,N/I,D
66030     let inf_matches+=1
66032     let inf_code$(inf_matches)=uprc$(gic_inf_code$) error REDIM_GIC_ARRAY
66034     let inf_type$(inf_matches)=gic_inf_type$
66036     let inf_value$(inf_matches)=buff$
66038     let inf_value(inf_matches)=buff
66040     read #gic_inf_handle,using GIC_INFINITY,release: gic_inf_fileno$,gic_inf_code$,gic_inf_type$,gic_inf_data$ eof XIT_GIC_LOOP
66042   loop 
66044 XIT_GIC_LOOP: ! 
66046 XIT_GET_INF_CLAIM: let fnget_inf_claim=inf_matches
66048   mat inf_code$(inf_matches)
66050   mat inf_type$(inf_matches)
66052   mat inf_value$(inf_matches)
66054   mat inf_value(inf_matches)
66056 fnend 
66060 REDIM_GIC_ARRAY: ! r: Re-Dim due to error 122
66062 if err=122 then 
66064   let max_inf_matches=inf_matches+1000
66066   mat inf_code$(max_inf_matches)
66068   mat inf_type$(max_inf_matches)
66070   mat inf_value$(max_inf_matches)
66072   mat inf_value(max_inf_matches)
66074 else 
66076   print "Warning, Err:";err;" in Line:";line : pause 
66078 end if 
66080 retry  ! /r After Re-Dim, simply retry.
66090 def library fnfind_inf_claim$(inf_key$,&inf_value$,&inf_value,mat inf_code$,mat inf_type$,mat inf_value$,mat inf_value)
66100   let inf_key$=rpad$(uprc$(inf_key$),8)
66110   let inf_match=srch(mat inf_code$,inf_key$)
66120   if inf_match >0 then 
66130     let inf_value$=inf_value$(inf_match)
66140     let inf_value=inf_value(inf_match)
66150     let fnfind_inf_claim$=inf_type$(inf_match)
66160   end if  ! inf_match >0 THEN
66170 fnend 
66175 def library fnis_phone$*30(comment$*80)
66176   let fnis_phone$=fn_is_phone$(comment$)
66177 fnend 
66178 def library fnget_phone$*30(comment$*80)
66179   let fnget_phone$=fn_is_phone$(comment$)
66180 fnend 
66181 def fn_is_phone$*30(comment$*80)
66182   dim phone$*80
66183   if ~setup_is_phone then !:
          let setup_is_phone=1 !:
          let fnxlate_setup
66184   let phone$ = trim$(comment$)
66186   if phone$(1:1)="+" or phone$(1:3)="011" then !:
          goto ASSIGN_PHONE !:
          ! *** Note: + or 011 identifies an international #.
66188   if pos(phone$&" "," ")=11 then 
66190     let _phone=val(phone$(1:10)) conv NOT_NUMBER_ONLY
66192     let phone$(1:10)=fnphone_$(phone$(1:10))
66194 NOT_NUMBER_ONLY: ! 
66196   end if  ! Phone is 10 Digit #
66198   if phone$(3:3)=":" and phone$(6:6)=" " then !:
          let time1=val(phone$(1:2)) conv NOT_TIME_FIELD !:
          let time2=val(phone$(4:5)) conv NOT_TIME_FIELD !:
          let phone$(1:6)="" ! First "WORD" is time.
66200 NOT_TIME_FIELD: ! 
66205   let phone$ = trim$(srep$(xlate$(phone$,numbers_xlate$),"  "," "))
66206   if len(phone$) > 10 then let phone$=trim$(phone$ (1:14))
66210   if len(phone$) < 8 then let fn_is_phone$="" : goto XIT_PHONE_CHK
66211   if phone$(1:1)="1" then 
66214   end if  ! Phone$(1:1)="1"
66240   if len(trim$(phone$)) > 10 then let phone$=phone$ (1:12) : goto GOOD_PHONE
66245   if phone$ (4:4)=" " and len(phone$)=8 then let phone$=phone$ (1:14) : goto GOOD_PHONE
66255   if phone$ (4:4)=" " and phone$ (8:8)=" " then let phone$=phone$ (1:14) : goto GOOD_PHONE
66260   if phone$ (4:5)="  " and phone$ (5:6)=" " and phone$ (9:10)=" " then let phone$=phone$ (1:14) : goto GOOD_PHONE
66265   let fn_is_phone$="" : goto XIT_PHONE_CHK
66270 GOOD_PHONE: ! 
66275   let phone$ = srep$(phone$," ","")
66280   let phone$=fnphone_$(phone$)
66281   if pos(phone$,"-")<=0 then let phone$=""
66284 ASSIGN_PHONE: ! 
66285   let fn_is_phone$=phone$
66290 XIT_PHONE_CHK: ! 
66295 fnend 
66300 def library fnlaw_list$*4(list_name$*80)
66305   dim name_array$(1)*80
66310   let vinitials$=""
66315   let list_name$=" "&uprc$(list_name$)&" "
66320   let list_name$=srep$(list_name$,'"'," ")
66325   let list_name$=srep$(list_name$,","," ")
66330   let list_name$=srep$(list_name$,"'","")
66335   let list_name$=srep$(list_name$,"-"," ")
66340   let list_name$=srep$(list_name$,"."," ")
66345   let list_name$=srep$(list_name$,"    "," ")
66350   let list_name$=srep$(list_name$,"   "," ")
66355   let list_name$=srep$(list_name$,"  "," ")
66360   let list_name$=srep$(list_name$," OF "," ")
66365   let list_name$=srep$(list_name$," THE "," ")
66370   let list_name$=srep$(list_name$," AND "," ")
66375   let list_name$=srep$(list_name$," A "," ")
66380   let list_name$=trim$(list_name$)
66385   if len(trim$(list_name$))<=4 then 
66390     let vinitials$=list_name$
66395   else 
66400     let str2mat(list_name$,mat name_array$," ")
66405     for inits = 1 to min(udim(name_array$),4)
66410       let vinitials$=trim$(vinitials$)&name_array$(inits)(1:1)
66415     next inits
66420   end if  ! Len<=4
66425   let fnlaw_list$=vinitials$
66430 fnend 
66500 def library fnget_months$(mat get_months$)
66510   if ~cls_setup then let fnclssetup
66520   mat get_months$(udim(month$))=month$
66549 fnend 
66700 def fnfind3_file$*128(def_file$*128)
66710   dim getfile$*128,common$*128,custom$*128,local$*128
66720   let getfile$ = trim$(def_file$) !:
        let common$ = "common\"&getfile$ !:
        let custom$ = "custom\"&getfile$ !:
        let local$ = "n:"&getfile$
66730   if fnexists_(local$) > 0 then let fnfind3_file$=local$ : goto XIT_FIND3
66740   if fnexists_(custom$) > 0 then let fnfind3_file$=custom$ : goto XIT_FIND3
66750   if fnexists_(common$) > 0 then let fnfind3_file$=common$ : goto XIT_FIND3
66760 XIT_FIND3: ! 
66770 fnend 
66800 def library fnedi_type_to_matrix_type$(etmt_edi_type$*10)
66810   let fnedi_type_to_matrix_type$ = fnedi_type_to_matrix_type_$(etmt_edi_type$)
66820 fnend 
66830 def fnedi_type_to_matrix_type_$(etmt_edi_type$*10)
66840   dim etmt_matrix_type$*10
66850   let etmt_matrix_type$= (trim$(etmt_edi_type$))(1:8)
66860   if trim$(etmt_matrix_type$)="C_CON" then let etmt_matrix_type$="CC_F2C"
66870   if trim$(etmt_matrix_type$)="SFGAG" then let etmt_matrix_type$="SHERFINL"
66880   if trim$(etmt_matrix_type$)="MBNA2" then let etmt_matrix_type$="MBNA"
66890   let fnedi_type_to_matrix_type_$ = etmt_matrix_type$(1:8)
66899 fnend 
66900 def library fncsv$*1024(csv_value$*1024)
66905   let use_quote=0
66910   let csv_value$=rtrm$(csv_value$)
66915   if pos(csv_value$,",")>0 then let use_quote=1
66920   if use_quote then !:
          let csv_value$=srep$(csv_value$,'"','""') !:
          let csv_value$(1:0)='"' !:
          let csv_value$(9999:0)='"'
66925   let fncsv$=csv_value$
66930 fnend 
67000 def library fnautoc$*80(mat auto_fieldsc$,mat auto_datac$,search$,org_value$*80)
67005 ! Used by the AUTOMATE EDI routines to read data from the character INI Fields
67010   let s_ele=srch(mat auto_fieldsc$,uprc$(search$))
67020   if s_ele>0 then !:
          let fnautoc$=auto_datac$(s_ele) !:
        else !:
          let fnautoc$=org_value$
67030 fnend 
67040 def library fnauton(mat auto_fieldsn$,mat auto_datan,search$,org_value)
67045 ! Used by the AUTOMATE EDI routines to read data from the numeric INI Fields
67050   let s_ele=srch(mat auto_fieldsn$,uprc$(search$))
67060   if s_ele>0 then !:
          let fnauton=auto_datan(s_ele) !:
        else !:
          let nauton=org_value
67070 fnend 
67100 def library fngen_automate_template(gat_programname$*1000, mat gat_ini_settings$;showdiarydisclosure)
67110 ! This function generates a HTML file, with the ini settings that a particular program needs in the AUTOMATE.INI file, to run automatically
67120   dim gat_summary$(1)*1050
67130   let fnasci_("Reports\AUTOMATE.htm",mat gat_summary$)
67140   open #(cleanup:=fngethandle_): "NAME="&env$("CLIENT_TEMP")&"\KILL-"&wsid$&".HTM,REPLACE,RECL=5000",display,output  !:
        close #cleanup: 
67150   execute "*FREE "&env$("CLIENT_TEMP")&"\*.HTM >[WBWORK]NULL" error L67160 !:
        !:
        ! ** Note - This cleanup routine is very important! !:
        ! Without it, the summary feature will create a terrible mess!
67160 L67160: ! 
67170   open #(output:=fngethandle_): "NAME="&env$("CLIENT_TEMP")&"\AUTOMATE.HTM,REPLACE,RECL=5000",display,output 
67180   for nsummary=1 to udim(gat_summary$)
67190     let buff$=gat_summary$(nsummary)
67200 PARSE_NEXT: let nslash=pos(buff$,"\") !:
          if nslash<=0 then goto OUTPUT_LINE
67210     let nslash2=pos(buff$,"\",nslash+1)
67220     if nslash2<=nslash then goto OUTPUT_LINE !:
            ! Unbalanced "\" Ignore rest of line
67230     let buff1$=buff$(nslash:nslash2)
67240     let x4=0 !:
          let x2=pos(buff1$,"(") !:
          if x2>0 then let x3=pos(buff1$,")",x2+1) !:
            let x4=val(buff1$(x2+1:x3-1)) !:
            let buff1$=buff1$(1:x2-1)&"\"
67250     if buff1$ ="\PROGRAM NAME\" then !:
            let buff1$= gat_programname$ !:
            goto NEXT_FIELD
67260     if buff1$ = "\AUTOMATE TEXT\" then 
67270       let buff1$ =""
67280       for gat_scntr=1 to udim(gat_ini_settings$)
67290         let buff1$ = buff1$ & srep$(gat_ini_settings$(gat_scntr),"\","&#92;")
67300         if gat_scntr <> udim(gat_ini_settings$) then let buff1$ = buff1$ &"<br/>"
67310       next gat_scntr
67320     end if 
67325     if buff1$ = "\DIARY_DISCLOSURE\" then 
67330       if showdiarydisclosure then !:
              let buff1$="To use diary filters, please refer to the manual." !:
            else !:
              let buff1$=""
67335     end if 
67365 NEXT_FIELD: let buff1$=srep$(buff1$,"\","/") !:
          let buff$(nslash:nslash2)=buff1$
67370     goto PARSE_NEXT
67375 OUTPUT_LINE: print #output: buff$
67380   next nsummary
67385   execute "SYS -w -c VB32\VBSHELL "&env$("CLIENT_TEMP")&"\AUTOMATE.HTM"
67390   close #cleanup: 
67395 X_SUMMARY: ! 
67400 fnend  ! SUMMARY
67500 def library fnstr2mat(&source_string$,mat destination_array$)
67510   let source_delimiter$="," !:
        if pos(source_string$,chr$(9))>0 then !:
          let source_delimiter$=chr$(9)
67520   let str2mat(source_string$,mat destination_array$,source_delimiter$)
67525   let fnstr2mat=udim(destination_array$)
67530 fnend 
67600 def library fnvalidate_phone(vphone$*80)
67610   let is_valid_phone=0
67630   let vphone$=trim$(fnphone_$(vphone$)) ! Format The Provided Phone Number!
67640   if vphone$=fn_is_phone$(vphone$) then !:
          let is_valid_phone=1
67660   let fnvalidate_phone=is_valid_phone
67670 fnend 
67700 def library fnima(user_queue$)
67710 ! find user number in default queue
67720   let user_queue$=trim$(user_queue$) !:
        let ima_len=len(user_queue$)
67730   let ima=val(user_queue$(ima_len-2:99)) conv L67740 !:
        goto EXIT_IMA !:
        ! try last 3 digits
67740 L67740: let ima=val(user_queue$(ima_len-1:99)) conv L67750 !:
        goto EXIT_IMA !:
        ! try last 2 digits
67750 L67750: let ima=val(user_queue$(ima_len:ima_len)) conv L67770 !:
        goto EXIT_IMA !:
        ! try last digit
67760 EXIT_IMA: !:
        let fnima=ima
67770 L67770: fnend 
67800 def fnssn_$(ssn$)
67810   let ssn$=trim$(ssn$)
67820   if ssn$(3:3)="-" then 
67830     let ssn1=val(ssn$(1:2)) conv XIT_SSN
67840     let ssn2=val(ssn$(4:99)) conv XIT_SSN
67850     if len(trim$(ssn$(1:2)))<>2 or len(trim$(ssn$(4:99)))<>7 then goto XIT_SSN
67860     let ssn$=cnvrt$('PIC(##)',ssn1)&"-"&cnvrt$('PIC(#######)',ssn2) conv XIT_SSN
67870   else if ssn$(4:4)="-" and ssn$(7:7)="-" then 
67880     let ssn1=val(ssn$(1:3)) conv XIT_SSN
67890     let ssn2=val(ssn$(5:6)) conv XIT_SSN
67900     let ssn3=val(ssn$(8:99)) conv XIT_SSN
67910     if len(trim$(ssn$(1:3)))<>3 or len(trim$(ssn$(5:6)))<>2 or len(trim$(ssn$(8:99)))<>4 then goto XIT_SSN
67920     let ssn$=cnvrt$('PIC(###)',ssn1)&"-"&cnvrt$('PIC(##)',ssn2)&"-"&cnvrt$('PIC(####)',ssn3) conv XIT_SSN
67930   else if pos(ssn$,"-")>0 then 
67940     goto XIT_SSN ! Invalid position of Dashes!
67950   else 
67960     let ssn=val(srep$(ssn$,"-","")) conv XIT_SSN
67970     if ssn>=999999 and ssn<=999999999 then !:
            let ssn$=cnvrt$('PIC(###D##D####)',ssn) else !:
            if ssn=0 then let ssn$=""
67980   end if  ! SSN$(3:3)="-"
67990 XIT_SSN: let fnssn_$=ssn$
67999 fnend 
68000 def library fnvalidate_ssn(vssn$*80)
68010   let is_valid_ssn=0
68030   let vssn$=trim$(fnssn_$(vssn$)) ! Format The Provided SSN Number!
68040   let ssn=val(srep$(vssn$,"-","")) conv XIT_VALIDATE_SSN
68050   if vssn$(3:3)="-" then 
68060     let ssn1=val(vssn$(1:2)) conv XIT_VALIDATE_SSN
68070     let ssn2=val(vssn$(4:99)) conv XIT_VALIDATE_SSN
68080     if len(trim$(vssn$(1:2)))<>2 or len(trim$(vssn$(4:99)))<>7 then goto XIT_VALIDATE_SSN
68081     if ssn1<0 or ssn2<0 then goto XIT_VALIDATE_SSN
68085     let is_valid_ssn=1
68090   else if vssn$(4:4)="-" and vssn$(7:7)="-" then 
68100     let ssn1=val(vssn$(1:3)) conv XIT_VALIDATE_SSN
68110     let ssn2=val(vssn$(5:6)) conv XIT_VALIDATE_SSN
68120     let ssn3=val(vssn$(8:99)) conv XIT_VALIDATE_SSN
68130     if len(trim$(vssn$(1:3)))<>3 or len(trim$(vssn$(5:6)))<>2 or len(trim$(vssn$(8:99)))<>4 then goto XIT_VALIDATE_SSN
68131     if ssn1<0 or ssn2<0 or ssn3<0 then goto XIT_VALIDATE_SSN
68135     let is_valid_ssn=1
68140   end if  ! SSN$(3:3)="-"
68160 XIT_VALIDATE_SSN: let fnvalidate_ssn=is_valid_ssn
68170 fnend 
68180 def library fnpopulate_years$(mat pop_years$;years_back,years_forward)
68181   mat pop_years$(0)
68182   let year=val(date$("CCYY"))
68184   if years_back=0 then let years_back=10
68186   if year_forward=0 then let years_forward=1
68188   let curr_year=(year-years_back)
68190   for _year=1 to years_back
68192     let fn_add_one$(mat pop_years$,str$(curr_year))
68194     let curr_year+=1
68196   next _year
68198   let curr_year=year
68200   for _year=1 to years_forward
68202     let fn_add_one$(mat pop_years$,str$(curr_year))
68204     let curr_year+=1
68206   next _year
68208 fnend 
68210 def fndiary_rw_open
68220   if h_diary_queue_rw_open<=0 then !:
          open #h_diary_queue_rw_open:=fngethandle_: "name=DIARY.INT//6,KFNAME=DIARY.QUE//6,SHR",internal,outin,keyed 
68230 fnend 
68300 def library fnresolve_filepath(&rfilename$, &rpath$)
68310   let fnresolve_filepath= fnresolve_filepath_(rfilename$, rpath$)
68320 fnend 
68330 def fnresolve_filepath_(&rfilename$, &rpath$)
68340   if rpath$<>"" then goto X_R_FILEPATH
68350   let fpstatus = exists(rfilename$)
68360   if fpstatus = 1 then ! It is a directory that exists in the file system
68370     let rpath$ = rfilename$
68380     let rfilename$= "*.*"
68390   else 
68400     let lastslash = pos(rfilename$, "\", -1)
68410     let rpath$ = rfilename$(1:lastslash)
68420     let rfilename$ = rfilename$(lastslash+1:len(rfilename$))
68430   end if 
68440 X_R_FILEPATH: ! 
68450 fnend 
68500 def library fndiary_time$(ntime$;exit_prog)
68505   if exit_prog>=1 and trim$(ntime$)="" or trim$(ntime$) = ":" or ntime$ = "@@:@@" then let nfixtime$ = "@@:@@" : goto XIT_FNVAL_TIME
68510   if trim$(ntime$) = "" or ntime$ = "  :  " then let nfixtime$ = "  :  " : goto XIT_FNVAL_TIME
68515   let nfixtime$=trim$(ntime$) : let fixtime=nomark=nhour=nmin=0
68520   if nfixtime$(2:2)=":" then let nfixtime$(1:0)="0"
68525   if uprc$(nfixtime$(2:2)) = "A" then let nfixtime$(1:2)="0"&nfixtime$(1:1)
68530   if uprc$(nfixtime$(2:2)) = "P" then let nfixtime$(1:2)=str$(val(nfixtime$(1:1))+12)
68535   if len(trim$(nfixtime$(1:2))) < 2 then let nfixtime$(1:2)= "0"&nfixtime$(1:1)
68540   let nhour = val(nfixtime$(1:2)) conv BAD_HOUR
68545   if uprc$(nfixtime$(2:2)) = "A" or uprc$(nfixtime$(2:2)) = "P" then let nfixtime$(1:2)=cnvrt$('PIC(##)',nhour) conv ignore
68550   if pos(nfixtime$,":") <=0 then let nomark =1
68555   if nomark=1 then let nmin$ = uprc$(nfixtime$(3:5)) else !:
          let nmin$ = uprc$(nfixtime$(4:5))
68560   if nmin$="PM" or trim$(nmin$)="P" or pos(nfixtime$,"P")>0 then let nfixtime$(1:2)=cnvrt$('PIC(##)',nhour+12) conv ignore
68565   if trim$(nmin$)="" then let nmin$="00" : let nfixtime$=nfixtime$(1:3) & "00"
68570   if nomark=1 and (nmin$ = "AM" or nmin$ = "PM" or nmin$ = "P" or nmin$ = "A") then let nfixtime$=nfixtime$(1:2) & ":00"
68575   if nomark=0 and (nmin$ = "AM" or nmin$ = "PM" or nmin$ = "P" or nmin$ = "A") then let nfixtime$=nfixtime$(1:3) & "00"
68580   let nmin = val(nfixtime$(4:5)) conv BAD_MIN
68585   if nmin > 59 or nmin < 0 then let nfixtime$ = nfixtime$(1:3) & "??" : let fixtime=1
68590   if nhour >= 24 or nhour < 0 then let nfixtime$ = "??" & nfixtime$(3:5) : let fixtime=1 : goto XIT_FNVAL_TIME
68595   goto XIT_FNVAL_TIME
68600 BAD_HOUR: if nhour >= 24 or nhour < 1 then let nfixtime$ = "??" & nfixtime$(3:5) : let fixtime=1 : goto XIT_FNVAL_TIME
68605 BAD_MIN: let nfixtime$ = nfixtime$(1:3) & "??" : let fixtime=1 : goto XIT_FNVAL_TIME
68615 XIT_FNVAL_TIME: ! 
68616   if len(nfixtime$)=4 and pos(ntime$,":")<=0 then let nfixtime$(3:2)=":"
68620   if trim$(nfixtime$) = ":" then let nfixtime$ = "??:??"
68625   if exit_prog=2 and pos(nfixtime$,"?")>0 then let nfixtime$="00:00" ! if an invalid time is passed, return 00:00
68630   let fndiary_time$=nfixtime$(1:5)
68635 fnend  ! FnVal_Time$
68700 def library fndebtordoxd(h_document,mat active_data$,mat active_data)
68710   let fndebtordoxd = fndebtordoxd_(h_document,mat active_data$,mat active_data)
68720 fnend 
68730 def fndebtordoxd_(h_document,mat active_data$,mat active_data)
68740 FDNO: form pos 99,bh 2
68750   dim dockey$*50
68760   gosub SETUP_SQL_ACTIVE
68770   let dno = 0
68780   if h_document<1 then goto X_DEBTORDOXD
68790   let dockey$= rpad$(active_data$(active_fileno),8) & cnvrt$("BH 4",active_data(active_trans_date)) & cnvrt$("BH 4",active_data(active_trans_time)) & cnvrt$("BH 4",active_data(active_recno)) & rpad$(active_data$(active_type),1) & rpad$(active_data$(active_code),8)
68800   read #h_document, using FDNO, key=dockey$, release: dno error X_DEBTORDOXD
68810 X_DEBTORDOXD: ! 
68820   let fndebtordoxd_ = dno
68830 fnend 
68900 def library fnactiverecnotodebtordoxd(h_active,actdd_recno,h_document)
68910   gosub SETUP_SQL_ACTIVE
68920   let acrtdd_dno =0
68930   read #h_active, using active_formall$, rec=actdd_recno, release: mat active_data$, mat active_data error X_ACTIVERNOTODEBTORDOXD
68940   let acrtdd_dno = fndebtordoxd_(h_document,mat active_data$, mat active_data)
68950 X_ACTIVERNOTODEBTORDOXD: ! 
68960   let fnactiverecnotodebtordoxd= acrtdd_dno
68970 fnend 
69000 def library fnprogram_exe$*256(exe_name$*128)
69010   dim programfiles$(0)*128
69020   if ~setup_program_exe then 
69030     let _program_files=0 : mat programfiles$(4)
69040     if env$("CS_ProgramFiles")<>"" and exists("@::"&env$("CS_ProgramFiles")) then !:
            let programfiles$(_program_files+=1)="@::"&trim$(env$("CS_ProgramFiles")) !:
            let programfiles$(_program_files)=rtrm$(programfiles$(_program_files),"\")&"\"
69050     if env$("CS_PROGRAMW6432")<>"" and exists("@::"&trim$(env$("CS_PROGRAMW6432"))) then !:
            let programfiles$(_program_files+=1)="@::"&trim$(env$("CS_PROGRAMW6432")) !:
            let programfiles$(_program_files)=rtrm$(programfiles$(_program_files),"\")&"\"
69060     if env$("ProgramFiles")<>"" and exists(env$("ProgramFiles")) then !:
            let programfiles$(_program_files+=1)=os_filename$(":"&trim$(env$("ProgramFiles"))) !:
            let programfiles$(_program_files)=rtrm$(programfiles$(_program_files),"\")&"\"
69070     if env$("PROGRAMW6432")<>"" and exists(env$("PROGRAMW6432")) then !:
            let programfiles$(_program_files+=1)=os_filename$(":"&trim$(env$("PROGRAMW6432"))) !:
            let programfiles$(_program_files)=rtrm$(programfiles$(_program_files),"\")&"\"
69080     let setup_program_exe=1
69090     mat programfiles$(_program_files)
69100   end if 
69110   let exe_name$=trim$(trim$(exe_name$,"/"),"\")
69120   for _program_try=1 to udim(programfiles$)
69130     if exists(programfiles$(_program_try)&exe_name$) then !:
            let fnprogram_exe$=programfiles$(_program_try)&exe_name$ : goto RETURN_PROG
69140   next _program_try
69149 RETURN_PROG: !:
      fnend 
70200 def library fnis_cost(categ)
70205   if ( int(categ)>=33 and int(categ)<=81 ) or ( int(categ)>=501 and int(categ)<=599 ) then !:
          let fnis_cost=1
70209 fnend 
70210 def library fnge_33(categ)
70215   if ( int(categ)>=33 and int(categ)<=99 ) or ( int(categ)>=501 and int(categ)<=599 ) then !:
          let fnge_33=1
70219 fnend 
70450 def library fndistinctc(mat source$, mat distinct$; excludeblanks)
70455 ! RS: The function FnDistinctC returns the distict sorted elements in a string array
70460 ! mat Source$: The source array from which to return distinct elements
70465 ! mat Distinct$: The destination array that is computed to contain distinct elements from the source array !:
        ! Excludeblanks: Flag to indicate if empty elements in source array should be ignored
70470   mat distinct$(source_udim:= udim(mat source$))
70475   mat sourcesorted(source_udim) = aidx(source$)
70480   let distinctcnt = 0 ! LET Source_Udim = Udim(Mat Source$)
70485   for dc_cntr = 1 to source_udim
70490     let _sorted_cntr = sourcesorted(dc_cntr)
70495     let source$(_sorted_cntr) = trim$(uprc$(source$(_sorted_cntr)))
70500     if excludeblanks and source$(_sorted_cntr)="" then goto N_DC
70505     if srch(mat distinct$, source$(_sorted_cntr))<1 then 
70510       let distinctcnt+=1 !  mat Distinct$(Curdim:=Udim(Mat Distinct$)+1)
70515       let distinct$(distinctcnt)= source$(_sorted_cntr)
70520     end if 
70525 N_DC: next dc_cntr
70530   mat distinct$(distinctcnt)
70535   let fndistinctc = distinctcnt
70540 fnend 
70600 def library fnemail_subject_override$*256(eso_fileno$,eso_rel_type$,eso_rel_no,eso_email_subject$*128,eso_h_master,eso_h_debtor,eso_h_infinity)
70610   if ~setup then !:
          let fn_setup
70620   if ~setup_sql then !:
          gosub SETUP_SQL
70630   let fnemail_subject_override$=fn_email_subject_override$(eso_fileno$,eso_rel_type$,eso_rel_no,eso_email_subject$,eso_h_master,eso_h_debtor,eso_h_infinity)
70640 fnend  ! Fnemail_Subject_Override$
70650 def fn_email_subject_override$*256(eso_fileno$,eso_rel_type$,eso_rel_no,eso_email_subject$*128,eso_h_master,eso_h_debtor,eso_h_infinity)
70660   dim eso_field$*70,eso_override_subject$*128
70670   if exists("EmailOverride.ini/custom") and eso_rel_no>0 and trim$(eso_rel_type$)<>"" then 
70680     if not ini_opened then !:
            let fn_ini_open("EmailOverride.ini/custom") !:
            let ini_opened=1
70700     let eso_override_subject$=fn_ini_read$("["&eso_rel_type$&".EmailSubject]",str$(eso_rel_no)) ! trim handled by FnINI_read
70710     if eso_override_subject$="" then !:
            let eso_override_subject$=fn_ini_read$("["&eso_rel_type$&".EmailSubject]","DEFAULT")
70720     if eso_override_subject$<>"" then !:
            let eso_email_subject$=eso_override_subject$
70730     let eso_slash1=pos(eso_email_subject$,"\") !:
          let eso_slash2=pos(eso_email_subject$,"\",eso_slash1+1)
70740     do while eso_slash1>0 and eso_slash2>0 !:
            ! loop to find all \\ variables, replacing with values on each pass
70750       let eso_field$=uprc$(trim$(eso_email_subject$(eso_slash1:eso_slash2)))
70755       let eso_uform$="" !:
            let eso_x5=pos(eso_field$,"{") !:
            if eso_x5>0 then !:
              let eso_x6=pos(eso_field$,"}") !:
              let eso_uform$=eso_field$(eso_x5+1:eso_x6-1) !:
              let eso_field$=eso_field$(1:eso_x5-1)&eso_field$(eso_x6+1:9999)
70760       let eso_dotpos=pos(eso_field$,".")
70770       if eso_field$(1:8)="\MASTER." then 
70780         let fn_sql_print$(eso_field$,user_form$,eso_h_master,eso_fileno$,last_eso_fileno$,mat master_data$,mat master_data,mat master_fieldsc$,mat master_fieldsn$,master_formc$,master_formn$,mat master_fc$,mat master_fn$,"MASTER",master_loc)
70790       else if uprc$(eso_field$(1:7))="\DEBTOR" then 
70800         let debtor_no=max(fnval_(eso_field$(8:eso_dotpos-1)),1) !:
              let debtor_key$=rpad$(eso_fileno$,8)&cnvrt$('N 3',debtor_no) !:
              let eso_field$="\"&trim$(uprc$(eso_field$(eso_dotpos+1:eso_slash2))) !:
              let fn_sql_print$(eso_field$,user_form$,eso_h_debtor,debtor_key$,debtor_last_key$,mat debtor_data$,mat debtor_data,mat debtor_fieldsc$,mat debtor_fieldsn$,debtor_formc$,debtor_formn$,mat debtor_fc$,mat debtor_fn$,"DEBTOR",debtor_loc)
70810       else if uprc$(eso_field$(1:5))="\INF." then 
70820         let fn_getinf$(eso_h_infinity,eso_fileno$&eso_field$(eso_dotpos+1:len(eso_field$)-1),inf_data,eso_field$) !:
              ! only character Inf fields currently supported
70830       end if  ! ESO_Field$(1:8)
70835       if eso_uform$<>"" then !:
              let eso_field$=fnchar$(eso_field$,len(eso_field$),eso_uform$)
70840       let eso_email_subject$=eso_email_subject$(1:eso_slash1-1)&srep$(trim$(eso_field$),"\","/")&eso_email_subject$(eso_slash2+1:9999)
70850       let eso_slash1=pos(eso_email_subject$,"\") !:
            let eso_slash2=pos(eso_email_subject$,"\",eso_slash1+1)
70860     loop 
70870   end if  ! Exists("EmailOverride.ini/custom") AND ESO_Rel_No>0 AND TRIM$(Eso_Rel_Type$)<>""
70880 X_FNEMAIL_SUBJECT_OVERRIDE: !:
        let fn_email_subject_override$=srep$(eso_email_subject$,"\","/") !:
      fnend  ! Fn_Email_Subject_Override$
70900 def library fnleave(fileno$,h_actived,h_tempwp,mat collector_codes$)
70905   if not setup_sql_active then !:
          gosub SETUP_SQL_ACTIVE
70910   let leave_flag=0
70915   read #h_actived,using active_formall$,search>=cnvrt$("BH 4",date('CCYYMMDD'))&fileno$,release: mat active_data$,mat active_data nokey X_FNLEAVE
70920   do while active_data(active_trans_date)=date('ccyymmdd') and active_data$(active_fileno)=fileno$
70925     let leave_flag=max(srch(mat collector_codes$,uprc$(active_data$(active_code))),0) !:
          if leave_flag then !:
            exit do 
70930     read #h_actived,using active_formall$,release: mat active_data$,mat active_data eof LEAVE_CHECK_TWP
70935   loop 
70940 LEAVE_CHECK_TWP: !:
        if not leave_flag then 
70945     let wpfileno$="" !:
          read #h_tempwp,using R17,search>=fileno$,release: wpfileno$,llcode$ nokey X_FNLEAVE
70950     do while wpfileno$=fileno$
70955       let leave_flag=max(srch(mat collector_codes$,rpad$(uprc$(llcode$),8)),0) !:
            if leave_flag then !:
              exit do 
70960       read #h_tempwp,using R17,release: wpfileno$,llcode$ eof X_FNLEAVE
70965     loop 
70970   end if 
70975   let fnleave=leave_flag
70980 X_FNLEAVE: !:
      fnend 
71000 def fn_diarycode_desc_span(dia$*80)
71020   let dds_return=dds_x1=dds_x2=0
71030   let dds_x=pos(srep$(dia$,"\","/"),"/")
71040   if dds_x>0 then 
71050     let dds_x1=fnval_(dia$(1:dds_x-1))
71060     let dds_x2=fnval_(dia$(dds_x+1:99))
71070     if dds_x1=0 then let dds_x1=dds_x2 ! : dia$(dds_x:99)='' else dia$(1:dds_x)='' ! note: the modifications to dia$ on this line are only for when stipping the span value from the description
71080     if dds_x1<>0 then let dds_return=dds_x1
71090   end if  ! dds_X>0
71110   let fn_diarycode_desc_span=dds_return
71120 fnend 
71240 ! -----------FNGET_CSZ()----------------------------
71245 def library fnget_csz(csz_text$*128,mat csz_results$)
71250   let fnget_csz=fnget_csz_(csz_text$,mat csz_results$)
71255 fnend 
71260 def fnget_csz_(csz_text$*128,mat csz_results$)
71265 ! CSZ = City State &/Or Zip   !:
        ! (1)=City !:
        ! (2)=State !:
        ! (3)=Zip !:
        !  Returns 1 if the data is city, state, zip and 0 if not correct data
71270   mat csz_results$(3)=("") !:
        let set_fnget_csz = 0
71275   let fnparse_csz_$(csz_text$,mat csz_results$)
71280 CHECK_ZIP: ! 
71285   if (len(csz_results$(3))<>5 and len(srep$(csz_results$(3),"-",""))<>9) then !:
          goto X_FNGET_CSZ
71290 CHECK_STATE: ! 
71295   if csz_results$(2)="" then !:
          goto X_FNGET_CSZ
71300 SET_FNGET_CSZ: ! 
71305   let set_fnget_csz = 1
71310   goto X_FNGET_CSZ
71315 X_FNGET_CSZ: ! 
71320   if ~set_fnget_csz then !:
          mat csz_results$(3) = ("")
71325   let fnget_csz_ = set_fnget_csz
71330 fnend 
71620 def library fnpap_comment$*100(active_handle, fileno$, pf_code$; search_up_or_down)
71630 PAP_CMT: form pos 1,c 8,bh 4,pos 65,c 8,pos 17,c 48
71650   let fileno$=rpad$(trim$(fileno$),8)
71660   let pf_code$=uprc$(trim$(pf_code$))
71670   if search_up_or_down=-1 then ! search down (from end of matching filenos)
71680     let fileno_above$=fileno$(1:7)&chr$(ord(fileno$(8:8))+1)
71690     read #active_handle,using PAP_CMT,search>=fileno_above$,release: pfileno$,pdate,pcode$,pcmt$ nokey PC_RESTORE_LAST
71700 !   let pcode$=uprc$(trim$(pcode$))
71710     do 
71730       read #active_handle,using PAP_CMT,prior,release: pfileno$,pdate,pcode$,pcmt$ eof PAP_CMT_XIT
71740       let pcode$=uprc$(trim$(pcode$))
71750     loop until pfileno$<>fileno$
71760   else ! search up (from beginning of matching filenos)
71770     read #active_handle,using PAP_CMT,key=fileno$,release: pfileno$,pdate,pcode$,pcmt$ nokey PAP_CMT_XIT
71780     let pcode$=uprc$(trim$(pcode$))
71790     do until pfileno$<>fileno$
71810       read #active_handle,using PAP_CMT,release: pfileno$,pdate,pcode$,pcmt$ eof PAP_CMT_XIT
71820       let pcode$=uprc$(trim$(pcode$))
71830     loop 
71840   end if 
71850   goto PAP_CMT_XIT
71860 PC_RESTORE_LAST: ! 
71870   restore #active_handle,last: ioerr PAP_CMT_XIT
71880   continue  ! PC_RESTORE_LAST
71890 PAP_CMT_XIT: ! 
71900   let fnpap_comment$=trim$(pcmt$)
71910 fnend 
71920 def library fnhas_multiacct(fma_fileno$,fma_d_no,mat debtor_data$,mat debtor_data,fma_party_rel;fma_inf_field$)
71925   let fnhas_multiacct=fnhas_multiacct_(fma_fileno$,fma_d_no,mat debtor_data$,mat debtor_data,fma_party_rel,fma_inf_field$) !:
        ! Takes the given debtor and scans all other files by this debtor to determine if given party (or inf field) exists
71930 fnend 
71935 def fnhas_multiacct_(fma_fileno$,fma_d_no,mat debtor_data$,mat debtor_data,fma_party_rel;fma_inf_field$)
71940   dim new_fma_debtor_ssn$*17
71945   if ~setup_sql then 
71950     gosub SETUP_SQL
71955   end if 
71960 FMA_DFORM: form pos 1,c 8,pos 371,c 17
71965 FMA_INTFORM: form pos 24,bh 3
71970   open #fma_debtoridx_h:=fngethandle_: "Name=Debtor//6,KFNAME=Debtor.ssn//6,SHR",internal,input,keyed 
71975   open #h_internal:=fngethandle_: "NAME=INTERNAL//6,KFNAME=INTERNAL.IDX//6,shr",internal,input,keyed 
71980   let h_infinity=fnopen_infinity(mat generic_handle)
71985   let fma_has=0
71990   if fma_d_no>0 then 
71995     do while fma_has<=0
72000       read #fma_debtoridx_h,using FMA_DFORM,key=rpad$(debtor_data$(24),17),release: new_fma_fileno$,new_fma_debtor_ssn$ nokey X_FNHAS_MULTIACCT_ eof X_FNHAS_MULTIACCT_
72005       if trim$(fma_inf_field$)<>"" then 
72010         read #h_infinity,using RINFINITY,key=rpad$(new_fma_fileno$,8)&rpad$(fma_inf_field$,8),release: fma_inf_fileno$,fma_inf_type$,fma_inf_data$ nokey FMA_NEXT
72015         if trim$(fma_inf_data$)<>"" then 
72020           let fma_has=1
72025           goto X_FNHAS_MULTIACCT_
72030         end if  ! TRIM$(FMA_Inf_Data$)<>""
72035       else 
72040         do 
72045 FMA_READ_INTERNAL: ! 
72050           read #h_internal,using FMA_INTFORM,search=rpad$(fma_fileno$,8)&cnvrt$('N 3',fma_d_no)&cnvrt$('N 2',fma_party_rel),release: fma_party_no nokey FMA_NEXT eof FMA_NEXT
72055           if fma_party_no then 
72060             let fma_has=fma_party_no
72065             goto X_FNHAS_MULTIACCT_
72070           else 
72075             goto FMA_READ_INTERNAL
72080           end if  ! FMA_Party_No
72085         loop 
72090       end if  ! TRIM$(FMA_Inf_Field$)<>""
72095 FMA_NEXT: loop 
72100   end if  ! FMA_D_No>0
72105 X_FNHAS_MULTIACCT_: ! 
72110   let fnhas_multiacct_=fma_has
72115 fnend 
72200 def library fndraw_box(db_handle,winy,winx,rows,cols;attribute$*60)
72210   dim box_form$(99)*80,box_data$(99)*200
72220   if trim$(attribute$)="" then !:
          let attribute$="[W]"
72230 ! Build Top Line
72240   let box_line=0
72250   let box_form$(box_line+=1)=str$(winy)&","&str$(winx)&",C 1,"&attribute$ ! Top Left Corner
72260   let box_data$(box_line)=chr$(218)
72270   let box_form$(box_line+=1)=str$(winy)&","&str$(winx+1)&",C "&str$(cols-2)&","&attribute$ ! Top Line
72280   let box_data$(box_line)=rpt$(chr$(196),cols-2)
72290   let box_form$(box_line+=1)=str$(winy)&","&str$(winx+cols-1)&",C 1,"&attribute$ ! Top Right Left Corner
72300   let box_data$(box_line)=chr$(191)
72310 ! Build Bottom Line
72320   let box_form$(box_line+=1)=str$(winy+rows-1)&","&str$(winx)&",C 1,"&attribute$ ! Top Left Corner
72330   let box_data$(box_line)=chr$(192)
72340   let box_form$(box_line+=1)=str$(winy+rows-1)&","&str$(winx+1)&",C "&str$(cols-2)&","&attribute$ ! Top Line
72350   let box_data$(box_line)=rpt$(chr$(196),cols-2)
72360   let box_form$(box_line+=1)=str$(winy+rows-1)&","&str$(winx+cols-1)&",C 1,"&attribute$ ! Top Right Left Corner
72370   let box_data$(box_line)=chr$(217)
72380 ! Build Left & Right Lines
72390   for _line=1 to rows-2
72400 ! Left Line
72410     let box_form$(box_line+=1)=str$(winy+_line)&","&str$(winx)&",C 1,"&attribute$ ! Top Left Corner
72420     let box_data$(box_line)=chr$(179)
72430 ! RIght Line
72440     let box_form$(box_line+=1)=str$(winy+_line)&","&str$(winx+cols-1)&",C 1,"&attribute$ ! Top Right Left Corner
72450     let box_data$(box_line)=chr$(179)
72460   next _line
72470   mat box_form$(box_line) : mat box_data$(box_line)
72480   print #db_handle,fields mat box_form$: mat box_data$
72490 fnend  ! FNDraw_Box
